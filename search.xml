<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2020 02 &amp; 03 Reading</title>
      <link href="/2020/04/02/2020-02-03-Reading/"/>
      <url>/2020/04/02/2020-02-03-Reading/</url>
      
        <content type="html"><![CDATA[<blockquote><p>从2月7号开始，开始每天花一定的时间看书，想要养成读书的习惯，为了激励一下自己，所以在这里记录下 2、3 月份读的书。</p></blockquote><h2 id="2020-02"><a href="#2020-02" class="headerlink" title="2020-02"></a>2020-02</h2><blockquote><p>2月份读了10本书，大部分书都是在微信上看完的，当时应该有点刻意的让虚构和非虚构的数量相同，所以基本上是一本虚构、一本非虚构的。</p></blockquote><h3 id="《人生海海》"><a href="#《人生海海》" class="headerlink" title="《人生海海》"></a>《人生海海》</h3><blockquote><p>开始时间：2020-02-07</p><p>完成时间：2020-02-09</p><p>评分：★★★★☆</p></blockquote><p>发现了一个本土的好作家——麦家</p><h3 id="《牛奶可乐经济学》"><a href="#《牛奶可乐经济学》" class="headerlink" title="《牛奶可乐经济学》"></a>《牛奶可乐经济学》</h3><blockquote><p>开始时间：2020-02-11</p><p>完成时间：2020-02-17</p><p>评分：★★★☆☆</p></blockquote><p>一开始看感觉还挺好玩的，但看到3分之一时就觉得有些无趣了，可能因为经济学本来就不是什么太有趣的东西吧。ps：有种看十万个为什么的感觉。</p><h3 id="《白夜行》"><a href="#《白夜行》" class="headerlink" title="《白夜行》"></a>《白夜行》</h3><blockquote><p>开始时间：2020-02-17</p><p>完成时间：2020-02-20</p><p>评分：★★★★★</p></blockquote><p>东野圭吾的书，果然没让我失望，“枪虾和虾虎鱼的故事”，强烈推荐。</p><h3 id="《精进》"><a href="#《精进》" class="headerlink" title="《精进》"></a>《精进》</h3><blockquote><p>开始时间：2020-02-17</p><p>完成时间：2020-02-19</p><p>评分：★★★☆☆</p></blockquote><p>知乎式“干货”。第2，3章的一些观点感觉还不错，但后面真的是越看越无趣。</p><h3 id="《娱乐至死》"><a href="#《娱乐至死》" class="headerlink" title="《娱乐至死》"></a>《娱乐至死》</h3><blockquote><p>开始时间：2020-02-19</p><p>完成时间：2020-02-21</p><p>评分：★★★★★</p></blockquote><p>“人们感到痛苦的不是他们用笑声代替了思考，而是他们不知道自己为什么笑以及为什么不再思考。”</p><p>值得多读几遍的书籍。</p><h3 id="《美丽新世界》"><a href="#《美丽新世界》" class="headerlink" title="《美丽新世界》"></a>《美丽新世界》</h3><blockquote><p>开始时间：2020-02-21</p><p>完成时间：2020-02-28</p><p>评分：★★★★★</p></blockquote><p>看这本书是因为看了《娱乐至死》，hhh，貌似我在高中就看过开头，然而当时并没有看下去。</p><h3 id="《呼吸》"><a href="#《呼吸》" class="headerlink" title="《呼吸》"></a>《呼吸》</h3><blockquote><p>开始时间：2020-02-21</p><p>完成时间：2020-02-23</p><p>评分：★★★★☆</p></blockquote><p>看起来像是一部作品集，我对这本书的期望值好像有点过高了，有几篇读起来和寓言故事的感觉。恩，像是《一千零一夜》的感觉。</p><h3 id="《练习的心态》"><a href="#《练习的心态》" class="headerlink" title="《练习的心态》"></a>《练习的心态》</h3><blockquote><p>开始时间：2020-02-23</p><p>完成时间：2020-02-26</p><p>评分：★★★☆☆  </p></blockquote><p>翻译真的是太烂了吧，有些句子读起来都拗口难懂，书中观点也呈现的不够清晰（也可能是翻译的锅），不过感觉书中有些想法还是不错的，感觉看得下去完全是因为有些观点引起了共鸣。</p><h3 id="《月亮与六便士》"><a href="#《月亮与六便士》" class="headerlink" title="《月亮与六便士》"></a>《月亮与六便士》</h3><blockquote><p>开始时间：2020-02-29</p><p>结束时间：2020-03-01</p><p>评分：★★★★☆</p></blockquote><p>我看的那个版本似乎特别冷门，感觉之后可以找其他版本来看看。</p><h2 id="2020-03"><a href="#2020-03" class="headerlink" title="2020-03"></a>2020-03</h2><blockquote><p>这个月读书比较随意，经常同时读好几本书（后来感觉这样不好就改掉了），没想到这样还是读了10本。同时，因为购入了kpw4，所以有一半的书是在 Kindle 上读完的，而且也开始养成了睡前读书的习惯，10点半洗澡，洗完澡就爬到床上去读一个小时的书。感觉这样的生活还是很惬意的，emmm，虽然4月份就不一定有这种好氛围了，哎，美好的假期似乎要结束了。</p></blockquote><h3 id="《如何高效学习》"><a href="#《如何高效学习》" class="headerlink" title="《如何高效学习》"></a>《如何高效学习》</h3><blockquote><p>开始时间：2020-03-02</p><p>结束时间：2020-03-04</p><p>评分：★★★★☆</p></blockquote><p>我应该是第二遍读这本书了，看的时候不断地思考之前自己的做法，发现自己有段时间应该是在践行书中的一些观点的，但是后来似乎就没有有意识地去做这件事了。这也导致了自己有段时间也出现了死读书的情况，比如不思考地抄笔记，记录书中的观点什么的。</p><h3 id="《动物农场》"><a href="#《动物农场》" class="headerlink" title="《动物农场》"></a>《动物农场》</h3><blockquote><p>开始时间：2020-03-03</p><p>结束时间：2020-03-04</p><p>评分：★★★★★</p></blockquote><p>“目光从猪移到人，再从人移到猪，又重新从猪移到人，要分清哪张脸是猪的，哪张脸是人的，已经不可能了。”</p><p>看这本书最开始是因为想读这本书的原版，然而到现在都没开始（捂脸）。</p><h3 id="《掌控习惯》"><a href="#《掌控习惯》" class="headerlink" title="《掌控习惯》"></a>《掌控习惯》</h3><blockquote><p>开始时间：2020-03-04</p><p>结束时间：2020-03-15</p><p>评分：★★★★☆</p></blockquote><p>虽然看到后半部分就感觉有点无聊了，但是还是讲了许多关于习惯的技巧，比如想，将要养成的习惯挂在已经有的习惯后面等等。</p><h3 id="《孤独小说家》"><a href="#《孤独小说家》" class="headerlink" title="《孤独小说家》"></a>《孤独小说家》</h3><blockquote><p>开始时间：2020-03-04</p><p>结束时间：2020-03-07</p><p>评分：★★★★☆</p></blockquote><p>有点碎碎念的小说，看的时候感觉很平淡，但是莫名其妙看的进去。BTW，你要是说，这本书是耕平写的，我完全相信。</p><h3 id="《82年生的金智英》"><a href="#《82年生的金智英》" class="headerlink" title="《82年生的金智英》"></a>《82年生的金智英》</h3><blockquote><p>开始时间：2020-03-08</p><p>结束时间：2020-03-09</p><p>评分：★★★★☆</p></blockquote><p>一本很快就能看完的书，晚上睡前看了一会，然后早上起来看了一会就看完。虽然写的是韩国的事情，但是把地点改成中国也完全不会有违和感。</p><h3 id="《1984》"><a href="#《1984》" class="headerlink" title="《1984》"></a>《1984》</h3><blockquote><p>开始时间：2020-03-18</p><p>结束时间：2020-03-30</p></blockquote><p>看完《娱乐至死》就已经决定要看的书了，一开始有点略微无聊，不过看到后面就还好。</p><h3 id="《房思琪的初恋乐园》"><a href="#《房思琪的初恋乐园》" class="headerlink" title="《房思琪的初恋乐园》"></a>《房思琪的初恋乐园》</h3><blockquote><p>开始时间：2020-03-09</p><p>结束时间：2020-03-13</p><p>评分：★★★★★</p></blockquote><p>这个月让我印象最深刻的书，看这本书的这几天几乎陷进去了，那几天心情有点过于低落。这本书给人一种很奇怪的感觉，一开始看的时候会觉得作者的写作风格很奇怪，读到后半段的时候，会有种既厌恶又难以掩饰喜欢的感觉。</p><h3 id="《微习惯》"><a href="#《微习惯》" class="headerlink" title="《微习惯》"></a>《微习惯》</h3><blockquote><p>开始时间：2020-03-13</p><p>结束时间：2020-03-31</p><p>评分：★★★★☆</p></blockquote><p>很短的一本书，有种看博客集合的感觉，不过看完后，我也想试试“一个俯卧撑挑战”，hhh。</p><h3 id="《无人生还》"><a href="#《无人生还》" class="headerlink" title="《无人生还》"></a>《无人生还》</h3><blockquote><p>开始时间：2020-03-20</p><p>结束时间：2020-03-21</p><p>评分：★★★★☆</p></blockquote><p>士兵岛童谣杀人事件，估计是因为之前在其他地方看到过对这本书的模仿，所以看这本书的时候其实挺无感的。</p><h3 id="《禅与摩托车维修艺术》"><a href="#《禅与摩托车维修艺术》" class="headerlink" title="《禅与摩托车维修艺术》"></a>《禅与摩托车维修艺术》</h3><blockquote><p>开始时间：2020-03-21</p><p>结束时间：2020-03-26</p><p>评分：★★★★☆</p></blockquote><p>游记？哲学书？说实话有点没看懂，书中所说的“良质”是指“Good”吗？？</p><h3 id="总结-amp-Flag"><a href="#总结-amp-Flag" class="headerlink" title="总结 &amp; Flag"></a>总结 &amp; Flag</h3><p>2 月份和 3 月份读的书都是和专业无关的，以后可以稍微增加一点专业相关的书籍。</p><p>接下来是下个月想读的书：</p><ul><li><input disabled="" type="checkbox"> 别逗了，费曼先生</li><li><input disabled="" type="checkbox"> 黑客与画家</li><li><input disabled="" type="checkbox"> 肖申克的救赎</li><li><input disabled="" type="checkbox"> 非暴力沟通</li><li><input disabled="" type="checkbox"> 流浪地球</li><li><input disabled="" type="checkbox"> 乌合之众</li><li><input disabled="" type="checkbox"> Animal Farm</li><li><input disabled="" type="checkbox"> 学习之道</li><li><input disabled="" type="checkbox"> 深入浅出 Docker</li><li><input disabled="" type="checkbox"> MySQL 必知必会</li></ul><p>BTW, 想读 != 一定要读</p>]]></content>
      
      
      <categories>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Binary Search Tree Iterator</title>
      <link href="/2020/03/31/Binary-Search-Tree-Iterator/"/>
      <url>/2020/03/31/Binary-Search-Tree-Iterator/</url>
      
        <content type="html"><![CDATA[<blockquote><p>貌似又是一道之前做了，但是没写题解的题目。</p></blockquote><p>今天的题目是<a href="https://leetcode-cn.com/problems/binary-search-tree-iterator/" target="_blank" rel="noopener">Binary Search Tree Iterator</a>。</p><p>这道题要求我们按从小到大的顺序返回二叉搜索树的值，而我们知道二叉搜索树的中序遍历就是从小到大的，所以问题就变成了，对一个二叉树的中序遍历问题。</p><p>因为之前总结过<a href="https://blog.codeand.fun/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/">二叉树遍历</a>，所以这里我们可以套用当时提到的三种方法来解这道题：</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>由于题目只要求了<code>next()</code>和<code>hasNext()</code>的时间复杂度，所以我们可以在构造器中对二叉树进行遍历，然后存储下来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    BSTIterator(TreeNode* root) &#123;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        inorderTraversal(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;</span><br><span class="line">            inorderTraversal(root-&gt;left);</span><br><span class="line">            vec.push_back(root-&gt;val);</span><br><span class="line">            inorderTraversal(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vec[index++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index != vec.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样<code>next()</code>和<code>hasNext()</code>的时间复杂度肯定是<code>O(1)</code>的，但是空间复杂度却是<code>O(n)</code>，而题目要求的是<code>O(h)</code>。</p><h2 id="基于栈进行迭代。"><a href="#基于栈进行迭代。" class="headerlink" title="基于栈进行迭代。"></a>基于栈进行迭代。</h2><p>基于栈对二叉树进行迭代的中序遍历大体可以分为两部：</p><ol><li>不断地把先左节点移动，并把节点压入栈中（以下简称 step 1)。</li><li>弹出栈顶节点，并输出，然后先右节点方向移动（以下简称 step 2)。</li></ol><p>一旦做完以上两步，我们就输出了一个值。</p><p>因为当时是在一个循环中实现的，所以和现在的情况是不一样的，<code>root</code>是在构造器中输入的，所以我们得在构造器中就把<code>root</code>压入栈中，为了不把过程弄的复杂，所以我们在构造器中就直接把 step 1 给做完，然后在<code>next()</code>中把两步的顺序倒过来，即先执行 step 2 然后执行 step 1，当然 step 2 中的输出操作显然要放到最后来做。因为在两个地方都进行了 step 1，所以我们可以把它抽象成一个单独的函数<code>pushleft</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode *&gt; st;</span><br><span class="line">    BSTIterator(TreeNode* root) &#123;</span><br><span class="line">        pushleft(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushleft</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root) &#123;</span><br><span class="line">            st.push(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> root = st.top(); st.pop();</span><br><span class="line">        pushleft(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !st.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为基于栈的遍历算法的空间复杂度是<code>O(h)</code>，所以上面这个算法的空间复杂度也是<code>O(h)</code>（其实也很好理解，因为栈要临时存放节点个数最大就是 h），然后<code>hasNext()</code>的时间复杂度显然也是<code>O(1)</code>。下面的问题就是，<code>next()</code>的时间复杂度是否是<code>O(1)</code>。</p><p>如果我们仔细观察一下题目的话，我们会发现它要求的是平均时间复杂度，因为一颗有<code>n</code>个节点的树进行遍历，我们需要做<code>n</code>次<code>st.push</code>，同时<code>next()</code>我们也要调用<code>n</code>次才能遍历整棵树，所以<code>n / n = 1</code>，即平均时间复杂度为<code>O(1)</code>。</p><h2 id="莫里斯遍历"><a href="#莫里斯遍历" class="headerlink" title="莫里斯遍历"></a>莫里斯遍历</h2><p>我们先看下莫里斯遍历的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">GetRightLeaf</span><span class="params">(TreeNode *root, TreeNode *<span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root-&gt;right &amp;&amp; root-&gt;right != <span class="built_in">end</span>) root = root-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            TreeNode *p = GetRightLeaf(root-&gt;left, root);</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right == root) &#123;</span><br><span class="line">                p-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p-&gt;right = root;</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几乎可以什么都不用改的情况下，把代码移植过去：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode *root;</span><br><span class="line">    <span class="function">TreeNode *<span class="title">GetRightLeaf</span><span class="params">(TreeNode *root, TreeNode *end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root-&gt;right &amp;&amp; root-&gt;right != end) root = root-&gt;right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BSTIterator(TreeNode* _root):root(_root) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">                TreeNode *p = GetRightLeaf(root-&gt;left, root);</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;right == root) &#123;</span><br><span class="line">                    p-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; root-&gt;val &lt;&lt; endl;</span></span><br><span class="line">                    res = root-&gt;val;</span><br><span class="line">                    root = root-&gt;right;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    p-&gt;right = root;</span><br><span class="line">                    root = root-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; root-&gt;val &lt;&lt; endl;</span></span><br><span class="line">                res = root-&gt;val;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个的空间复杂度显然是<code>O(1)</code>，而时间复杂度，我们可以这样理解，每个节点都会被访问两遍，即<code>O(2n)</code>，而<code>next()</code>要调用 n 次，所以时间复杂度是<code>O(2n / 2) = O(2) = O(1)</code>。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Tree </tag>
            
            <tag> Stack </tag>
            
            <tag> Design </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Evaluate Reverse Polish Notation</title>
      <link href="/2020/03/31/Evaluate-Reverse-Polish-Notation/"/>
      <url>/2020/03/31/Evaluate-Reverse-Polish-Notation/</url>
      
        <content type="html"><![CDATA[<blockquote><p>因为最近在总结 LeetCode 中 <code>Stack</code> 标签下做过的题目，然后这道题做了但是没有写题解，所以补充一下。</p></blockquote><p>一道<code>Medium</code>的题目，但是数据结构课上提到栈时，都会举这个例子才对，所以这道题挺简单的。</p><p>因为输入的已经是解析好的<code>token</code>了，所以不用额外的做 parse 的工作。我们只需要用一个栈来保存操作树即可。</p><ul><li>当遇到一个操作数时，就压入栈中。</li><li>当遇到一个操作符时，就弹出两个操作数，然后根据操作符对这两个操作数进行操作，并将结果压入栈中。</li></ul><p>由于题目保证了输入一定是正确的，所以很多判断都可以省略掉。然后又一个需要主要的就是栈是后进先出的，所以操作数的顺序不要弄反了就好了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isOp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> s.<span class="built_in">size</span>() == <span class="number">1</span> &amp;&amp; (s[<span class="number">0</span>] == <span class="string">'+'</span> || s[<span class="number">0</span>] == <span class="string">'-'</span> || s[<span class="number">0</span>] == <span class="string">'*'</span> || s[<span class="number">0</span>] == <span class="string">'/'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span> op, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(op) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'+'</span>: <span class="keyword">return</span> a + b;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'-'</span>: <span class="keyword">return</span> a - b;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'*'</span>: <span class="keyword">return</span> a * b;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'/'</span>: <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;s: tokens) &#123;</span><br><span class="line"><span class="keyword">if</span> (!isOp(s)) &#123;</span><br><span class="line">st.push(atoi(s.c_str()));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> b = st.top(); st.pop();</span><br><span class="line"><span class="keyword">int</span> a = st.top(); st.pop(); </span><br><span class="line">st.push(calc(a, s[<span class="number">0</span>], b));</span><br><span class="line">&#125;  <span class="comment">// else return -1;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> st.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gitea + Drone CI/CD</title>
      <link href="/2020/03/27/Gitea-Drone-CI-CD/"/>
      <url>/2020/03/27/Gitea-Drone-CI-CD/</url>
      
        <content type="html"><![CDATA[<p>最近想实践一下 DevOps，所以准备搭建一套代码托管和CI/CD 系统。</p><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><h3 id="代码托管"><a href="#代码托管" class="headerlink" title="代码托管"></a>代码托管</h3><p>代码托管系统的选择其实并不多：</p><ul><li>Gitea</li><li>Gogs</li><li>GitLab</li></ul><p>由于 <code>Gitlab</code> 资源占用过大，所以可以直接去除（毕竟这个系统只有我一个人在用，而且只有一台1核2G的服务器）。</p><p><code>Gitea</code>是脱胎于<code>Gogs</code>的，在<code>Gogs</code>上做了较多的扩展，而且迭代的也毕竟快。<code>Gitea</code>对现有的代码托管做了<a href="https://docs.gitea.io/zh-cn/comparison/" target="_blank" rel="noopener">横向对比</a>,<br>我们可以看出来<code>Gitea</code>几乎是最优选择。</p><p><code>Gitea</code>有一个比较显著的缺点，它没有像<code>Gitlab</code>一样内置了<code>CI/CD</code>，所以我们必须搭另外一套<code>CI/CD</code>系统。</p><h3 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI/CD"></a>CI/CD</h3><p>对现有的 CI/CD 进行了一下调研:</p><ul><li>Jenkins<ul><li>优点：最为流行，出现坑的容易找到解决方案</li><li>缺点：用 Java 编写，过于笨重</li></ul></li><li>GitLab CI<ul><li>优点：据说很好用</li><li>缺点：笨重</li></ul></li><li>Drone<ul><li>优点：轻量级，支持<code>Gitea</code></li><li>缺点：生态不够丰富，文档差</li></ul></li></ul><p>在这里我们选择<code>Drone</code>作为<code>CI/CD</code>，主要原因当然是因为只有它轻量级啊。</p><h2 id="Gitea"><a href="#Gitea" class="headerlink" title="Gitea"></a>Gitea</h2><p>在安装<code>Gitea</code>和<code>Drone</code>时，我们都选择使用<code>docker-compose</code>来管理，因此需要先安装<code>docker</code>和<code>docker-compose</code>。</p><p>创建一个<code>gitea</code>文件夹，并在该文件夹下创建<code>docker-compose.yml</code>文件：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"2"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">gitea:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">gitea/gitea:1.11</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">USER_UID=1000</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">USER_GID=1000</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">RUN_MODE=prod</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SSH_PORT=</span> <span class="number">3022</span> <span class="comment">#SSH端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SSH_DOMAIN=</span> <span class="comment">#IP地址或URL</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DISABLE_REGISTRATION=False</span> <span class="comment">#取消注册</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">gitea</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./gitea:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/timezone:/etc/timezone:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime:ro</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"3000:3000"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"3022:3022"</span></span><br></pre></td></tr></table></figure><p>这里面需要注意的是，设置<code>SSH_PORT</code>和<code>SSH_DOMAIN</code>，这样 gitea 生成的 repo SSH 链接才是能直接使用的形式。</p><p>填写完后，直接<code>docker-compose up -d</code>开启服务即可，第一次登陆时，会跳出一个安装页面，可以设置所使用的数据库和管理员账号，同时要记得检查一下 SSH 端口和域名是否正确。</p><h2 id="Drone"><a href="#Drone" class="headerlink" title="Drone"></a>Drone</h2><p><code>Drone</code>的安装比<code>Gitea</code>复杂的多，同时需要先在<code>Gitea</code>中创建<code>OAuth2</code>应用程序：</p><p>打开<code>Gitea</code>的页面 -&gt; 个人信息 -&gt; 应用 -&gt; 管理 OAuth2 应用程序</p><p><img src="http://imagehosting.wuxiaobai24.fun/blogGitea-Drone-CI-CD-20200327211442-2020-03-27" alt="Gitea-Drone-CI-CD-20200327211442-2020-03-27"></p><p>应用名称填什么都无所谓，但是重定向 URL 比较重要，要填 <code>Drone</code>服务的地址（虽然现在还没启动），比如说，你的 Drone 的 <code>ip</code> 地址为<code>1.2.3.4</code>，<code>Drone</code>端口的为<code>8000</code>，<br>那么就可以填<code>http://1.2.3.4:8000</code>。</p><p>创建后会得到一个客户端ID和客户端密钥。这时，<code>Gitea</code>的设置就已经完成了。</p><p>为了让<code>Drone Server</code>和<code>Drone Runer</code>能够通过<code>RPC</code>连接，我们需要生成<code>RPC</code>密钥，可以在 shell 中使用该命令来生成随机数，用该随机数作为 RPC 的密钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ openssl rand -hex 16</span><br></pre></td></tr></table></figure><p>上面的操作中可以得到：</p><ul><li>客户端 ID</li><li>客户端密钥</li><li>RPC 密钥</li></ul><p>创建一个<code>drone</code>文件夹并在其中创建一个<code>docker-compose.yml</code>文件：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.5"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">drone:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">drone_network</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span> </span><br><span class="line">  <span class="attr">drone-server:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">drone/drone:1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8000</span><span class="string">:80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">443</span><span class="string">:443</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">drone</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./drone-data:/var/lib/drone</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_GITEA_CLIENT_ID=</span> <span class="comment"># Gitea 客户端ID</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_GITEA_CLIENT_SECRET=</span> <span class="comment"># Gitea 客户端密钥</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_GITEA_SERVER=</span> <span class="comment"># Gitea URL 地址</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_GITEA=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_RPC_SECRET=</span> <span class="comment"># Drone RPC 密钥</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_SERVER_HOST=</span> <span class="comment"># Drone URL,可以填域名或 ip:port</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DRONE_SERVER_PROTO=http</span> <span class="comment"># Drone 所使用的协议 http 或者 https</span></span><br><span class="line">  <span class="comment"># 由于我的 Gitea 的设置是只允许登陆用户访问代码的，所以 Git 需要 Auth</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_GIT_ALWAYS_AUTH=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_GIT_USERNAME=</span> <span class="comment"># Gitea 用户名</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_GIT_PASSWORD=</span> <span class="comment"># Gitea 密码</span></span><br><span class="line">  <span class="attr">drone-agent:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">drone/drone-runner-docker:1</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">depends_on:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">drone-server</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">drone</span></span><br><span class="line">    <span class="attr">volumes:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">    <span class="attr">environment:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_RPC_SECRET=</span> <span class="comment"># 这里的密钥要和 Server 一样</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_RPC_PROTO=http</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DRONE_RPC_HOST=</span> <span class="comment"># 和上面的 DRONE_SERVER_HOST</span></span><br></pre></td></tr></table></figure><p>和<code>Gitea</code>同理，我们只需要在<code>docker-compose up -d</code>即可。</p><p>第一次打开 Drone 会先跳到 Gitea 进行验证。由于打开 Drone 会验证 Gitea 是否登陆，所以不用担心 Drone 的页面直接暴露到公网。</p><h3 id="测试-Drone-和-Gitea"><a href="#测试-Drone-和-Gitea" class="headerlink" title="测试 Drone 和 Gitea"></a>测试 Drone 和 Gitea</h3><ol><li>在 Gitea 中创建一个 repo</li><li>在 Drone 激活该 repo</li><li>创建公钥并加入到 gitea 中（这一步和 Github 类似）</li><li>将 repo clone 到本地</li><li>创建一个<code>.drone.yml</code>文件：</li><li>git commit and push</li></ol><p><code>.drone.yml</code>的样例如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">pipeline</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">docker</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">default</span></span><br><span class="line"></span><br><span class="line"><span class="attr">steps:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">greeting</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line">  <span class="attr">commands:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">echo</span> <span class="string">hello</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">echo</span> <span class="string">world</span></span><br></pre></td></tr></table></figure><p>关于<code>.drone.yml</code>的信息可以查看<a href="https://docs.drone.io/" target="_blank" rel="noopener">官方文档</a>。</p><p>之后估计也会写一篇 blog 对 Drone 的使用进行下总结。</p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gitea </tag>
            
            <tag> Drone </tag>
            
            <tag> CI/CD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Binary Tree (Preorder|Inorder|Postorder) Traversal</title>
      <link href="/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/"/>
      <url>/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/</url>
      
        <content type="html"><![CDATA[<p>今天将二叉树的先、中、后遍历的做了一些总结。三种遍历都有三种写法：</p><ul><li>递归<ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(h)</code>，<code>h</code>为树高</li></ul></li><li>基于栈进行迭代：<ul><li>时间复杂度:<code>O(n)</code></li><li>空间复杂度：<code>O(n)</code></li></ul></li><li>莫里斯算法：<ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(1)</code></li></ul></li></ul><p>接下来内容有一下几个部分组成：</p><ol><li>首先介绍二叉树先、中、后序遍历的含义</li><li>递归算法</li><li>基于栈的迭代算法</li><li>莫里斯算法</li></ol><h2 id="二叉树-amp-先、中、后序遍历"><a href="#二叉树-amp-先、中、后序遍历" class="headerlink" title="二叉树 &amp; 先、中、后序遍历"></a>二叉树 &amp; 先、中、后序遍历</h2><p><img src="https://g.gravizo.com/svg?digraph%20G%20%7B%20node%5Bshape=circle%5D%20edge%5Barrowhead=vee%5D%201-%3E2;%201-%3E5;%202-%3E3;%202-%3E4;%20%7D" alt=""></p><ul><li><p>先序遍历：</p><blockquote><ol><li>访问当前节点</li><li>遍历左子树</li><li>遍历右子树</li></ol></blockquote></li><li><p>中序遍历：</p><blockquote><ol><li>遍历左子树</li><li>访问当前节点</li><li>遍历右子树</li></ol></blockquote></li><li><p>后序遍历：</p><blockquote><ol><li>遍历左子树</li><li>遍历右子树</li><li>访问当前节点</li></ol></blockquote></li></ul><p>如上图中显示的二叉树中，先、中、后序遍历分别为：</p><ul><li>先序：<code>1 2 3 4 5</code></li><li>中序：<code>3 2 4 1 5</code></li><li>后序：<code>3 4 2 5 1</code></li></ul><h2 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h2><p>已知三种遍历的含义之后，我们可以很容易的写出三种遍历的递归算法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prevorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        prevorderTraversal(root-&gt;left);</span><br><span class="line">        prevorderTraversal(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        inorderTraversal(root-&gt;left);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        inorderTraversal(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        postorderTraversal(root-&gt;left);</span><br><span class="line">        postorderTraversal(root-&gt;right);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于递归算法比较简单，所以这里不做过多的说明。</p><p>为了方便，访问节点时，只是输出节点的值。</p></blockquote><h2 id="基于栈的迭代算法"><a href="#基于栈的迭代算法" class="headerlink" title="基于栈的迭代算法"></a>基于栈的迭代算法</h2><h3 id="基于栈的迭代算法——先序遍历"><a href="#基于栈的迭代算法——先序遍历" class="headerlink" title="基于栈的迭代算法——先序遍历"></a>基于栈的迭代算法——先序遍历</h3><p>基于栈的遍历算法中，先序遍历是最简单的。因为先序遍历本身可以进行尾递归优化，所以很容易用<code>stack</code>对递归调用进行模拟：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode *&gt; st;</span><br><span class="line">    <span class="keyword">if</span> (root) st.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!st.empty()) &#123;</span><br><span class="line">        root = st.top(); st.pop();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) st.push(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) st.push(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，因为栈用后进先出的特性，所以要先将右子树压入栈中，然后再将左子树压入栈中。</p><h3 id="基于栈的迭代算法——中序遍历"><a href="#基于栈的迭代算法——中序遍历" class="headerlink" title="基于栈的迭代算法——中序遍历"></a>基于栈的迭代算法——中序遍历</h3><p><img src="http://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328094051-2020-03-28" alt="Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328094051-2020-03-28"></p><p>我们以上图为例子，其中圆圈表示树中的节点，而三角形表示子树。其中的序号为访问顺序，我们可以发现，进行中序遍历的二叉树都符合这样的移动规律：</p><ol><li>先一直往左孩子的方向移动，直到没有左孩子。</li><li>然后访问该节点，并遍历其右子树（这时相当于对其右子树进行 1、2、3步）。</li><li>最后返回到其父节点并从第 2 步开始。</li></ol><p>为了方便实现和代码的简洁，我们可以把观察到规律转换一下：</p><ol><li>先一直往左孩子的方向移动，直到当前节点为空，同时把所有经过的节点压入栈中。</li><li>如果栈不空，则将栈顶弹出并访问，向右孩子移动并返回第一步。</li></ol><p>因此我们可以写出如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode *&gt; st;</span><br><span class="line">    <span class="keyword">while</span>(root || !st.empty()) &#123;</span><br><span class="line">        <span class="keyword">while</span>(root) &#123;</span><br><span class="line">            st.push(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 栈一定不为空</span></span><br><span class="line">        root = st.top(); st.pop();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于栈的迭代算法——后序遍历"><a href="#基于栈的迭代算法——后序遍历" class="headerlink" title="基于栈的迭代算法——后序遍历"></a>基于栈的迭代算法——后序遍历</h3><p><img src="http://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328094135-2020-03-28" alt="Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328094135-2020-03-28"></p><p>后序遍历与中序遍历有些类似，同样需要先一直往左孩子方向移动直到没有左孩子，但是后序遍历要先访问完右子树才能访问当前节点，因此对于栈顶节点是否要访问并弹出，我们需要判断其右子树是否被访问了。同时，因为后序遍历中，一颗树的根节点是最后访问的，所以我们可以根据右孩子是否被访问了来判断右子树是否被访问了。而我们知道，当访问完右孩子，就可以马上访问该节点了，所以我们可以维护一个指针，该指针指向上一次被访问的节点。通过判断上一次被访问的节点是否为右子树或者<code>nullpter</code>，我们就可以知道是否要访问该节点并弹栈了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    TreeNode *prev = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode *&gt; st;</span><br><span class="line">    <span class="keyword">while</span>(root || !st.empty()) &#123;</span><br><span class="line">        <span class="keyword">while</span>(root) &#123;</span><br><span class="line">            st.push(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = st.top();</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span> || root-&gt;right == prev) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; root &lt;&lt; right &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            prev = root;</span><br><span class="line">            root = <span class="literal">nullptr</span>;</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="莫里斯算法"><a href="#莫里斯算法" class="headerlink" title="莫里斯算法"></a>莫里斯算法</h2><p>莫里斯算法是一种用时间来换空间的二叉树遍历算法。他只需要<code>O(1)</code>的空间复杂度。</p><p>个人觉得它非常像中序线索树，所以我们先介绍中序线索树，然后再来理解莫里斯遍历。</p><h3 id="中序线索树"><a href="#中序线索树" class="headerlink" title="中序线索树"></a>中序线索树</h3><p>假设一颗二叉树有<code>N</code>个节点，因为每个节点有 2 个指向孩子的指针，所以我们就有了 <code>2*N</code> 个指向节点的指针。同时，因为根节点不需要指针指向它，所以我们就使用了<code>2*N - (N-1) = N + 1</code>个空指针。线索树的想法就是将这些空指针利用上，来加快遍历速度的。</p><p><img src="http://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328104922-2020-03-28" alt="Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328104922-2020-03-28"></p><p>对于上面的二叉树来说，其中序遍历的结果为<code>[6 4 7 2 5 8 9 1 3]</code>。</p><p>如果节点 A 被访问后，马上访问 B，我们就认为 A 是 B 的前驱，B 是 A 的后继。从中序遍历的结果可以看出 6 是 4 的前驱，4 是 6 的后继。</p><p><img src="http://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328105557-2020-03-28" alt="Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328105557-2020-03-28"></p><p>上图中，红色虚线表示后继，绿色虚线表示前驱，一般我们将前驱放在左孩子，后继放在右孩子中。为了区分一个节点的两个孩子指针到底是真的孩子，还是线索，一般需要在每个节点中增加两个flag 位来区分。</p><h3 id="莫里斯算法——中序遍历"><a href="#莫里斯算法——中序遍历" class="headerlink" title="莫里斯算法——中序遍历"></a>莫里斯算法——中序遍历</h3><p>因为中序线索树需要给每个节点都增加两个<code>flag</code>，但是因为很多时候我们不能修改二叉树节点的数据结构，所以它在很多情况是不适合的。通过观察我们可以发现，<strong>在建立完中序线索树后，一个节点的左子树中最右边的节点的后继线索是总指向该节点的</strong>。我们可以根据这个规律来判断当前节点是否需要访问，是向左孩子移动还是向右孩子移动。同时，因为遍历时不需要用到前驱，所以我们不用建立前驱的节点，只需要建立后继即可。</p><p><img src="http://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328112150-2020-03-28" alt="Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328112150-2020-03-28"></p><p>当我们访问节点<code>root</code>的时候：</p><ul><li>如果它有左孩子，则找出左子树中最右边节点，并将该节点的右孩子设置为<code>root</code>（建立线索），并向左孩子移动。</li><li>如果它有左孩子，同时在找出左子树最右边节点的时候，如果发现某个节点的右孩子为<code>root</code>，则表示为该节点为左子树的最右边的节点，且已经建立了线索。这表示我们已经访问过左子树了。我们可以清除线索，访问<code>root</code>节点，并向右子树移动。</li><li>如果它没有左孩子，则直接访问<code>root</code>，并向右子树移动。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">GetRightLeaf</span><span class="params">(TreeNode *root, TreeNode *<span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root-&gt;right &amp;&amp; root-&gt;right != <span class="built_in">end</span>) root = root-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            TreeNode *p = GetRightLeaf(root-&gt;left, root);</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right == root) &#123;</span><br><span class="line">                p-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p-&gt;right = root;</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="莫里斯算法——先序遍历"><a href="#莫里斯算法——先序遍历" class="headerlink" title="莫里斯算法——先序遍历"></a>莫里斯算法——先序遍历</h3><p>在莫里斯算法中，先序遍历与中序遍历非常想，只是访问<code>root</code>的节点的位置变了。在中序遍历中，我们总是在向右子树移动的时候访问<code>root</code>节点。而在先序遍历的中，我们总是在向左子树移动的时候访问<code>root</code>。当然，在没有左孩子的情况时，一样也是先访问<code>root</code>节点，再想右孩子移动。</p><p>当我们访问节点<code>root</code>的时候：</p><ul><li>如果它有左孩子，则找出左子树中最右边节点，并将该节点的右孩子设置为<code>root</code>（建立线索），访问<code>root</code>节点，并向左孩子移动。</li><li>如果它有左孩子，同时在找出左子树最右边节点的时候，如果发现某个节点的右孩子为<code>root</code>，则表示为该节点为左子树的最右边的节点，且已经建立了线索。这表示我们已经访问过左子树了。我们可以清除线索，并向右子树移动。</li><li>如果它没有左孩子，则直接访问<code>root</code>，并向右子树移动。</li></ul><p>因此代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">GetRightLeaf</span><span class="params">(TreeNode *root, TreeNode *<span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root-&gt;right &amp;&amp; root-&gt;right != <span class="built_in">end</span>) root = root-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root) &#123;    </span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            <span class="comment">// if (root-&gt;right == nullptr) cout &lt;&lt; "NULL" &lt;&lt; endl;</span></span><br><span class="line">            TreeNode *p = GetRightLeaf(root-&gt;left, root);</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right == root) &#123;</span><br><span class="line">                p-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p-&gt;right = root;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="莫里斯遍历——后序遍历"><a href="#莫里斯遍历——后序遍历" class="headerlink" title="莫里斯遍历——后序遍历"></a>莫里斯遍历——后序遍历</h3><p><img src="http://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328115304-2020-03-28" alt="Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328115304-2020-03-28"></p><p>通过观察，我们可以发现先、中、后序遍历有上面这种规律，因此我们可以发现，当所有左子树被访问完了（这时只剩下一条由右孩子组成的边，这里为了简便，将其称为，右边），按逆序访问由右边即可。</p><p>当我们访问节点<code>root</code>的时候：</p><ul><li>如果它有左孩子，则找出左子树中最右边节点，并将该节点的右孩子设置为<code>root</code>（建立线索），并向左孩子移动。</li><li>如果它有左孩子，同时在找出左子树最右边节点的时候，如果发现某个节点的右孩子为<code>root</code>，则表示为该节点为左子树的最右边的节点，且已经建立了线索。这表示我们已经访问过左子树了。我们可以清除线索，<strong>逆序访问左子树的右边。</strong></li><li>如果它没有左孩子，并向右子树移动。</li></ul><p>按上面的算法进行的话，会导致有一条右边没办法访问到，所以增加一个虚节点，该虚节点的左孩子为<code>root</code>,右孩子为空，即：</p><p><img src="http://imagehosting.wuxiaobai24.fun/blogBinary-Tree-Preorder-Inorder-Postorder-Traversal-20200328120751-2020-03-28" alt="Binary-Tree-Preorder-Inorder-Postorder-Traversal-20200328120751-2020-03-28"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">GetRightLeaf</span><span class="params">(TreeNode *root, TreeNode *<span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root-&gt;right &amp;&amp; root-&gt;right != <span class="built_in">end</span>) root = root-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode *<span class="title">reverse</span><span class="params">(TreeNode *p, <span class="keyword">const</span> function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; &amp;func)</span> </span>&#123;</span><br><span class="line">    TreeNode *prev, *next;</span><br><span class="line">    prev = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        func(p-&gt;val);</span><br><span class="line">        next = p-&gt;right;</span><br><span class="line">        p-&gt;right = prev;</span><br><span class="line">        prev = p;</span><br><span class="line">        p = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal2</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="function">TreeNode <span class="title">node</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    node.left = root;</span><br><span class="line">    root = &amp;node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> func1 = [&amp;](<span class="keyword">int</span> val) &#123;</span><br><span class="line">        res.push_back(val);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> func2 = [](<span class="keyword">int</span> val) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            TreeNode *p = GetRightLeaf(root-&gt;left, root);</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right == root) &#123;</span><br><span class="line">                p-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                p = reverse(root-&gt;left, func2);</span><br><span class="line">                reverse(p, func1);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p-&gt;right = root;</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了使得空间复杂度为<code>O(1)</code>，在逆序访问时，我们通过“翻转链表”的方式进行逆序访问，而不是用栈来实现。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Tree </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode Stack Tag 总结</title>
      <link href="/2020/03/23/LeetCode-Stack-Tag-%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/23/LeetCode-Stack-Tag-%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>准备按 Tag 过一遍之前刷过的 LeetCode，总结一些常用的技巧和套路。</p></blockquote><h2 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h2><table><thead><tr><th align="left">Name</th><th align="left">No</th><th align="left">Difficulty</th><th align="left">Blog Link</th><th align="left">Note</th></tr></thead><tbody><tr><td align="left"><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">Valid Parentheses</a></td><td align="left">20</td><td align="left">Easy</td><td align="left"><a href="https://blog.codeand.fun/2017/09/24/Valid-Parentheses/">https://blog.codeand.fun/2017/09/24/Valid-Parentheses/</a></td><td align="left">可以建一个右括号到左括号的<code>map</code>来使代码更加简洁</td></tr><tr><td align="left"><a href="https://leetcode-cn.com/problems/simplify-path/" target="_blank" rel="noopener">Simplify Path</a></td><td align="left">71</td><td align="left">Medium</td><td align="left"><a href="https://blog.codeand.fun/2019/03/02/Simplify-Path/">https://blog.codeand.fun/2019/03/02/Simplify-Path/</a></td><td align="left">用FSM的思想也可以解，可以用<code>stringstream</code>和<code>getline</code>进行字符串分割</td></tr><tr><td align="left"><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">Binary Tree Inorder Traversal</a></td><td align="left">94</td><td align="left">Medium</td><td align="left"><a href="https://blog.codeand.fun/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/">https://blog.codeand.fun/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/</a></td><td align="left">递归、栈、莫里斯遍历</td></tr><tr><td align="left"><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener"> Binary Tree Zigzag Level Order Traversal</a></td><td align="left">103</td><td align="left">Medium</td><td align="left"><a href="https://blog.codeand.fun/2018/02/11/Binary-Tree-Zigzag-Level-Order-Traversal/">https://blog.codeand.fun/2018/02/11/Binary-Tree-Zigzag-Level-Order-Traversal/</a></td><td align="left">用栈来模拟，可以避免逆序操作</td></tr><tr><td align="left"><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">Binary Tree Preorder Traversal</a></td><td align="left">144</td><td align="left">Medium</td><td align="left"><a href="https://blog.codeand.fun/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/">https://blog.codeand.fun/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/</a></td><td align="left">递归、栈、莫里斯遍历</td></tr><tr><td align="left"><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal" target="_blank" rel="noopener">Binary Tree Postorder Traversal</a></td><td align="left">145</td><td align="left">Medium</td><td align="left"><a href="https://blog.codeand.fun/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/">https://blog.codeand.fun/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/</a></td><td align="left"><code>function</code>对象+<code>lambda</code>表达式可以减少代码冗余。</td></tr><tr><td align="left"><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">Evaluate Reverse Polish Notation</a></td><td align="left">150</td><td align="left">Medium</td><td align="left"><a href="https://blog.codeand.fun/2020/03/31/Evaluate-Reverse-Polish-Notation/">https://blog.codeand.fun/2020/03/31/Evaluate-Reverse-Polish-Notation/</a></td><td align="left"></td></tr><tr><td align="left"><a href="https://leetcode-cn.com/problems/binary-search-tree-iterator/" target="_blank" rel="noopener">Binary Search Tree Iterator</a></td><td align="left">173</td><td align="left">Medium</td><td align="left"><a href="https://blog.codeand.fun/2020/03/31/Binary-Search-Tree-Iterator/">https://blog.codeand.fun/2020/03/31/Binary-Search-Tree-Iterator/</a></td><td align="left">可以用递归、栈和莫里斯遍历来实现中序遍历</td></tr><tr><td align="left"><a href="https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/" target="_blank" rel="noopener">Verify Preorder Serialization of a Binary Tree</a></td><td align="left">331</td><td align="left">Medium</td><td align="left"><a href="https://blog.codeand.fun/2018/02/19/Verify-Preorder-Serialization-of-a-Binary-Tree/">https://blog.codeand.fun/2018/02/19/Verify-Preorder-Serialization-of-a-Binary-Tree/</a></td><td align="left">??这道题和栈好像没有关系啊，不用栈去想反而更简单更快</td></tr><tr><td align="left"><a href="https://leetcode-cn.com/problems/flatten-nested-list-iterator/" target="_blank" rel="noopener">Flatten Nested List Iterator</a></td><td align="left">341</td><td align="left">Medium</td><td align="left"></td><td align="left"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《 Java 编程思想》CH09 接口</title>
      <link href="/2020/02/19/%E3%80%8A-Java-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8BCH09-%E6%8E%A5%E5%8F%A3/"/>
      <url>/2020/02/19/%E3%80%8A-Java-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8BCH09-%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p><strong>接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法。</strong></p><h2 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h2><p>Java 提供一个叫做“抽象方法”的机制来建立通用接口，这样不同的子类可以用不同的方式表示此接口。如<code>abstract void fun()</code>。<br>包含抽象方法的类叫做抽象类，如果一个类包含一个或多个抽象方法，则该类必须限定为抽象的，如<code>abstract class ClassName</code>。</p><p>如果一个从一个抽象类中继承，我们需要为基类中所有的抽象方法提供定义，否则该导出类也是抽象类，需要用<code>abstract</code>进行限定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">what</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Instrument"</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><code>interface</code>关键字可以产生一个完全抽象的类，它允许创建者确定方法名，参数列表和返回类型，但是没有任何方法体。<strong>接口只提供了形式，但是没有提供任何实现</strong>。通常，接口被用来建立类之间的协议。之所以有了抽象类后还需要接口是因为：<strong>一个类可以实现多个接口，从而实现类似多继承的特性</strong>。</p><p>接口有两种访问权限：</p><ul><li>public</li><li>包访问权限</li></ul><p>接口中可以包含域，但是这些域隐式地是<code>public</code>和<code>static</code>的。接口中的方法是<code>public</code>的，因此类在实现接口时，必须指定方法为<code>public</code>的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InstrumentInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> VALUE = <span class="number">5</span>; <span class="comment">// static final public</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span></span>; <span class="comment">// public</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">implements</span> <span class="title">InstrumentInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Wind.play() n = "</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Wind"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完全解耦"><a href="#完全解耦" class="headerlink" title="完全解耦"></a>完全解耦</h2><p>策略设计模式：创建一个能够根据所传递的参数对象的不同而具有不同行为的方法。这类方法包含要执行算法中固定不变的部分，而“策略”包含变化的部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch09;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Object <span class="title">process</span><span class="params">(Object input)</span> </span>&#123; <span class="keyword">return</span> input; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Upcase</span> <span class="keyword">extends</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">process</span><span class="params">(Object input)</span> </span>&#123; <span class="comment">// 协变返回类型</span></span><br><span class="line">        <span class="keyword">return</span> ((String) input).toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Downcase</span> <span class="keyword">extends</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((String) input).toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Splitter</span> <span class="keyword">extends</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.toString(((String) input).split(<span class="string">" "</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apply</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Processor p, Object s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Using Processor p.name() = "</span> + p.name());</span><br><span class="line">        System.out.println(p.process(s));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String s = <span class="string">"Disagreement with beliefs is by definition incorrect"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        process(<span class="keyword">new</span> Upcase(), s);</span><br><span class="line">        process(<span class="keyword">new</span> Downcase(), s);</span><br><span class="line">        process(<span class="keyword">new</span> Splitter(), s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>Filter</code>类与<code>Processer</code>有相同的接口，但是它不是继承与<code>Processer</code>，那么它就不能被<code>Apply.proceess</code>所使用。这是因为<code>Processer</code>和<code>Apply</code>过于耦合了，而导致我们没法复用代码。我们可以将<code>Processer</code>转变成接口来解耦。我们可以依据接口来实现<code>Filter</code>，也可以用适配器设计模式来完成。设配器中代码将接收已有的接口/代码，实现需要的接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class FilterAdapter implements Processor &#123;</span><br><span class="line">  Filter filter;</span><br><span class="line">  public FilterAdapter(Filter filter) &#123;</span><br><span class="line">    this.filter &#x3D; filter;</span><br><span class="line">  &#125;</span><br><span class="line">  public String name() &#123;</span><br><span class="line">    return filter.name();</span><br><span class="line">  &#125;</span><br><span class="line">  public Waveform process(Object object) &#123;</span><br><span class="line">    return filter.process((Waveform)objec);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-中的多重继承"><a href="#Java-中的多重继承" class="headerlink" title="Java 中的多重继承"></a>Java 中的多重继承</h2><p>Java 可以组合多个接口来实现了类似C++中的多继承。</p><ul><li>实现一个接口需要保证接口中所有方法类中都有，<strong>该方法可以继承自基类</strong>。</li><li>使用接口的原因：<ul><li>为了能够向上转型为多个基类</li><li>防止客户端创建该类的对象，并确保这个仅仅是一个接口</li></ul></li><li>如果要创建不带任何方法定义和成员变量的基类，那就应该选择接口而不是抽象类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch09;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanFight</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanSwim</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanFly</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActionCharacter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hero</span> <span class="keyword">extends</span> <span class="title">ActionCharacter</span> <span class="keyword">implements</span> <span class="title">CanFight</span>, <span class="title">CanFly</span>, <span class="title">CanSwim</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意到这里fight()函数是继承与ActionCharac</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adventure</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">t</span><span class="params">(CanFight x)</span> </span>&#123;</span><br><span class="line">        x.fight();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">u</span><span class="params">(CanSwim x)</span> </span>&#123;</span><br><span class="line">        x.swim();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">v</span><span class="params">(CanFly x)</span> </span>&#123;</span><br><span class="line">        x.fly();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">(ActionCharacter x)</span> </span>&#123;</span><br><span class="line">        x.fight();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hero h = <span class="keyword">new</span> Hero();</span><br><span class="line">        t(h);</span><br><span class="line">        u(h);</span><br><span class="line">        v(h);</span><br><span class="line">        w(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过继承来扩展接口"><a href="#通过继承来扩展接口" class="headerlink" title="通过继承来扩展接口"></a>通过继承来扩展接口</h2><ul><li>接口可以继承一个或多个接口</li><li>接口中方法签名同样是由函数名和参数列表组成的，因此如果两个接口有相同函数名和参数类型的方法，并且返回类型不相同的话，则不能同时<code>implement</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanFight</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanSwim</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanFightAndSwim</span> <span class="keyword">extends</span> <span class="title">CanFight</span>, <span class="title">CanSwim</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口中的域"><a href="#接口中的域" class="headerlink" title="接口中的域"></a>接口中的域</h2><p>接口中的的域都是 static 和 final 的，所以接口用来创建常量组，接口中定义的域不能是”空final“，但是可以被非常量表达式初始化。现在建议使用<code>enum</code>来创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RandVals</span> </span>&#123;</span><br><span class="line">  Random RAND = <span class="keyword">new</span> Random(<span class="number">24</span>);</span><br><span class="line">  <span class="keyword">int</span> RANDOM_INT = RAND.nextInt(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">long</span> RANDOM_LONG = RAND.nextLong(<span class="number">20</span>) * <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="嵌套接口"><a href="#嵌套接口" class="headerlink" title="嵌套接口"></a>嵌套接口</h2><p>接口可以嵌套在类或其他皆苦中。</p><p>嵌套在类中的接口除了 public 和包访问权限，还有 private 访问权限。</p><p>嵌套在接口中的接口自动是 public 访问权限。</p>]]></content>
      
      
      <categories>
          
          <category> 《Java编程思想》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 阅读笔记 </tag>
            
            <tag> 《Java编程思想》 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《 Java 编程思想》CH08 多态</title>
      <link href="/2020/02/18/%E3%80%8A-Java-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8BCH08-%E5%A4%9A%E6%80%81/"/>
      <url>/2020/02/18/%E3%80%8A-Java-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8BCH08-%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<ul><li>在面向对象的程序设计语言中，多态是继数据抽象和继承之后的第三种基本特征。</li><li>多态通过分离做什么和怎么做，从另一个角度将接口和实现分离开来。</li><li>“封装”通过合并特征和行为来创建新的数据类型。“实现隐藏”则通过将细节“私有化”把接口和实现分离开来，而多态的作用则是消除类型之间的耦合关系。</li></ul><h2 id="再论向上转型-amp-转机"><a href="#再论向上转型-amp-转机" class="headerlink" title="再论向上转型 &amp; 转机"></a>再论向上转型 &amp; 转机</h2><ul><li>对象既可以作为它自己本身的类型使用，也可以作为它的基类使用，而这种把某个对象的引用视为其基类的引用的做法被称为“向上转型”</li><li>将一个方法调用同一个方法主体关联起来被称为<strong>绑定</strong>。<ul><li>若在程序执行前进行绑定（如果有的话，由编译器和链接器实现），叫做<strong>前期绑定</strong>。</li><li>若在运行时根据对象的类型进行绑定，则叫做<strong>后期绑定</strong>，也叫做<strong>动态绑定</strong>或<strong>运行时绑定</strong>。</li></ul></li><li>Java 中除了 static 方法和 final 方法（private 方法属于 final 方法）外，其他所有方法都是后期绑定的。</li><li>Java 用动态绑定实现了多态后，我们可以只编写与基类相关的代码，而这些代码可以对所有该基类的导出类正确运行。</li><li>多态的例子可以参考练习2。</li><li>在一个设计良好的 OOP 程序中，大多数或所有方法都只与基类接口通信。这样的程序是可扩展的，因为可以从通用的基类继承出新的数据类型，从而新添加一些功能。</li><li>域没有多态。</li><li>如果一个方法是静态的，那么它的行为就不具有多态性。静态方法是与类，而不是与单个对象相关联的。</li><li>由于 final 方法是无法覆盖的，所以 private 也是无法覆盖的，因此没办法进行动态绑定。即只有非 private 方法可以覆盖，但是“覆盖”private 方法编译器不会报错，但运行结果往往与预期不符：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateOverride</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"private func()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrivateOverride privateOverride = <span class="keyword">new</span> Derived();</span><br><span class="line">        privateOverride.func();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">PrivateOverride</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; <span class="comment">// 这里其实没有覆盖。</span></span><br><span class="line">        System.out.println(<span class="string">"Derived func()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// private func()</span></span><br></pre></td></tr></table></figure><h2 id="构造器和多态"><a href="#构造器和多态" class="headerlink" title="构造器和多态"></a>构造器和多态</h2><p><strong>构造器不具有多态性</strong>，它们实际上是 static 方法，只不过该 static 是隐式声明的。</p><h3 id="构造器的调用顺序"><a href="#构造器的调用顺序" class="headerlink" title="构造器的调用顺序"></a>构造器的调用顺序</h3><ul><li>基类的构造器总是在导出类的构造过程中调用，而且按照继承层次逐渐向上链接，以使每个基类的构造器都能得到调用。</li><li>在导出类的构造器主体中，如果没有明确指定调用某个基类构造器，它会默默地调用默认构造器。如果不存在默认构造器，编译器就会出错（如果某个类没有任何构造器，则编译器会给他添加一个默认构造器）</li></ul><p>构造器的调用顺序：</p><ol><li>调用基类构造器。</li><li>按照声明顺序调用成员的初始化方法。</li><li>调用导出类的构造器的主体。</li></ol><h3 id="继承与清理"><a href="#继承与清理" class="headerlink" title="继承与清理"></a>继承与清理</h3><p>Java 中通常不需要考虑清理的问题，垃圾回收机制会解决大部分问题，但是如果真的需要进行清理操作时，我们需要手动调用某个特定的函数进行清理操作。因为继承的原因，我们在覆盖基类的清理函数时，需要调用基类版本的清理函数。通常在导出类清理函数的末尾。同时如果成员对象也有需要清理的话，也需要在清理函数中调用该成员的清理函数。调用的原则就是：<strong>清理的顺序应该与初始化的顺序相同</strong>。</p><p>如果某些成员对象存在于其他一个或多个对象共享的情况下，我们不能简单的调用其清理函数，我们可以使用“引用计数”来跟踪访问着共享对象的对象数量（就是C++中的shared_ptr）。</p><h3 id="构造器内部的多态方法的行为："><a href="#构造器内部的多态方法的行为：" class="headerlink" title="构造器内部的多态方法的行为："></a>构造器内部的多态方法的行为：</h3><p>如果在一个构造器的内部调用正在构造的对象的某个动态绑定方法，会发生什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch08;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Glyph</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Glyph.draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Glyph() &#123;</span><br><span class="line">        System.out.println(<span class="string">"Glyph() before draw()"</span>);</span><br><span class="line">        draw();</span><br><span class="line">        System.out.println(<span class="string">"Glyph() after draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoundGlyph</span> <span class="keyword">extends</span> <span class="title">Glyph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> radius = <span class="number">1</span>;</span><br><span class="line">    RoundGlyph(<span class="keyword">int</span> r) &#123;</span><br><span class="line">        radius = r;</span><br><span class="line">        System.out.println(<span class="string">"RoundGlyph.RoundGlyph(), radius = "</span> + radius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"RoundGlyph.draw(), radius = "</span> + radius);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolyConstructors</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> RoundGlyph(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Glyph() before draw()</span></span><br><span class="line"><span class="comment">// RoundGlyph.draw(), radius = 0</span></span><br><span class="line"><span class="comment">// Glyph() after draw()</span></span><br><span class="line"><span class="comment">// RoundGlyph.RoundGlyph(), radius = 5</span></span><br></pre></td></tr></table></figure><p>从上面的输出可以看出，在基类中调用动态方法，的确会调用到对应导出类的方法，但是导出类的域却未完成初始化。</p><p>初始化实例的过程：</p><ol><li>在其他任何事物发生之前，将分配给对象的存储空间初始化成二进制的零</li><li>调用基类构造器</li><li>按声明顺序调用成员的初始化方法</li><li>调用导出类的构造器主题。</li></ol><p>在构造器内唯一能够安全调用的那些方法是基类中 final 方法（private 方法属于 final 方法）</p><h2 id="协变返回类型"><a href="#协变返回类型" class="headerlink" title="协变返回类型"></a>协变返回类型</h2><p>Java SE5 中添加了协变返回类型，它表示在导出类中的被覆盖方法可以返回基类方法的返回类型的某种导出类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch08;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grain</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Grain"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wheat</span> <span class="keyword">extends</span> <span class="title">Grain</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Wheat"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mill</span> </span>&#123;</span><br><span class="line">    <span class="function">Grain <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Grain();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WheatMill</span> <span class="keyword">extends</span> <span class="title">Mill</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Wheat <span class="title">process</span><span class="params">()</span> </span>&#123; <span class="comment">// 关键在这里，原本返回类型应该是 Grain，而这里使用了 Grain 的导出类 Wheat</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wheat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantReturn</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mill mill = <span class="keyword">new</span> Mill();</span><br><span class="line">        Grain grain = mill.process();</span><br><span class="line">        System.out.println(<span class="string">"grain = "</span> + grain);</span><br><span class="line">        mill = <span class="keyword">new</span> WheatMill();</span><br><span class="line">        grain = mill.process();</span><br><span class="line">        System.out.println(<span class="string">"grain = "</span> + grain);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// grain = Grain</span></span><br><span class="line"><span class="comment">// grain = Wheat</span></span><br></pre></td></tr></table></figure><h2 id="用继承进行设计"><a href="#用继承进行设计" class="headerlink" title="用继承进行设计"></a>用继承进行设计</h2><p>我们应该首先选择“组合”，尤其是不能十分确定应该使用哪种方法时。组合不会强制我们的程序谁叫进入继承的层次结构。而且，组合更加灵活，他可以动态选择类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch08;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HappyActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HappyActor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SadActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SadActor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Actor actor = <span class="keyword">new</span> HappyActor();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        actor = <span class="keyword">new</span> SadActor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        actor.act();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transmogrify</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stage stage = <span class="keyword">new</span> Stage();</span><br><span class="line">        stage.performPlay();</span><br><span class="line">        stage.change();</span><br><span class="line">        stage.performPlay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// HappyActor</span></span><br><span class="line"><span class="comment">// SadActor</span></span><br></pre></td></tr></table></figure><p>我们通过在运行时将引用与不同的对象重新绑定起来，可以让我们在运行期间获得动态灵活性（也称为“状态模式”）。</p><p><strong>继承表示行为间的差异，字段表示状态上的变化</strong>。</p><h3 id="纯继承与扩展"><a href="#纯继承与扩展" class="headerlink" title="纯继承与扩展"></a>纯继承与扩展</h3><ul><li>is-a 关系（纯继承）：只覆盖在基类中已有的方法，不对其进行扩展<ul><li>导出类和基类有完全相同的接口。</li><li>只需要从导出类向上转型，永远不需要知道正在处理的对象的确切类型</li></ul></li><li>is-like-a 关系：对基类进行了扩展<ul><li>导出类接口中扩展部分不能被基类访问。</li></ul></li></ul><h3 id="向下转型与运行时类型识别"><a href="#向下转型与运行时类型识别" class="headerlink" title="向下转型与运行时类型识别"></a>向下转型与运行时类型识别</h3><p>在 Java 中，所有转型都会得到检查。即使我们只是进行一次普通的加括弧形式的类型转换，在进入运行期时仍然会对其进行检查，如果不是我们想要转换的类型，那么会返回一个 ClassCastException。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cycle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cycle run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Unicycle</span> <span class="keyword">extends</span> <span class="title">Cycle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Unicycle run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span> <span class="keyword">extends</span> <span class="title">Cycle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bicycle run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tricycle</span> <span class="keyword">extends</span> <span class="title">Cycle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Tricycle run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ride</span><span class="params">(Cycle c)</span> </span>&#123;</span><br><span class="line">        c.run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Unicycle unicycle = <span class="keyword">new</span> Unicycle();</span><br><span class="line">        Bicycle bicycle = <span class="keyword">new</span> Bicycle();</span><br><span class="line">        Tricycle tricycle = <span class="keyword">new</span> Tricycle();</span><br><span class="line"></span><br><span class="line">        unicycle.run();</span><br><span class="line">        bicycle.run();</span><br><span class="line">        tricycle.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Unicycle run</span></span><br><span class="line"><span class="comment">// Bicycle run</span></span><br><span class="line"><span class="comment">// Tricycle run</span></span><br></pre></td></tr></table></figure><h3 id="练习2"><a href="#练习2" class="headerlink" title="练习2"></a>练习2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Circle draw"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Circle erase"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Square draw"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Square erase"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Triangle draw"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Triangle erase"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomShapeGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (random.nextInt(<span class="number">3</span>)) &#123;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> <span class="keyword">new</span> Triangle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shapes</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RandomShapeGenerator randomShapeGenerator = <span class="keyword">new</span> RandomShapeGenerator();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Shape[] shapes = <span class="keyword">new</span> Shape[<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++) &#123;</span><br><span class="line">            shapes[i] = randomShapeGenerator.next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Shape shape: shapes) &#123;</span><br><span class="line">            shape.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Triangle draw</span></span><br><span class="line"><span class="comment">// Triangle draw</span></span><br><span class="line"><span class="comment">// Square draw</span></span><br><span class="line"><span class="comment">// Triangle draw</span></span><br><span class="line"><span class="comment">// Square draw</span></span><br><span class="line"><span class="comment">// Triangle draw</span></span><br><span class="line"><span class="comment">// Square draw</span></span><br><span class="line"><span class="comment">// Triangle draw</span></span><br><span class="line"><span class="comment">// Circle draw</span></span><br></pre></td></tr></table></figure><h3 id="练习3"><a href="#练习3" class="headerlink" title="练习3"></a>练习3</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Shape info"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使导出类没有覆盖它，但是由于继承的原因，导出类任然会有该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Circle draw"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Circle erase"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Circle info"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shapes</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RandomShapeGenerator randomShapeGenerator = <span class="keyword">new</span> RandomShapeGenerator();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Shape[] shapes = <span class="keyword">new</span> Shape[<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++) &#123;</span><br><span class="line">            shapes[i] = randomShapeGenerator.next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Shape shape: shapes) &#123;</span><br><span class="line">            shape.info();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Shape info</span></span><br><span class="line"><span class="comment">// Shape info</span></span><br><span class="line"><span class="comment">// Circle info</span></span><br><span class="line"><span class="comment">// Circle info</span></span><br><span class="line"><span class="comment">// Shape info</span></span><br><span class="line"><span class="comment">// Shape info</span></span><br><span class="line"><span class="comment">// Shape info</span></span><br><span class="line"><span class="comment">// Shape info</span></span><br><span class="line"><span class="comment">// Circle info</span></span><br></pre></td></tr></table></figure><p>如果只有一个导出类Circle覆盖了该方法，只有在正式类型为Circle的Shape调用info时，才会调用到覆盖后的方法，而其余的则是调用到基类的方法。</p><h3 id="练习4"><a href="#练习4" class="headerlink" title="练习4"></a>练习4</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Line draw"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Line erase"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shapes</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RandomShapeGenerator randomShapeGenerator = <span class="keyword">new</span> RandomShapeGenerator();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Shape[] shapes = <span class="keyword">new</span> Shape[<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++) &#123;</span><br><span class="line">            shapes[i] = randomShapeGenerator.next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Shape shape: shapes) &#123;</span><br><span class="line">            shape.draw();</span><br><span class="line">        &#125;</span><br><span class="line">        shapes[<span class="number">0</span>] = <span class="keyword">new</span> Line();</span><br><span class="line">        shapes[<span class="number">0</span>].draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Shape info</span></span><br><span class="line"><span class="comment">//Shape info</span></span><br><span class="line"><span class="comment">//Circle info</span></span><br><span class="line"><span class="comment">//Circle info</span></span><br><span class="line"><span class="comment">//Shape info</span></span><br><span class="line"><span class="comment">//Shape info</span></span><br><span class="line"><span class="comment">//Shape info</span></span><br><span class="line"><span class="comment">//Shape info</span></span><br><span class="line"><span class="comment">//Circle info</span></span><br></pre></td></tr></table></figure><h3 id="练习5"><a href="#练习5" class="headerlink" title="练习5"></a>练习5</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cycle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cycle run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wheels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Unicycle</span> <span class="keyword">extends</span> <span class="title">Cycle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Unicycle run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wheels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span> <span class="keyword">extends</span> <span class="title">Cycle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bicycle run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wheels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tricycle</span> <span class="keyword">extends</span> <span class="title">Cycle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Tricycle run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wheels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ride</span><span class="params">(Cycle c)</span> </span>&#123;</span><br><span class="line">        c.run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Unicycle unicycle = <span class="keyword">new</span> Unicycle();</span><br><span class="line">        Bicycle bicycle = <span class="keyword">new</span> Bicycle();</span><br><span class="line">        Tricycle tricycle = <span class="keyword">new</span> Tricycle();</span><br><span class="line"></span><br><span class="line">        unicycle.run();</span><br><span class="line">        bicycle.run();</span><br><span class="line">        tricycle.run();</span><br><span class="line"></span><br><span class="line">        Cycle[] cycles = <span class="keyword">new</span> Cycle[]&#123;unicycle, bicycle, tricycle&#125;;</span><br><span class="line">        <span class="keyword">for</span> (Cycle cycle: cycles) &#123;</span><br><span class="line">            System.out.println(<span class="string">"cycle.wheels() = "</span> + cycle.wheels());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Unicycle run</span></span><br><span class="line"><span class="comment">// Bicycle run</span></span><br><span class="line"><span class="comment">// Tricycle run</span></span><br><span class="line"><span class="comment">// cycle.wheels() = 1</span></span><br><span class="line"><span class="comment">// cycle.wheels() = 2</span></span><br><span class="line"><span class="comment">// cycle.wheels() = 3</span></span><br></pre></td></tr></table></figure><h3 id="练习6"><a href="#练习6" class="headerlink" title="练习6"></a>练习6</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch08;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Note &#123;</span><br><span class="line">    MIDDLE_C, C_SHARP, B_FLAT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Instrument.play() n = "</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Instrument"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Adusting Instrument"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Wind.play() n = "</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Percussion</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Percussion.play() n = "</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Percussion"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Adjusting Percussion"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stringed</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Stringed.play() n = "</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Stringed"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Adjusting Stringed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brass</span> <span class="keyword">extends</span> <span class="title">Wind</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Brass.play() n = "</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Adjusting Brass"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woodwind</span> <span class="keyword">extends</span> <span class="title">Wind</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Woodwind.play() n = "</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Woodwind"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrument i)</span> </span>&#123;</span><br><span class="line">        i.play(Note.MIDDLE_C);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tuneAll</span><span class="params">(Instrument[] instruments)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Instrument instrument: instruments) &#123;</span><br><span class="line">            tune(instrument);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Instrument[] instruments = &#123;</span><br><span class="line">                <span class="keyword">new</span> Wind(),</span><br><span class="line">                <span class="keyword">new</span> Percussion(),</span><br><span class="line">                <span class="keyword">new</span> Stringed(),</span><br><span class="line">                <span class="keyword">new</span> Brass(),</span><br><span class="line">                <span class="keyword">new</span> Woodwind(),</span><br><span class="line">        &#125;;</span><br><span class="line">        tuneAll(instruments);</span><br><span class="line">        <span class="keyword">for</span> (Instrument instrument: instruments) &#123;</span><br><span class="line">            System.out.println(instrument);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Wind.play() n = MIDDLE_C</span></span><br><span class="line"><span class="comment">// Percussion.play() n = MIDDLE_C</span></span><br><span class="line"><span class="comment">// Stringed.play() n = MIDDLE_C</span></span><br><span class="line"><span class="comment">// Brass.play() n = MIDDLE_C</span></span><br><span class="line"><span class="comment">// Woodwind.play() n = MIDDLE_C</span></span><br><span class="line"><span class="comment">// Instrument</span></span><br><span class="line"><span class="comment">// Percussion</span></span><br><span class="line"><span class="comment">// Stringed</span></span><br><span class="line"><span class="comment">// Instrument</span></span><br><span class="line"><span class="comment">// Woodwind</span></span><br></pre></td></tr></table></figure><h3 id="练习7"><a href="#练习7" class="headerlink" title="练习7"></a>练习7</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Piano</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Piano.play() n = "</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Piano"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Adjusting Piano"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrument i)</span> </span>&#123;</span><br><span class="line">        i.play(Note.MIDDLE_C);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tuneAll</span><span class="params">(Instrument[] instruments)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Instrument instrument: instruments) &#123;</span><br><span class="line">            tune(instrument);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Instrument[] instruments = &#123;</span><br><span class="line">                <span class="keyword">new</span> Wind(),</span><br><span class="line">                <span class="keyword">new</span> Percussion(),</span><br><span class="line">                <span class="keyword">new</span> Stringed(),</span><br><span class="line">                <span class="keyword">new</span> Brass(),</span><br><span class="line">                <span class="keyword">new</span> Woodwind(),</span><br><span class="line">                <span class="keyword">new</span> Piano(),</span><br><span class="line">        &#125;;</span><br><span class="line">        tuneAll(instruments);</span><br><span class="line">        <span class="keyword">for</span> (Instrument instrument: instruments) &#123;</span><br><span class="line">            System.out.println(instrument);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Wind.play() n = MIDDLE_C</span></span><br><span class="line"><span class="comment">// Percussion.play() n = MIDDLE_C</span></span><br><span class="line"><span class="comment">// Stringed.play() n = MIDDLE_C</span></span><br><span class="line"><span class="comment">// Brass.play() n = MIDDLE_C</span></span><br><span class="line"><span class="comment">// Woodwind.play() n = MIDDLE_C</span></span><br><span class="line"><span class="comment">// Piano.play() n = MIDDLE_C</span></span><br><span class="line"><span class="comment">// Instrument</span></span><br><span class="line"><span class="comment">// Percussion</span></span><br><span class="line"><span class="comment">// Stringed</span></span><br><span class="line"><span class="comment">// Instrument</span></span><br><span class="line"><span class="comment">// Woodwind</span></span><br><span class="line"><span class="comment">// Piano</span></span><br></pre></td></tr></table></figure><h3 id="练习8"><a href="#练习8" class="headerlink" title="练习8"></a>练习8</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InstrumentGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random(<span class="number">42</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Instrument <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (random.nextInt(<span class="number">6</span>)) &#123;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> <span class="keyword">new</span> Wind();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="keyword">new</span> Percussion();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> <span class="keyword">new</span> Stringed();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">return</span> <span class="keyword">new</span> Brass();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">return</span> <span class="keyword">new</span> Woodwind();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>: <span class="keyword">return</span> <span class="keyword">new</span> Piano();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrument i)</span> </span>&#123;</span><br><span class="line">        i.play(Note.MIDDLE_C);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tuneAll</span><span class="params">(Instrument[] instruments)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Instrument instrument: instruments) &#123;</span><br><span class="line">            tune(instrument);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Instrument[] instruments = <span class="keyword">new</span> Instrument[<span class="number">10</span>];</span><br><span class="line">        InstrumentGenerator instrumentGenerator = <span class="keyword">new</span> InstrumentGenerator();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            instruments[i] = instrumentGenerator.next();</span><br><span class="line">        &#125;</span><br><span class="line">        tuneAll(instruments);</span><br><span class="line">        <span class="keyword">for</span> (Instrument instrument: instruments) &#123;</span><br><span class="line">            System.out.println(instrument);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stringed.play() n = MIDDLE_C</span></span><br><span class="line"><span class="comment">// Brass.play() n = MIDDLE_C</span></span><br><span class="line"><span class="comment">// Wind.play() n = MIDDLE_C</span></span><br><span class="line"><span class="comment">// Stringed.play() n = MIDDLE_C</span></span><br><span class="line"><span class="comment">// Wind.play() n = MIDDLE_C</span></span><br><span class="line"><span class="comment">// Percussion.play() n = MIDDLE_C</span></span><br><span class="line"><span class="comment">// Piano.play() n = MIDDLE_C</span></span><br><span class="line"><span class="comment">// Stringed.play() n = MIDDLE_C</span></span><br><span class="line"><span class="comment">// Percussion.play() n = MIDDLE_C</span></span><br><span class="line"><span class="comment">// Piano.play() n = MIDDLE_C</span></span><br><span class="line"><span class="comment">// Stringed</span></span><br><span class="line"><span class="comment">// Instrument</span></span><br><span class="line"><span class="comment">// Instrument</span></span><br><span class="line"><span class="comment">// Stringed</span></span><br><span class="line"><span class="comment">// Instrument</span></span><br><span class="line"><span class="comment">// Percussion</span></span><br><span class="line"><span class="comment">// Piano</span></span><br><span class="line"><span class="comment">// Stringed</span></span><br><span class="line"><span class="comment">// Percussion</span></span><br><span class="line"><span class="comment">// Piano</span></span><br></pre></td></tr></table></figure><h3 id="练习9"><a href="#练习9" class="headerlink" title="练习9"></a>练习9</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rodent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Rodent.eat()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Rodent[] rodents = <span class="keyword">new</span> Rodent[] &#123;</span><br><span class="line">                <span class="keyword">new</span> Rodent(),</span><br><span class="line">                <span class="keyword">new</span> Mouse(),</span><br><span class="line">                <span class="keyword">new</span> Gerbil(),</span><br><span class="line">                <span class="keyword">new</span> Hamster(),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (Rodent rodent: rodents) &#123;</span><br><span class="line">            rodent.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">extends</span> <span class="title">Rodent</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Mouse.eat()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gerbil</span> <span class="keyword">extends</span> <span class="title">Rodent</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Gerbil.eat()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hamster</span> <span class="keyword">extends</span> <span class="title">Rodent</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hamster.eat()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Rodent.eat()</span></span><br><span class="line"><span class="comment">// Mouse.eat()</span></span><br><span class="line"><span class="comment">// Gerbil.eat()</span></span><br><span class="line"><span class="comment">// Hamster.eat()</span></span><br></pre></td></tr></table></figure><h3 id="练习10"><a href="#练习10" class="headerlink" title="练习10"></a>练习10</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch08;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        func2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Base"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ex10</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Ex10"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Base base = <span class="keyword">new</span> Ex10();</span><br><span class="line">        base.func1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Ex10</span></span><br></pre></td></tr></table></figure><p>因为<code>func2</code>既不是static也不是final，所以他是动态绑定的，因此基类的 func1 中调用 func2 方法也是调用到导出类的 func2。</p><h3 id="练习11"><a href="#练习11" class="headerlink" title="练习11"></a>练习11</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch08;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meal</span> </span>&#123;</span><br><span class="line">    Meal() &#123;</span><br><span class="line">        System.out.println(<span class="string">"Meal()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bread</span> </span>&#123;</span><br><span class="line">    Bread() &#123;</span><br><span class="line">        System.out.println(<span class="string">"Bread()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cheese</span> </span>&#123;</span><br><span class="line">    Cheese() &#123;</span><br><span class="line">        System.out.println(<span class="string">"Cheese()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lettuce</span> </span>&#123;</span><br><span class="line">    Lettuce() &#123;</span><br><span class="line">        System.out.println(<span class="string">"Lettuce()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lunch</span> <span class="keyword">extends</span> <span class="title">Meal</span> </span>&#123;</span><br><span class="line">    Lunch() &#123;</span><br><span class="line">        System.out.println(<span class="string">"Lunch()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PortableLunch</span> <span class="keyword">extends</span> <span class="title">Lunch</span> </span>&#123;</span><br><span class="line">    PortableLunch() &#123;</span><br><span class="line">        System.out.println(<span class="string">"PortableLunch()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pickle</span> </span>&#123;</span><br><span class="line">    Pickle() &#123;</span><br><span class="line">        System.out.println(<span class="string">"Pickle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sandwich</span> <span class="keyword">extends</span> <span class="title">PortableLunch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Bread b = <span class="keyword">new</span> Bread();</span><br><span class="line">    <span class="keyword">private</span> Cheese c = <span class="keyword">new</span> Cheese();</span><br><span class="line">    <span class="keyword">private</span> Lettuce l = <span class="keyword">new</span> Lettuce();</span><br><span class="line">    <span class="keyword">private</span> Pickle p = <span class="keyword">new</span> Pickle();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sandwich</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sandwich()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Sandwich();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习12"><a href="#练习12" class="headerlink" title="练习12"></a>练习12</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rodent</span> </span>&#123;</span><br><span class="line">    Rodent() &#123;</span><br><span class="line">        System.out.println(<span class="string">"Rodent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Rodent.eat()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Rodent[] rodents = <span class="keyword">new</span> Rodent[] &#123;</span><br><span class="line">                <span class="keyword">new</span> Rodent(),</span><br><span class="line">                <span class="keyword">new</span> Mouse(),</span><br><span class="line">                <span class="keyword">new</span> Gerbil(),</span><br><span class="line">                <span class="keyword">new</span> Hamster(),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (Rodent rodent: rodents) &#123;</span><br><span class="line">            rodent.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">extends</span> <span class="title">Rodent</span> </span>&#123;</span><br><span class="line">    Mouse() &#123;</span><br><span class="line">        System.out.println(<span class="string">"Mouse"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Mouse.eat()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gerbil</span> <span class="keyword">extends</span> <span class="title">Rodent</span> </span>&#123;</span><br><span class="line">    Gerbil() &#123;</span><br><span class="line">        System.out.println(<span class="string">"Gerbil"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Gerbil.eat()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hamster</span> <span class="keyword">extends</span> <span class="title">Rodent</span> </span>&#123;</span><br><span class="line">    Hamster() &#123;</span><br><span class="line">        System.out.println(<span class="string">"Hamster"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hamster.eat()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习13"><a href="#练习13" class="headerlink" title="练习13"></a>练习13</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch08;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shared</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> refcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Create "</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        refcount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(--refcount == <span class="number">0</span>)</span><br><span class="line">            System.out.println(<span class="string">"Disposing "</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Shared&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"finalize()"</span>);</span><br><span class="line">        <span class="keyword">if</span> (refcount != <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"refcount != 0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composing</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Shared shared;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Composing</span><span class="params">(Shared shared)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Creating "</span> + <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.shared = shared;</span><br><span class="line">        <span class="keyword">this</span>.shared.addRef();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"disposing "</span> + <span class="keyword">this</span>);</span><br><span class="line">        shared.dispose();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Composing&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCounting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Shared shared = new Shared();</span></span><br><span class="line"><span class="comment">//        Composing[] composings = &#123;</span></span><br><span class="line"><span class="comment">//                new Composing(shared), new Composing(shared),</span></span><br><span class="line"><span class="comment">//                new Composing(shared), new Composing(shared),</span></span><br><span class="line"><span class="comment">//                new Composing(shared)</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        for (Composing composing: composings) &#123;</span></span><br><span class="line"><span class="comment">//            composing.dispose();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">new</span> Composing(<span class="keyword">new</span> Shared());</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习14"><a href="#练习14" class="headerlink" title="练习14"></a>练习14</h3><h3 id="练习15"><a href="#练习15" class="headerlink" title="练习15"></a>练习15</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch08;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Glyph</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Glyph.draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Glyph() &#123;</span><br><span class="line">        System.out.println(<span class="string">"Glyph() before draw()"</span>);</span><br><span class="line">        draw();</span><br><span class="line">        System.out.println(<span class="string">"Glyph() after draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoundGlyph</span> <span class="keyword">extends</span> <span class="title">Glyph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> radius = <span class="number">1</span>;</span><br><span class="line">    RoundGlyph(<span class="keyword">int</span> r) &#123;</span><br><span class="line">        radius = r;</span><br><span class="line">        System.out.println(<span class="string">"RoundGlyph.RoundGlyph(), radius = "</span> + radius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"RoundGlyph.draw(), radius = "</span> + radius);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RectangularGlygh</span> <span class="keyword">extends</span> <span class="title">Glyph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> length;</span><br><span class="line">    RectangularGlygh(<span class="keyword">int</span> length) &#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        System.out.println(<span class="string">"RectanguarGlygh length = "</span> + length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"RectanguarGlygh.draw() length = "</span> + length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolyConstructors</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> RectangularGlygh(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Glyph() before draw()</span></span><br><span class="line"><span class="comment">// RectanguarGlygh.draw() length = 0</span></span><br><span class="line"><span class="comment">// Glyph() after draw()</span></span><br><span class="line"><span class="comment">// RectanguarGlygh length = 10</span></span><br></pre></td></tr></table></figure><h3 id="练习16"><a href="#练习16" class="headerlink" title="练习16"></a>练习16</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch08;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Status</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatusA</span> <span class="keyword">extends</span> <span class="title">Status</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Status A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatusB</span> <span class="keyword">extends</span> <span class="title">Status</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Status B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatusC</span> <span class="keyword">extends</span> <span class="title">Status</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Status C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlterStatus</span> </span>&#123;</span><br><span class="line">    Status status = <span class="keyword">new</span> StatusA();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        status = <span class="keyword">new</span> StatusA();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        status = <span class="keyword">new</span> StatusB();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">C</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        status = <span class="keyword">new</span> StatusC();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        status.func();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Starship</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AlterStatus alterStatus = <span class="keyword">new</span> AlterStatus();</span><br><span class="line">        alterStatus.call();</span><br><span class="line">        alterStatus.B();</span><br><span class="line">        alterStatus.call();</span><br><span class="line">        alterStatus.C();</span><br><span class="line">        alterStatus.call();</span><br><span class="line">        alterStatus.A();</span><br><span class="line">        alterStatus.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Status A</span></span><br><span class="line"><span class="comment">// Status B</span></span><br><span class="line"><span class="comment">// Status C</span></span><br><span class="line"><span class="comment">// Status A</span></span><br></pre></td></tr></table></figure><h3 id="练习17"><a href="#练习17" class="headerlink" title="练习17"></a>练习17</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cycle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cycle run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wheels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Unicycle</span> <span class="keyword">extends</span> <span class="title">Cycle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Unicycle run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wheels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">balance</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span> <span class="keyword">extends</span> <span class="title">Cycle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bicycle run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wheels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">balance</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tricycle</span> <span class="keyword">extends</span> <span class="title">Cycle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Tricycle run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wheels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ride</span><span class="params">(Cycle c)</span> </span>&#123;</span><br><span class="line">        c.run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Cycle[] cycles = <span class="keyword">new</span> Cycle[]&#123;<span class="keyword">new</span> Unicycle(), <span class="keyword">new</span> Bicycle(), <span class="keyword">new</span> Tricycle()&#125;;</span><br><span class="line"><span class="comment">//        for(Cycle cycle: cycles) &#123;</span></span><br><span class="line"><span class="comment">//            cycle.balance(); // 无法调用</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        Unicycle unicycle = (Unicycle)cycles[<span class="number">0</span>];</span><br><span class="line">        Bicycle bicycle = (Bicycle)cycles[<span class="number">1</span>];</span><br><span class="line">        Tricycle tricycle = (Tricycle)cycles[<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        unicycle.balance();</span><br><span class="line">        bicycle.balance();</span><br><span class="line"><span class="comment">//        tricycle.balance(); //无法调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 《Java编程思想》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 阅读笔记 </tag>
            
            <tag> 《Java编程思想》 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《 Java 编程思想》CH07 复用类</title>
      <link href="/2020/02/15/%E3%80%8A-Java-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8BCH07-%E5%A4%8D%E7%94%A8%E7%B1%BB/"/>
      <url>/2020/02/15/%E3%80%8A-Java-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8BCH07-%E5%A4%8D%E7%94%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p><strong>复用代码是 Java 众多引人注目的功能之一。</strong></p><p>Java 可以通过创建类来复用代码，要在使用类的时候不破坏现有代码，有两种方式：</p><ul><li>组合：在新的类中使用现有类的对象。</li><li>继承：按照现有类的类型来创建新类，无需改变现有类的形式，并为其添加新代码。</li></ul><h2 id="组合语法"><a href="#组合语法" class="headerlink" title="组合语法"></a>组合语法</h2><ul><li>使用组合技术只需要将对象引用置于新类中。</li><li>每个非基本类型的对象都有一个 <code>toString()</code> 方法，而且当编译器需要一个 String 而你传入一个对象时，<code>toString()</code> 会被调用。</li><li>类中的对象引用会被默认初始化为 null，如果你对其调用任何方法都会抛出异常，但是可以在不抛出异常的情况下，仍然可以打印一个 null 引用</li><li>类中对象引用的初始化位置：<ul><li>在定义对象的地方</li><li>在类的构造器中</li><li>惰性初始化，即在要使用该对象的地方进行初始化</li><li>实例初始化</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Soap</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String s;</span><br><span class="line">Soap() &#123;</span><br><span class="line">System.out.println(<span class="string">"Soup()"</span>);</span><br><span class="line">s = <span class="string">"Constructed"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bath</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bath</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String s1 = <span class="string">"happy"</span>,  <span class="comment">// 在定义处初始化</span></span><br><span class="line">s2; </span><br><span class="line"><span class="keyword">private</span> Soap soap;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Bath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Inside Bath()"</span>);</span><br><span class="line">soap = <span class="keyword">new</span> Soap(); <span class="comment">// 在构造函数中初四花</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">s2 = <span class="string">"Joy"</span>; <span class="comment">// 惰性初始化</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">i = <span class="number">2</span>; <span class="comment">// 实例初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Bath b = <span class="keyword">new</span> Bath();</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承语法"><a href="#继承语法" class="headerlink" title="继承语法"></a>继承语法</h2><ul><li>继承是 OOP 语言和 Java 语言不可缺少的部分，当创建一个类时，总是在继承，即使没有显式继承某个类，也会隐式地从 Object 类中继承。</li><li>继承由关键词 <code>extends</code> 指定，其形式如<code>class Detergent extends Cleanser{}</code>，基类的所有方法和成员都会自动导入到导出类中。</li><li>可以为每个类都创建一个 main 方法，这样可以使得每个类的单元测试变得简便。即使某个类只有包访问权限，其<code>public main</code>也可以通过 <code>java className</code>的方式访问到</li><li>为了继承，一般是将所有的数据成员都指定为 private，将所有的方法指定为 public。</li><li>我们对继承来的方法进行重写，重写之后可以通过 <code>super</code> 关键词访问基类版本的方法，如<code>super.func()</code>;</li><li>Java 会自动在导出类的构造器中插入对基类构造器的调用，其总是在导出类构造器执行之前，即使是在定义处初始化的语句也会在基类构造器执行之后执行。</li><li>即使没有为导出类创建构造器，编译器也会在默认构造器中调用基类的构造器</li><li>如果没有默认的基类构造器，或者想要调用一个带有参数的基类构造器，就必须使用 super 关键词显式调用基类构造器，<strong>调用基类构造器必须是在你导出类构造器的第一条语句</strong>。</li></ul><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>代理是指，我们将一个成员对象置于要构造的类中（像组合），但与此同时我们在新类中暴露该成员对象的所有或部分方法（想继承）。</p><p>IDEA自动创建代理的过程：</p><ul><li>先在代理类中声明要代理的成员。</li><li><code>Alt + Insert</code>快捷键，选中 <code>Delegation</code></li><li>选中要代理的函数即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShipControls</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">back</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">turboBoost</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpaceShipDelegation</span> </span>&#123;</span><br><span class="line">    SpaceShipControls spaceShipControls = <span class="keyword">new</span> SpaceShipControls();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">        spaceShipControls.up(velocity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">        spaceShipControls.down(velocity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">        spaceShipControls.left(velocity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">        spaceShipControls.right(velocity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">back</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">        spaceShipControls.back(velocity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turboBoost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        spaceShipControls.turboBoost();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpaceShipDelegation spaceShipDelegation = <span class="keyword">new</span> SpaceShipDelegation();</span><br><span class="line">        spaceShipDelegation.left(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结合使用组合继承"><a href="#结合使用组合继承" class="headerlink" title="结合使用组合继承"></a>结合使用组合继承</h2><ul><li>可以结合组合和继承来创建复杂的类</li><li>编译器会强制你去初始化基类，并且要求在构造器最开始出就要这么做，但是它不会要求你对成员对象进行初始化，因此需要自己注意。</li><li>Java 中没有 C++ 中的析构函数，就像之前所说的一样，如果我们的类的确需要做一些类似的工作（如关闭文件），我们需要自己实现一个方法来实现，而当涉及到继承时，我们要确保以正确的顺序调用该函数，推荐和C++中析构函数的执行顺序一样编写该函数，即先清理导出类本身，再调用基类的清理函数。</li><li>清理函数需要放在 finally 子句中，以防异常的出现，导致清理函数未被执行，可参考练习12</li><li>如果 Java 的基类拥有某个已经被多次重载的方法名称时，在导出类中重新定义该方法的名称，不会屏蔽其在基类中的任何版本。这意味着，在导出类中，重载和重新定义（重写）容易混淆在一起，如果不看基类的定义是很难分辨某个方法是否正确的被重新定义了。我们可以使用<code>@Override</code>注解来标识某个方法我们希望其是重写而不是重载，如果一不小心重载了，则会出现编译错误来提醒我们。</li></ul><h2 id="在组合与继承之间选择"><a href="#在组合与继承之间选择" class="headerlink" title="在组合与继承之间选择"></a>在组合与继承之间选择</h2><ul><li>组合和继承都允许在新的类中放置子对象，组合是显式地这样做，而继承则是隐式地这样做。</li><li>组合技术通常用于想在新类中使用现有类的功能而非它的接口这种情况。有时，允许类的用户直接访问新类中组合成分是有意义的。</li><li>在继承时，使用某个现有类，开发一个它的特殊版本。通常，这意味着你在使用一个通用类，并为了某种特殊需要而将其特殊化。</li></ul><h2 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h2><ul><li>“为新的类提供方法”不是继承中最重要的部分，其重要的方面是用来表现新类和基类之间的关系。简单的说，我们可以认为“导出类是基类的一种类型”，即可以把导出类当成基类来使用</li><li>由于导出类转换为基类在继承图上是向上移动的，因为我们将其成为“向上转型”</li><li>向上转型是从一个较为专用的类向较为通用的类转变</li><li>虽然在教授OOP的过程中多次强调继承，但是我们应该慎用继承。判断是否要使用的继承的一个简单方法就是，判断我们是否要进行向上转型，如果要进行向上转型，则用继承，反之，则用组合。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrument i)</span> </span>&#123;</span><br><span class="line">        i.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Wind wind = <span class="keyword">new</span> Wind();</span><br><span class="line">        Instrument.tune(wind); <span class="comment">// 传递参数时，用了向上转型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h2><p>final 关键词的含义通常指“无法改变的”，使用这个关键词通常是因为设计和效率的原因。，final 可以用在数据、方法和类上。</p><h3 id="final-数据"><a href="#final-数据" class="headerlink" title="final 数据"></a>final 数据</h3><ul><li>数据的恒定不变分为两种情况：编译时常量和在运行时初始化并并无法的改变的值。</li><li>在 Java 中，这类常量必须是基本数据类型，并且用关键词 final 表示，并在该常量定义时对其初始化，如<code>final int value = 1</code>。通常，编译时常量还是一个<code>static</code>数据，即<code>static final int VALUE_ONE = 1</code>。</li><li>编译器常量的命名规则是：全用大写字母，单词与单词之间用<code>_</code>隔开</li><li>即使一个变量是<code>final</code>,我们也无法确定其是编译时常量，因为初始化没有要求是字面量，即初始化可以通过调用函数实现，如<code>final int value = rand.nextInt(20)</code>。</li><li>同时一个<code>final</code>数值，如果其是<code>static</code>的，那么它可能是在类导入时初始化的，而他不是<code>static</code>的话，它是在实例化时初始化的。</li><li>对于基本变量，final 使数值恒定不变，但是对于对象引用，其只是要求对象引用不变，即不指向新的对象，而对象本身是可以被修改的。</li><li>Java 允许“空白 final”，即被声明为 final 但是又没有给定初值的域，虽然可以在定义时不给定初值，按时编译器会保证，final 域在使用前都必须被初始化，即如果没有在定义处给定 final 域的初值的话，就必须在每个构造器中对该 final 域进行赋值。</li><li>Java 允许在参数列表中以声明的方式将参数指明为 final，其含义为，在该函数中无法修改该变量：<ul><li>参数类型为基本类型：可以读参数，但是不能修改</li><li>参数类型为对象类型：无法修改引用</li></ul></li></ul><h3 id="final-方法"><a href="#final-方法" class="headerlink" title="final 方法"></a>final 方法</h3><ul><li>可以将一个方法定义成 final，这样可以防止任何继承类修改它的含义（即导出类无法覆盖实现）</li><li>在 Java 的早期实现中，对 final 方法的调用会被转为内嵌调用（C++ 中的 inline），但是现在不需要用这样的方式来优化代码了</li><li>类中的所有 private 方法都被隐式的指定为 final</li><li>“覆盖”只有在方法是基类的接口的一部分时才会出现，即必须能将一个对象向上转型为它的基本类型并调用相同的方法，如果一个方法是 private，那么它就不是接口的一部分。</li></ul><h3 id="final-类"><a href="#final-类" class="headerlink" title="final 类"></a>final 类</h3><p>当将一个类的整体定义为 final 时，就表明该类无法被继承，同时隐式地将所有方法都定义为 final。</p><h2 id="初始化及类的加载"><a href="#初始化及类的加载" class="headerlink" title="初始化及类的加载"></a>初始化及类的加载</h2><ul><li>每个类的编译代码都存在与他自己独立的文件中。该文件只有在需要使用程序代码的时候才会被加载。</li><li>一般来说，只有在“类首次使用才加载”，即加载发生于第一次创建类的对象或第一次使用类中的静态域或静态方法。</li><li>在加载导出类是，Java 编译器会注意到它继承于某个基类，因此他会先去加载该基类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch07;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Insert</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i =  <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> j;</span><br><span class="line">    Insert() &#123;</span><br><span class="line">        System.out.println(<span class="string">"i = "</span> + i + <span class="string">" j = "</span> + j);</span><br><span class="line">        j = <span class="number">39</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x1 = printInit(<span class="string">"static Insert.x1 init"</span>);</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">printInit</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">47</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Beetle</span> <span class="keyword">extends</span> <span class="title">Insert</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> k = printInit(<span class="string">"Beetle.k init"</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Beetle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"k = "</span> + k);</span><br><span class="line">        System.out.println(<span class="string">"j = "</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x2 = printInit(<span class="string">"static Beetle.x2 init"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Beetle constructor"</span>);</span><br><span class="line">        <span class="keyword">new</span> Beetle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    static Insert.x1 init</span></span><br><span class="line"><span class="comment">//    static Beetle.x2 init</span></span><br><span class="line"><span class="comment">//    Beetle constructor</span></span><br><span class="line"><span class="comment">//    i = 9 j = 0</span></span><br><span class="line"><span class="comment">//    Beetle.k init</span></span><br><span class="line"><span class="comment">//    k = 47</span></span><br><span class="line"><span class="comment">//    j = 39</span></span><br></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Demo"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"toString()"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ex1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ex1</span> </span>&#123;</span><br><span class="line">Demo demo;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (demo == <span class="keyword">null</span>) &#123;</span><br><span class="line">demo = <span class="keyword">new</span> Demo();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> demo.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Ex1 ex1 = <span class="keyword">new</span> Ex1();</span><br><span class="line">System.out.println(ex1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习2"><a href="#练习2" class="headerlink" title="练习2"></a>练习2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cleanser</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String s = <span class="string">"Cleanser"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(String a)</span> </span>&#123;</span><br><span class="line">s += a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dilute</span><span class="params">()</span> </span>&#123; append(<span class="string">" dilute()"</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span> </span>&#123; append(<span class="string">" apply()"</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrub</span><span class="params">()</span> </span>&#123; append(<span class="string">" scrub()"</span>); &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Cleanser cleanser = <span class="keyword">new</span> Cleanser();</span><br><span class="line">cleanser.dilute(); cleanser.apply(); cleanser.scrub();</span><br><span class="line">System.out.println(cleanser);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Detergent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Detergent</span> <span class="keyword">extends</span> <span class="title">Cleanser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">append(<span class="string">" Detergent.scrub()"</span>);</span><br><span class="line"><span class="keyword">super</span>.scrub();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foam</span><span class="params">()</span> </span>&#123; append(<span class="string">" foam()"</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Detergent detergent = <span class="keyword">new</span> Detergent();</span><br><span class="line">detergent.dilute();</span><br><span class="line">detergent.apply();</span><br><span class="line">detergent.scrub();</span><br><span class="line">detergent.foam();</span><br><span class="line">System.out.println(detergent);</span><br><span class="line">Cleanser.main(args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewDetergent</span> <span class="keyword">extends</span> <span class="title">Detergent</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">append(<span class="string">"NewDetergent"</span>);</span><br><span class="line"><span class="keyword">super</span>.scrub();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sterilize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">append(<span class="string">"sterilize"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">NewDetergent newDetergent = <span class="keyword">new</span> NewDetergent();</span><br><span class="line">newDetergent.dilute();</span><br><span class="line">newDetergent.apply();</span><br><span class="line">newDetergent.scrub();</span><br><span class="line">newDetergent.foam();</span><br><span class="line">newDetergent.sterilize();</span><br><span class="line">System.out.println(newDetergent);</span><br><span class="line">Detergent.main(args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cleanser dilute() apply()NewDetergent Detergent.scrub() scrub() foam()sterilize</span></span><br><span class="line"><span class="comment">// Cleanser dilute() apply() Detergent.scrub() scrub() foam()</span></span><br><span class="line"><span class="comment">// Cleanser dilute() apply() scrub()</span></span><br></pre></td></tr></table></figure><h3 id="练习3-amp-练习4"><a href="#练习3-amp-练习4" class="headerlink" title="练习3 &amp; 练习4"></a>练习3 &amp; 练习4</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Art</span> </span>&#123;</span><br><span class="line">Art() &#123;</span><br><span class="line">System.out.println(<span class="string">"Art"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drawing</span> <span class="keyword">extends</span> <span class="title">Art</span> </span>&#123;</span><br><span class="line">Drawing() &#123;</span><br><span class="line">System.out.println(<span class="string">"Drawing"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cartoon</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cartoon</span> <span class="keyword">extends</span> <span class="title">Drawing</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// public Cartoon() &#123;</span></span><br><span class="line"><span class="comment">// System.out.println("Cartoon");</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Cartoon();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Art</span></span><br><span class="line"><span class="comment">// Drawing</span></span><br></pre></td></tr></table></figure><h3 id="练习5"><a href="#练习5" class="headerlink" title="练习5"></a>练习5</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">A() &#123;</span><br><span class="line">System.out.println(<span class="string">"A"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">B() &#123;</span><br><span class="line">System.out.println(<span class="string">"B"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">B b = <span class="keyword">new</span> B();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> C();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="comment">// B</span></span><br></pre></td></tr></table></figure><h3 id="练习6"><a href="#练习6" class="headerlink" title="练习6"></a>练习6</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">Game(<span class="keyword">int</span> i) &#123;</span><br><span class="line">System.out.println(<span class="string">"Game"</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoardGame</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">BoardGame(<span class="keyword">int</span> i) &#123;</span><br><span class="line"><span class="keyword">super</span>(i);</span><br><span class="line">System.out.println(<span class="string">"BoardGame"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Chess</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chess</span> <span class="keyword">extends</span> <span class="title">BoardGame</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Chess() &#123;</span><br><span class="line"><span class="keyword">super</span>(<span class="number">11</span>); <span class="comment">// 去掉这条语句，会报编译错误</span></span><br><span class="line">System.out.println(<span class="string">"Chess"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Chess();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习7"><a href="#练习7" class="headerlink" title="练习7"></a>练习7</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">A(<span class="keyword">int</span> i) &#123;</span><br><span class="line">System.out.println(<span class="string">"A"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">B(<span class="keyword">int</span> i) &#123;</span><br><span class="line">System.out.println(<span class="string">"B"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">B b = <span class="keyword">new</span> B(<span class="number">1</span>);</span><br><span class="line">C() &#123;</span><br><span class="line"><span class="keyword">super</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> C();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习8"><a href="#练习8" class="headerlink" title="练习8"></a>练习8</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">Game(<span class="keyword">int</span> i) &#123;</span><br><span class="line">System.out.println(<span class="string">"Game"</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoardGame</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">BoardGame() &#123;</span><br><span class="line"><span class="keyword">super</span>(<span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">"BoardGame Default"</span>);</span><br><span class="line">&#125;</span><br><span class="line">BoardGame(<span class="keyword">int</span> i) &#123;</span><br><span class="line"><span class="keyword">super</span>(i);</span><br><span class="line">System.out.println(<span class="string">"BoardGame"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习9"><a href="#练习9" class="headerlink" title="练习9"></a>练习9</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component1</span> </span>&#123;</span><br><span class="line">Component1() &#123;</span><br><span class="line">System.out.println(<span class="string">"Component1"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component2</span> </span>&#123;</span><br><span class="line">Component2() &#123;</span><br><span class="line">System.out.println(<span class="string">"Component2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component3</span> </span>&#123;</span><br><span class="line">Component3() &#123;</span><br><span class="line">System.out.println(<span class="string">"Component3"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Root</span> </span>&#123;</span><br><span class="line">Component1 c1 = <span class="keyword">new</span> Component1();</span><br><span class="line">Component2 c2 = <span class="keyword">new</span> Component2();</span><br><span class="line">Component3 c3 = <span class="keyword">new</span> Component3();</span><br><span class="line">Root() &#123;</span><br><span class="line">System.out.println(<span class="string">"Root"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stem</span> <span class="keyword">extends</span> <span class="title">Root</span> </span>&#123;</span><br><span class="line">Stem() &#123;</span><br><span class="line">System.out.println(<span class="string">"Stem"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Stem();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Component1</span></span><br><span class="line"><span class="comment">// Component2</span></span><br><span class="line"><span class="comment">// Component3</span></span><br><span class="line"><span class="comment">// Root</span></span><br><span class="line"><span class="comment">// Stem</span></span><br></pre></td></tr></table></figure><h3 id="练习10"><a href="#练习10" class="headerlink" title="练习10"></a>练习10</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component1</span> </span>&#123;</span><br><span class="line">Component1(<span class="keyword">int</span> i) &#123;</span><br><span class="line">System.out.println(<span class="string">"Component1"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component2</span> </span>&#123;</span><br><span class="line">Component2(<span class="keyword">int</span> i) &#123;</span><br><span class="line">System.out.println(<span class="string">"Component2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component3</span> </span>&#123;</span><br><span class="line">Component3(<span class="keyword">int</span> i) &#123;</span><br><span class="line">System.out.println(<span class="string">"Component3"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Root</span> </span>&#123;</span><br><span class="line">Component1 c1 = <span class="keyword">new</span> Component1(<span class="number">1</span>);</span><br><span class="line">Component2 c2 = <span class="keyword">new</span> Component2(<span class="number">2</span>);</span><br><span class="line">Component3 c3 = <span class="keyword">new</span> Component3(<span class="number">3</span>);</span><br><span class="line">Root(<span class="keyword">int</span> i) &#123;</span><br><span class="line">System.out.println(<span class="string">"Root"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stem</span> <span class="keyword">extends</span> <span class="title">Root</span> </span>&#123;</span><br><span class="line">Stem(<span class="keyword">int</span> j) &#123;</span><br><span class="line"><span class="keyword">super</span>(j);</span><br><span class="line">System.out.println(<span class="string">"Stem"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Stem(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习11"><a href="#练习11" class="headerlink" title="练习11"></a>练习11</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetergentDelegation</span> </span>&#123;</span><br><span class="line">Detergent detergent = <span class="keyword">new</span> Detergent();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(String a)</span> </span>&#123;</span><br><span class="line">detergent.append(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dilute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">detergent.dilute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">detergent.apply();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">detergent.scrub();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">detergent.foam();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Detergent.main(args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习12"><a href="#练习12" class="headerlink" title="练习12"></a>练习12</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch07;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component1</span> </span>&#123;</span><br><span class="line">Component1(<span class="keyword">int</span> i) &#123;</span><br><span class="line">System.out.println(<span class="string">"Component1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Component1 dispose"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component2</span> </span>&#123;</span><br><span class="line">Component2(<span class="keyword">int</span> i) &#123;</span><br><span class="line">System.out.println(<span class="string">"Component2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Component2 dispose"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component3</span> </span>&#123;</span><br><span class="line">Component3(<span class="keyword">int</span> i) &#123;</span><br><span class="line">System.out.println(<span class="string">"Component3"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Component3 dispose"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Root</span> </span>&#123;</span><br><span class="line">Component1 c1 = <span class="keyword">new</span> Component1(<span class="number">1</span>);</span><br><span class="line">Component2 c2 = <span class="keyword">new</span> Component2(<span class="number">2</span>);</span><br><span class="line">Component3 c3 = <span class="keyword">new</span> Component3(<span class="number">3</span>);</span><br><span class="line">Root(<span class="keyword">int</span> i) &#123;</span><br><span class="line">System.out.println(<span class="string">"Root"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"root dispose"</span>);</span><br><span class="line">c1.dispose();</span><br><span class="line">c2.dispose();</span><br><span class="line">c3.dispose();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stem</span> <span class="keyword">extends</span> <span class="title">Root</span> </span>&#123;</span><br><span class="line">Stem(<span class="keyword">int</span> j) &#123;</span><br><span class="line"><span class="keyword">super</span>(j);</span><br><span class="line">System.out.println(<span class="string">"Stem"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Stem dispose"</span>);</span><br><span class="line"><span class="keyword">super</span>.dispose();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Stem stem = <span class="keyword">new</span> Stem(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">stem.dispose();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Component1</span></span><br><span class="line"><span class="comment">// Component2</span></span><br><span class="line"><span class="comment">// Component3</span></span><br><span class="line"><span class="comment">// Root</span></span><br><span class="line"><span class="comment">// Stem</span></span><br><span class="line"><span class="comment">// Stem dispose</span></span><br><span class="line"><span class="comment">// root dispose</span></span><br><span class="line"><span class="comment">// Component1 dispose</span></span><br><span class="line"><span class="comment">// Component2 dispose</span></span><br><span class="line"><span class="comment">// Component3 dispose</span></span><br></pre></td></tr></table></figure><h3 id="练习13"><a href="#练习13" class="headerlink" title="练习13"></a>练习13</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plate</span> </span>&#123;</span><br><span class="line">    Plate(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Plate"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func int "</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func double "</span> + d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func string "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DinnerPlate</span> <span class="keyword">extends</span> <span class="title">Plate</span> </span>&#123;</span><br><span class="line">    DinnerPlate(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">super</span>(i);</span><br><span class="line">        System.out.println(<span class="string">"DinnerPlate"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func char "</span> + c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DinnerPlate dinnerPlate = <span class="keyword">new</span> DinnerPlate(<span class="number">1</span>);</span><br><span class="line">        dinnerPlate.func(<span class="string">'c'</span>);</span><br><span class="line">        dinnerPlate.func(<span class="string">"hello"</span>);</span><br><span class="line">        dinnerPlate.func(<span class="number">1</span>);</span><br><span class="line">        dinnerPlate.func(<span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Plate</span></span><br><span class="line"><span class="comment">// DinnerPlate</span></span><br><span class="line"><span class="comment">// func char c</span></span><br><span class="line"><span class="comment">// func string hello</span></span><br><span class="line"><span class="comment">// func int 1</span></span><br><span class="line"><span class="comment">// func double 1.0</span></span><br></pre></td></tr></table></figure><h3 id="练习14"><a href="#练习14" class="headerlink" title="练习14"></a>练习14</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch07;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rev</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wheel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inflate</span><span class="params">(<span class="keyword">int</span> psi)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollup</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rolldown</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Window window = <span class="keyword">new</span> Window();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Engine engine = <span class="keyword">new</span> Engine();</span><br><span class="line">    <span class="keyword">public</span> Wheel[] wheels = <span class="keyword">new</span> Wheel[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">public</span> Door left = <span class="keyword">new</span> Door(), right = <span class="keyword">new</span> Door();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            wheels[i] = <span class="keyword">new</span> Wheel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car car = <span class="keyword">new</span> Car();</span><br><span class="line">        car.left.window.rollup();</span><br><span class="line">        car.right.window.rolldown();</span><br><span class="line">        car.wheels[<span class="number">0</span>].inflate(<span class="number">72</span>);</span><br><span class="line">        car.engine.service();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习15"><a href="#练习15" class="headerlink" title="练习15"></a>练习15</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch07;</span><br><span class="line"><span class="keyword">import</span> com.company.ch05.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ex15</span> <span class="keyword">extends</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ex15 ex15 = <span class="keyword">new</span> Ex15();</span><br><span class="line">        ex15.func();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习16"><a href="#练习16" class="headerlink" title="练习16"></a>练习16</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Amphibian</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Amphibian amphibian)</span> </span>&#123;</span><br><span class="line">        amphibian.func();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Frog</span> <span class="keyword">extends</span> <span class="title">Amphibian</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Frog frog = <span class="keyword">new</span> Frog();</span><br><span class="line">        Amphibian.test(frog);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习17"><a href="#练习17" class="headerlink" title="练习17"></a>练习17</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Amphibian</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Amphibian func"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Amphibian amphibian)</span> </span>&#123;</span><br><span class="line">        amphibian.func();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Frog</span> <span class="keyword">extends</span> <span class="title">Amphibian</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Frog func"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Frog frog = <span class="keyword">new</span> Frog();</span><br><span class="line">        Amphibian.test(frog);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Frog func</span></span><br></pre></td></tr></table></figure><h3 id="练习18"><a href="#练习18" class="headerlink" title="练习18"></a>练习18</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ex18</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> i = random.nextInt(<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> j = random.nextInt(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ex18 ex18 = <span class="keyword">new</span> Ex18();</span><br><span class="line">        System.out.println(<span class="string">"ex18.i = "</span> + ex18.i);</span><br><span class="line">        System.out.println(<span class="string">"ex18.j = "</span> + ex18.j);</span><br><span class="line">        Ex18 ex181 = <span class="keyword">new</span> Ex18();</span><br><span class="line">        System.out.println(<span class="string">"ex181.i = "</span> + ex181.i);</span><br><span class="line">        System.out.println(<span class="string">"ex181.j = "</span> + ex181.j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ex18.i = 8</span></span><br><span class="line"><span class="comment">// ex18.j = 6</span></span><br><span class="line"><span class="comment">// ex181.i = 4</span></span><br><span class="line"><span class="comment">// ex181.j = 6</span></span><br></pre></td></tr></table></figure><h3 id="练习19"><a href="#练习19" class="headerlink" title="练习19"></a>练习19</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ex19</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> k;</span><br><span class="line">    Ex19() &#123;</span><br><span class="line">        k = <span class="number">1</span>; <span class="comment">// 必须赋值</span></span><br><span class="line">        <span class="comment">// k = 2; // 会报错</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ex19 ex19 = <span class="keyword">new</span> Ex19();</span><br><span class="line">        <span class="comment">// ex19.k = 1; // 会报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习20"><a href="#练习20" class="headerlink" title="练习20"></a>练习20</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch07;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithFinal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"WithFinal.f()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"WithFinal.g()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OverridingPrivate</span> <span class="keyword">extends</span> <span class="title">WithFinal</span> </span>&#123;</span><br><span class="line"><span class="comment">//    @Override //加上注解后编译错误</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"OverridingPrivate.f()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    @Override //加上注解后编译错误</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"OverridingPrivate.g()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OverridingPrivate2</span> <span class="keyword">extends</span> <span class="title">OverridingPrivate</span> </span>&#123;</span><br><span class="line"><span class="comment">//    @Override //加上注解后编译错误</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"OverridingPrivate2.f()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    @Override //加上注解后编译错误</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"OverridingPrivate2.g()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalOverridingIllusion</span> <span class="keyword">extends</span> <span class="title">OverridingPrivate2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OverridingPrivate2 overridingPrivate2 = <span class="keyword">new</span> OverridingPrivate2();</span><br><span class="line">        overridingPrivate2.f();</span><br><span class="line">        overridingPrivate2.g();</span><br><span class="line"></span><br><span class="line">        OverridingPrivate overridingPrivate = overridingPrivate2;</span><br><span class="line"><span class="comment">//        overridingPrivate.f(); 无法调用</span></span><br><span class="line"><span class="comment">//        overridingPrivate.g();</span></span><br><span class="line">        WithFinal withFinal = overridingPrivate;</span><br><span class="line"><span class="comment">//        withFinal.f(); 无法调用</span></span><br><span class="line"><span class="comment">//        withFinal.g();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习21"><a href="#练习21" class="headerlink" title="练习21"></a>练习21</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch07;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Final</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ex21</span> <span class="keyword">extends</span> <span class="title">Final</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 编译出错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习22"><a href="#练习22" class="headerlink" title="练习22"></a>练习22</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch07;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalClass</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ex22</span> <span class="keyword">extends</span> <span class="title">FinalClass</span> </span>&#123; <span class="comment">//编译出错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习23"><a href="#练习23" class="headerlink" title="练习23"></a>练习23</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Insert</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i =  <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> j;</span><br><span class="line">    Insert() &#123;</span><br><span class="line">        System.out.println(<span class="string">"i = "</span> + i + <span class="string">" j = "</span> + j);</span><br><span class="line">        j = <span class="number">39</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x1 = printInit(<span class="string">"static Insert.x1 init"</span>);</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">printInit</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">47</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Beetle</span> <span class="keyword">extends</span> <span class="title">Insert</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> k = printInit(<span class="string">"Beetle.k init"</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Beetle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"k = "</span> + k);</span><br><span class="line">        System.out.println(<span class="string">"j = "</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x2 = printInit(<span class="string">"static Beetle.x2 init"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> x3 = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Beetle constructor"</span>);</span><br><span class="line">        <span class="keyword">new</span> Beetle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ex23</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Beetle();</span><br><span class="line"><span class="comment">//        static Insert.x1 init</span></span><br><span class="line"><span class="comment">//        static Beetle.x2 init</span></span><br><span class="line"><span class="comment">//        i = 9 j = 0</span></span><br><span class="line"><span class="comment">//        Beetle.k init</span></span><br><span class="line"><span class="comment">//        k = 47</span></span><br><span class="line"><span class="comment">//        j = 39</span></span><br><span class="line">        <span class="comment">// or</span></span><br><span class="line">        <span class="comment">// System.out.println(Beetle.x3);</span></span><br><span class="line"><span class="comment">//        static Insert.x1 init</span></span><br><span class="line"><span class="comment">//        static Beetle.x2 init</span></span><br><span class="line"><span class="comment">//        3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习24"><a href="#练习24" class="headerlink" title="练习24"></a>练习24</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Insert</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i =  <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> j;</span><br><span class="line">    Insert() &#123;</span><br><span class="line">        System.out.println(<span class="string">"i = "</span> + i + <span class="string">" j = "</span> + j);</span><br><span class="line">        j = <span class="number">39</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x1 = printInit(<span class="string">"static Insert.x1 init"</span>);</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">printInit</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">47</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Beetle</span> <span class="keyword">extends</span> <span class="title">Insert</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> k = printInit(<span class="string">"Beetle.k init"</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Beetle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"k = "</span> + k);</span><br><span class="line">        System.out.println(<span class="string">"j = "</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x2 = printInit(<span class="string">"static Beetle.x2 init"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> x3 = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Beetle constructor"</span>);</span><br><span class="line">        <span class="keyword">new</span> Beetle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ex24</span> <span class="keyword">extends</span> <span class="title">Beetle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Ex24();</span><br><span class="line"><span class="comment">//        static Insert.x1 init</span></span><br><span class="line"><span class="comment">//        static Beetle.x2 init</span></span><br><span class="line"><span class="comment">//        i = 9 j = 0</span></span><br><span class="line"><span class="comment">//        Beetle.k init</span></span><br><span class="line"><span class="comment">//        k = 47</span></span><br><span class="line"><span class="comment">//        j = 39</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>调用 Ex24 的main函数（静态方法），准备加载 Ex24，但是发现其继承与 Beetle</li><li>准备加载 Beetle，但是发现其继承与 Insert，因此先加载 Insert</li><li>Insert 中的静态数据先初始化，所以会输出<code>static Insert.x1 init</code></li><li>Insert 加载并初始化完后，加载 Beetle 并对静态数据进行初始化，所以会输出<code>static Beetle.x2 init</code></li><li>然后加载 Ex24，加载过程完成，调用 main 函数</li><li><code>new Ex24</code>时，实例化的顺序为 <code>Insert -&gt; Beetle -&gt; Ex24</code></li><li>所以先输出 Insert 构造函数中的 <code>i = 9 j = 0</code>，之所以 j 为0，是因为int默认值为0</li><li>然后在实例化 Beetle 时，先会执行 实例初始化，即<code>private int k = printInit(&quot;Beetle.k init&quot;);</code></li><li>最后才是 Beetle 的构造函数。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 《Java编程思想》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 阅读笔记 </tag>
            
            <tag> 《Java编程思想》 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《 Java 编程思想》CH06 访问权限控制</title>
      <link href="/2020/02/14/%E3%80%8A-Java-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8BCH06-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
      <url>/2020/02/14/%E3%80%8A-Java-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8BCH06-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<ul><li><strong>访问控制（或隐藏具体实现）与“最初的实现并不恰当”有关</strong>。</li><li>重构即重写代码，以使得它更可读，更容易理解，并因此而更具维护性。</li><li>在面向对象设计中需要考虑一个基本问题：“如何把变动的事物与保持不变的事物区分开来”</li><li>应该尽可能将一切方法都定为<code>private</code>，而仅向客户端程序员公开你愿意让他们使用的方法。</li></ul><h2 id="包：库单元"><a href="#包：库单元" class="headerlink" title="包：库单元"></a>包：库单元</h2><ul><li>包内包含有一组类，它们在单一的名字空间之下被组织在一起</li><li>为了解决潜在的名字冲突问题，Java使用 package 对名称空间进行完全控制并为每一个类创建唯一的标识符组合。</li><li>每一个编译单元（.java 文件）只能有一个 public 类。</li><li>当编译一个 Java 文件时，.java 文件中的每一个类都会生成一个与其类名相同的 .class 文件</li><li>Java 可运行程序是一组可以打包并压缩为一个 Java 文档文件（JAR）的 .class 文件，Java解释器负责这些文件的查找、装载和解释。</li><li>类库实际上一组类文件。其中每个文件都有一个 public 类，以及任意数量的非 public 类。因此每个文件都有一个构件，如果希望他们都属于同一个群组，则可以使用关键词 package。</li><li>package 语句必须是文件中除了注释外的第一行代码。如<code>packgae access;</code>表示当前文件是 access 类库的一部分，标识符为<code>access.ClassName</code>;</li><li>package 名称的第一部分应该是域名的逆序。</li><li>package 名称会被分解为一个目录路径，这个包的所有文件都应该放在该文件夹中，例如包名为<code>fun.wuxiaobai24.access</code>，则被解释成<code>$CLASSPATH/fun/wuxiaobai24/access</code>，其中<code>$CLASSPATH</code>为环境变量，CLASSPATH 可以指定多个目录。</li><li>在使用JAR文件时，需要在 CLASSPATH 中指明JAR文件的真实路径，如<code>CLASSPATH = .;~/jar/access.jar</code></li><li>如果将两个包含相同名称的类库用<code>*</code>形式导入时，在使用重名的类时，需要指明是那个包中的，如<code>fun.wuxiaobai24.access.ClassName c = new fun.wuxiaobai24.access.ClassName()</code></li><li>使用<code>import static</code>语句进行静态导入，将某个包中的所有静态方法导入，这样可以直接用静态方法名进行方法调用，而不用在前面加类名，如调用某个类中的 main() 方法时，静态导入可以直接<code>main();</code>，而普通的导入而需要<code>ClassName.main();</code></li><li>Java 中 没有 C 中的条件编译，但是可以用 import 来间接实现某些功能。</li></ul><h2 id="Java-访问权限修饰词"><a href="#Java-访问权限修饰词" class="headerlink" title="Java 访问权限修饰词"></a>Java 访问权限修饰词</h2><ul><li>包访问权限允许将包内所有相关的类组合在一起，以使得它们彼此之间可以相互访问作用。</li><li>继承而来的类可以访问<code>public</code>和<code>protected</code>，只有当两个类在同一个包中时才能访问包访问权限的成员。</li><li>对于OOP而言，提供访问器和变异器（getter/setter），以读取或改变数值是最优雅的方法，而是 JavaBean 的基本原理。</li><li>如果没有给文件指定包，Java 将这些文件视为该目录的默认包中，于是给该目录中所有其他的文件提供包访问权限。</li><li>不能因为在类中某个对象的引用是 private，就认为其他对象就不能拥有该对象。</li><li>protected 成员除了继承的子类可以访问外，它也有包访问权限，即同一个包下的类可以访问它。</li><li>private 可以用来实现单例子模式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Soup</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Soup</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Soup soup = <span class="keyword">new</span> Soup();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Soup <span class="title">access</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> soup;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口和实现"><a href="#接口和实现" class="headerlink" title="接口和实现"></a>接口和实现</h2><p>访问权限的控制常被称为具体实现的隐藏。把数据和方法包装进类中，以及具体的实现的隐藏，常共同被称为<strong>封装</strong>。其结果是一个同时带有特征和行为的数据类型。</p><p>访问权限控制将权限的边界划在数据类型的内部的原因：</p><ul><li>不用担心客户端程序员偶然地将内部机制当作他们可以使用的接口的一部分。</li><li>接口和具体实现的分离</li></ul><h2 id="类的访问权限"><a href="#类的访问权限" class="headerlink" title="类的访问权限"></a>类的访问权限</h2><p>为了控制类的访问权限，修饰词必须出现在关键词 class 之前，如<code>public class ClassName</code>。同时有一些额外的限制：</p><ul><li>每个编译单元（文件）都只能有一个 public 类。每个编译单元都有单一的公共接口，同 public 类实现</li><li>public 类的名称必须与文件名相同，包括大小写。</li><li>编译单元（文件）中可以完全不带 public 类，此时可以随意对文件命名。</li></ul><p><strong>类的访问权限只有 public 和包访问权限</strong>。如果希望其他任何人对该类有访问权限，可以将所有的构造器都指定为 private，但是该类中 static 成员仍然可以创建和访问。</p>]]></content>
      
      
      <categories>
          
          <category> 《Java编程思想》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 阅读笔记 </tag>
            
            <tag> 《Java编程思想》 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 安装记录</title>
      <link href="/2020/02/10/Flutter-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/02/10/Flutter-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最近想开始写日记了，但是找了一圈发现好像好用又安全的App几乎没有，主要是怕不安全。很多App是不支持导出什么的,而且存在别人的服务器上总感觉不好，要是公司倒闭了，我们的日记岂不是全没有，就算有导出功能，要迁移到另一个App上好像也是很麻烦的样子。而那些支持保存到Webdev上基本是不加密的，也很危险啊。Whatever，我现在有点想做一个移动端的东西，也就是日记本。</p><p>调研了一圈，移动端基本上有三种选择：</p><ul><li>Java + Android</li><li>React Native</li><li>Flutter </li></ul><p>三者之中，Java + Android 应该是最稳的，毕竟有点 Java 基础；React Native 应该是最理想的，因为很容易就迁移到网页上啊；Flutter 应该算是一个比较激进的做法了，比较新技术，有许多坑，不过现在应该还是算挺多人在用了。作为一个有志向的开发者，踩坑才是最好玩的事情啊。whatever，我觉得用 Flutter 来实现这个东西了。BTW，写这篇东西一方面是为了记录安装中遇到的坑，另一方面也是立Flag（捂脸）。</p><h2 id="安装-Flutter"><a href="#安装-Flutter" class="headerlink" title="安装 Flutter"></a>安装 Flutter</h2><p>我使用的环境是 Manjaro Linux，所以可以不按照官网上的方法下载包然后安装，直接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S flutter</span><br></pre></td></tr></table></figure><p>安装完后显示下面这个东西，只需要按照他这里说明的进行一些配置即可。有一点要注意的是，这些命令全部都需要 root 权限，即在命令前面加 sudo 即可。</p><p><img src="http://imagehosting.wuxiaobai24.fun/blogFlutter-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95-20200210175913-2020-2-10" alt="安装Flutter后的输出"></p><p>基本上就安装成功了，可以按照<code>flutter.cn</code>中给出的安装教程一步步走即可。</p><h2 id="国情带来的坑"><a href="#国情带来的坑" class="headerlink" title="国情带来的坑"></a>国情带来的坑</h2><p>在第一次运行<code>flutter doctor</code>之前记得把镜像源配置好，这里可以参考<img src="https://flutter.dev/community/china" alt="官方文档">：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> FLUTTER_STORAGE_BASE_URL=https://mirrors.tuna.tsinghua.edu.cn/flutter</span><br><span class="line"><span class="built_in">export</span> PUB_HOSTED_URL=https://mirrors.tuna.tsinghua.edu.cn/dart-pub</span><br></pre></td></tr></table></figure><p>然后<code>Gradle</code>也有一个镜像源需要配置：</p><p>一个是项目中<code>android/gradle/build.gradle</code>:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    ext.kotlin_version = <span class="string">'1.3.50'</span></span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        <span class="comment">// google()</span></span><br><span class="line">        <span class="comment">// jcenter()</span></span><br><span class="line">        maven &#123; url <span class="string">'https://maven.aliyun.com/repository/google'</span> &#125;</span><br><span class="line">        maven &#123; url <span class="string">'https://maven.aliyun.com/repository/jcenter'</span> &#125;</span><br><span class="line">        maven &#123; url <span class="string">'http://maven.aliyun.com/nexus/content/groups/public'</span> &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">dependencies</span> &#123;</span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">'com.android.tools.build:gradle:3.5.0'</span></span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">allprojects</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        <span class="comment">// google()</span></span><br><span class="line">        <span class="comment">// jcenter()</span></span><br><span class="line">        maven &#123; url <span class="string">'https://maven.aliyun.com/repository/google'</span> &#125;</span><br><span class="line">        maven &#123; url <span class="string">'https://maven.aliyun.com/repository/jcenter'</span> &#125;</span><br><span class="line">        maven &#123; url <span class="string">'http://maven.aliyun.com/nexus/content/groups/public'</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是有<code>/opt/flutter/packags/flutter_tools/gradle/flutter.gradle</code></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        <span class="comment">// google()</span></span><br><span class="line">        <span class="comment">// jcenter()</span></span><br><span class="line">        </span><br><span class="line">        maven &#123; url <span class="string">'https://plugins.gradle.org/m2/'</span> &#125;</span><br><span class="line">        maven &#123; url <span class="string">'http://maven.aliyun.com/nexus/content/repositories/google'</span> &#125;</span><br><span class="line">        maven &#123; url <span class="string">'http://maven.aliyun.com/nexus/content/groups/public/'</span> &#125;</span><br><span class="line">        maven &#123; url <span class="string">'http://maven.aliyun.com/nexus/content/repositories/jcenter'</span>&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flutter 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 踩坑记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《 Java 编程思想》CH05 初始化与清理</title>
      <link href="/2020/02/09/%E3%80%8A-Java-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8BCH05-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/"/>
      <url>/2020/02/09/%E3%80%8A-Java-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8BCH05-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="用构造器确保初始化"><a href="#用构造器确保初始化" class="headerlink" title="用构造器确保初始化"></a>用构造器确保初始化</h2><p>在 Java 中，通过提供构造器，类的设计者可确保每个对象都会得到初始化。Java 会保证初始化的进行。<strong>构造器采用与类相同的名称</strong>。</p><ul><li>由于构造器的名称必须与类名完全相同，所以“每个方法首字母小写”的风格在这里不适用。</li><li>构造器方法可以有参数，这样可以在初始化对象时提供实际参数。</li><li>不接受任何参数的构造器叫做“默认构造器”。</li><li>构造器一种特殊类型的方法，<strong>它没有返回值</strong></li></ul><h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>因为可以要用多种方式来创建并初始化一个对象，所以就需要多个构造器，而构造器的名称又需要和类名相同，所以必须允许<strong>方法名相同而形式参数不同的构造器</strong>存在，所以 Java 中有<strong>方法重载</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rock</span> </span>&#123;</span><br><span class="line">Rock() &#123;</span><br><span class="line"><span class="comment">// 默认构造器</span></span><br><span class="line">&#125;</span><br><span class="line">Rock(<span class="keyword">int</span> i) &#123;</span><br><span class="line"><span class="comment">// 带参数的构造器</span></span><br><span class="line">System.out.println(<span class="string">"i="</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"i = null"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"i = "</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">Rock r1 = <span class="keyword">new</span> Rock(); <span class="comment">// 调用默认构造器</span></span><br><span class="line">Rock r2 = <span class="keyword">new</span> Rock(<span class="number">1</span>); <span class="comment">// 调用带参数的构造器</span></span><br><span class="line">r2.print();</span><br><span class="line">r2.print(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="区分重载方法"><a href="#区分重载方法" class="headerlink" title="区分重载方法"></a>区分重载方法</h3><p><strong>方法签名是由方法名和参数类型列表构成的</strong>，所以用参数类型列表区分重载方法。<strong>不能用返回值区分重载方法</strong></p><h3 id="设计基本类型的重载"><a href="#设计基本类型的重载" class="headerlink" title="设计基本类型的重载"></a>设计基本类型的重载</h3><p>由于基本类型可能会从一个“较小”的类型自动提升为一个“较大”的类型，所以在重载方法中需要特别注意：</p><ul><li>常数值当作<code>int</code>处理</li><li>实参的数据类型小于形参的数据类型时，会自动提升</li><li>对于 char 类型，如果找不到以 char 作为形参的方法的话，会把 char 类型提升成 int 类型</li><li>如果实参大于形参的话，需要显式的强制转换否则会报编译错误</li></ul><h2 id="默认构造器"><a href="#默认构造器" class="headerlink" title="默认构造器"></a>默认构造器</h2><ul><li>默认构造器是一个没有形式参数的构造器，其作用是创建一个“默认对象”</li><li>如果类中没有构造器，编译器会自动创建一个默认构造器</li><li>如果类中已经有了一个构造器了，编译器则不会自动创建默认构造器</li></ul><h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h2><p>由于同一类型的对象都可以调用相同的方法，为了在方法中区分不同的对象，会把对象的引用作为参数传递给方法，<code>a.fun(1)</code>在编译器内部会被翻译成<code>ClassName.fun(a, 1)</code>，我们可以通过<code>this</code>关键字在方法中访问到对象的引用。</p><ul><li>在方法内部调用同个类的另一个方法不需要使用<code>this</code>,直接调用即可。</li><li>this 可以在方法内部作为参数传递给另一个方法，也可以作为返回值（可以构造出链式操作）</li></ul><h3 id="在构造器中调用构造器"><a href="#在构造器中调用构造器" class="headerlink" title="在构造器中调用构造器"></a>在构造器中调用构造器</h3><ul><li>可以利用 this 来实现在构造器中调用构造器，这样可以避免重复代码。</li><li>this 在一个构造器中只能调用一次构造器</li><li>必须将构造器置于最开始处，否则编译器会报错</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Flower</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> petalCount = <span class="number">0</span>;</span><br><span class="line">    String s = <span class="string">"initial value"</span>;</span><br><span class="line"></span><br><span class="line">    Flower(<span class="keyword">int</span> petals) &#123;</span><br><span class="line">        petalCount = petals;</span><br><span class="line">        System.out.println(<span class="string">"int arg ,petalCount = "</span> + petalCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Flower(String ss) &#123;</span><br><span class="line">        s = ss;</span><br><span class="line">        System.out.println(<span class="string">"string arg ,s = "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Flower(String s, <span class="keyword">int</span> petals) &#123;</span><br><span class="line">        <span class="keyword">this</span>(petals);</span><br><span class="line">        <span class="comment">// this 只能调用一次构造器</span></span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        System.out.println(<span class="string">"string &amp; int arg, s = "</span> + s + <span class="string">", petalCount = "</span> + petalCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Flower() &#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">"hello"</span>, <span class="number">24</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Flower flower = <span class="keyword">new</span> Flower();</span><br><span class="line">        System.out.println(<span class="string">"flower.petalCount = "</span> + flower.petalCount);</span><br><span class="line">        System.out.println(<span class="string">"flower.s = "</span> + flower.s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// int arg ,petalCount = 24</span></span><br><span class="line"><span class="comment">// string &amp; int arg, s = hello, petalCount = 24</span></span><br><span class="line"><span class="comment">// flower.petalCount = 24</span></span><br><span class="line"><span class="comment">// flower.s = hello</span></span><br></pre></td></tr></table></figure><h3 id="static-的含义"><a href="#static-的含义" class="headerlink" title="static 的含义"></a>static 的含义</h3><p>static 方法就是没有 this 的方法，在 static 中不能调用非静态方法，但是反过来可以。</p><h2 id="清理：终结处理和垃圾回收"><a href="#清理：终结处理和垃圾回收" class="headerlink" title="清理：终结处理和垃圾回收"></a>清理：终结处理和垃圾回收</h2><ol><li>对象可能不会被垃圾回收</li><li>垃圾回收不等于“析构”<ol><li>Java 未提供“析构函数”或相似的概念，要做类似的清理工作，必须手动创建一下执行清理工作的普通方法</li></ol></li><li>垃圾回收只与内存有关<ol><li>对与垃圾回收有关的任何行为来说（尤其是 finalize() 方法），它们必须同内存及其回收相关</li><li>finalize() 的需求通常是用于一种特殊情况，即通过某种创建对象方式以外的方式为对象分配了存储空间，这种情况主要发生在使用了“本地方法”的情况下，本地方法是一种在 Java 中调用非 Java 代码的方式。如在非 Java 代码中调用了 malloc，为了释放内存，我们需要在 finalize() 中调用对应的本地方法进行 free。</li><li>finalize() 方法的执行机制：<strong>一旦垃圾回收器准备释放对象占用的存储空间，首先调用其 finalize() 方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。</strong></li></ol></li></ol><h3 id="你必须实施清理"><a href="#你必须实施清理" class="headerlink" title="你必须实施清理"></a>你必须实施清理</h3><p>Java 中没有用于释放对象的 delete，因为垃圾回收器会自动帮你释放存储空间，因此 Java 中没有析构函数。<strong>但是垃圾回收不能完全代替析构函数</strong>，如果希望进行除释放存储空间之外的清理工作，我们需要明确调用某个 Java 方法。例如某个类打开了一个文件，垃圾回收不能自动帮我们关闭这个文件。为什么这个工作不能有 finalize() 方法来完成呢，原因其实在上面已经说明了，<strong>对象可能不会被垃圾回收</strong>，也就是说 finalize() 方法可能永远都不会被调用。</p><p>如果 JVM 没有面临内存耗尽的情况，它是不会浪费时间去执行垃圾回收以恢复内存的。</p><h3 id="终结条件"><a href="#终结条件" class="headerlink" title="终结条件"></a>终结条件</h3><p>虽然我们不能用 finalize() 方法来进行“清理”，但是我们可以利用它验证某个对象的终结条件。还是刚才那个打开文件的例子，假设在文件没有关闭的时候，垃圾回收将对象回收了，这就会产生一些非常难找的 bug。而 finalize() 可以帮助我们发现这种 bug。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> checkedOut = <span class="keyword">false</span>;</span><br><span class="line">    Book(<span class="keyword">boolean</span> checkOut) &#123;</span><br><span class="line">        checkedOut = checkOut;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkIn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkedOut = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (checkedOut) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Error: checked out"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// super.finalize();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TerminationCondition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Book novel = <span class="keyword">new</span> Book(<span class="keyword">true</span>);</span><br><span class="line">        novel.checkIn();</span><br><span class="line">        <span class="keyword">new</span> Book(<span class="keyword">true</span>);</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Error: checked out</span></span><br></pre></td></tr></table></figure><p>如上面这个例子，我们希望 Book 在被回收前已经 checkIn 了，所以我们在 finalize() 中写了一个条件语句来判断。</p><ul><li><code>System.gc()</code>强制 GC</li><li>应该总是假设基类的 finalize() 也需要做某些时间，所以我们应该在 finalize() 函数的末尾加入 <code>super.finalize();</code></li></ul><h3 id="垃圾回收器如何工作"><a href="#垃圾回收器如何工作" class="headerlink" title="垃圾回收器如何工作"></a>垃圾回收器如何工作</h3><p>垃圾回收器会提高对象在堆上创建的速度，这是因为 Java 的堆的实现与 C++ 的不同，其更像是一个传送带，每分配一个对象，它就往前移动一格，所以“堆指针” 只是简单的移动到尚未分配的空间，这意味 Java 中在堆上的分配速度非常快。当然，如果只是简单的像传送带一样工作的话，Java 的堆会占用大量的虚拟内存，进而导致频繁的页面调度，并可能会导致内存资源耗尽，因此需要有垃圾回收器的介入。垃圾回收会一边回收空间一边对堆进行“紧凑”操作。</p><p>几种常见的垃圾回收机制：</p><ul><li>引用计数：一种简单但比较慢的垃圾回收机制。<ul><li>每个对象都有一个引用计数器，当引用连接对象时，引用计数加一，当引用离开作用域或被置 null 时，引用计数减一。</li><li>这种方法无法处理“循环引用”的情况。</li></ul></li><li>停止-复制（stop-and-copy)：<ul><li>其依据的思想是：对任何“活”的对象，一定能最终追溯到其存活在堆栈或静态存储区域之中。因此，可以从堆栈和静态存储区开始，遍历所有的引用，并递归查找该对象所包含的所有对象，即可找到所有“活”的对象。</li><li>该机制会先暂停程序的运行，然后将所有存活的对象从当前堆复制到另一个堆，然后更新引用</li><li>当对象被复制到新的堆中时，没复制的则相当于被回收了，同时可以实现“紧凑”的目标。</li><li>该机制会有以下两个缺点：<ul><li>需要两个堆，进而需要维护比之前大一倍的空间</li><li>如果只有少量垃圾甚至没有垃圾，而这时如果进行垃圾回收的话，开销太大了。</li></ul></li></ul></li><li>标记-清扫（mark-and-sweep)：<ul><li>与 stop-and-copy 机制依据的思想是一样的也是，用同样的方式找到“活”的对象</li><li>每当它找到一个“活”的对象，就会给该对象一个标记，这个过程中不会回收任何对象。只有当全部标记工作完成时，才会进行清理。</li><li>清理的过程中，没有被标记的对象被释放，但<strong>不会做任何复制动作</strong>。</li><li>为了避免存储空间的“碎片化”，JVM 需要做紧凑操作</li></ul></li></ul><p>JVM 中采用的垃圾回收机制：</p><ul><li>一种结合的 stop-and-copy 和 mark-and-sweep 的自适应垃圾回收算法</li><li>内存分配以较大的“快”作为单位，较大的对象可以独占一个块。每个块都有相应的代数（generation count）来记录它是否存活。</li><li>垃圾回收会对上次回收操作之后新分配的快进行整理，这样有助于解决有大量短命对象的情况。</li><li>垃圾回收机制会定期进行完整的清理——大型对象仍然不会被复制（只是其代数会增加），而那些含有大量小型对象的快会被复制并整理。</li><li>当只有少量或没有垃圾产生时，则转为使用 mark-and-sweep 算法。</li></ul><p>Java 中 JIT（Just-In-Time）技术：</p><p>这种技术可以把程序全部或部分翻译成本地机器码，而不是通过 JVM，进而提升程序的运行速度。</p><p>当需要装载某个类时（第一次创建这个类时），编译器会找到其.class 文件，然后将该类的字节码装入内存，此时有两种做法：</p><ul><li>JIT 直接编译所有代码，但这个做法会有两个缺点：<ul><li>加载动作分散在整个程序中，累加起来要话更多时间</li><li>可能会增加可执行代码的长度，进而导致页面调度</li></ul></li><li>惰性评估（lazy evaluation）：，即 JIT 只在必要时才编译，这样不会执行的代码就不会被 JIT 所编译。</li></ul><h2 id="成员初始化"><a href="#成员初始化" class="headerlink" title="成员初始化"></a>成员初始化</h2><p><strong>Java 尽力保证：所有变量在使用前都能得到适当的初始化。</strong></p><p>局部变量没有默认初始值，如有在未初始化前使用它会报错编译错误，而类变量则有默认初始值。</p><h3 id="指定初始化"><a href="#指定初始化" class="headerlink" title="指定初始化"></a>指定初始化</h3><p>Java 允许在定义类成员变量的时候为其赋值进行初始化。非基本类型也可以，同时可以使用已经函数或已经初始化好的变量进行初始化，但要保证初始化顺序的正确。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitialValues</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> t = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">short</span> s = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> i = func(s);</span><br><span class="line"><span class="keyword">long</span> l = <span class="number">4</span> + i;</span><br><span class="line"><span class="keyword">float</span> f = (<span class="keyword">float</span>)<span class="number">5.0</span>; <span class="comment">// 浮点数字面量是 double 类型的</span></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">6.0</span>;</span><br><span class="line">String reference = <span class="keyword">new</span> String(<span class="string">"hello world"</span>); <span class="comment">// 非基本类型也可以</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">short</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造器初始化"><a href="#构造器初始化" class="headerlink" title="构造器初始化"></a>构造器初始化</h2><ul><li>无法阻止自动初始化的进行，它将在构造器之前执行。</li><li>类变量的定义顺序决定了初始化的顺序</li><li>静态数据的默认值与类变量一致</li><li>对于静态变量，Java 可以将多个初始化语句组合成一个静态块，其和静态变量初始化一样在类加载时执行。顺序与定义时的顺序相同</li><li>对于非静态变量，Java 中也可以将多个初始化语句组成一个块，在实例初始化执行。</li><li>对于以上两种块，既可以可以把它当成一条初始化语句来看待。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitialValues</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> t = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">short</span> s = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">long</span> l = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">float</span> f;</span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line">String reference;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">f = (<span class="keyword">float</span>) <span class="number">1.0</span>;</span><br><span class="line">d = <span class="number">2</span>*f;</span><br><span class="line">reference = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">reference = reference + f + d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"A is "</span> + a);</span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象的创建过程：</p><ol><li>第一次创建类或者访问其静态数据或方法，JVM 会加载其 .class 文件，此时执行所有静态初始化（按定义的顺序执行）。</li><li>当 new 该类时，首先会在堆上分配空间，因为堆在分配前被置零了，所以本类型的默认值都是 0，非基本类型的引用的默认值则是 null。</li><li>按顺序执行非静态的初始化</li><li>执行构造器</li></ol><h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2><p>数组是同类型的、用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。</p><p>定义方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a; <span class="comment">//建议使用这种</span></span><br><span class="line"><span class="keyword">int</span> a[]; <span class="comment">//这样也可以， 但是不能指定数组的类型。`int a[3];` 这样是不允许的</span></span><br></pre></td></tr></table></figure><p><code>int[] a;</code>这样只是定义了一个数组的引用，我们可以使用<code>new</code>来创建一个数组，也可以直接初始化数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; <span class="comment">// 使用 new 来创建一个数组，这时真实数据会分配在堆中，所以默认值都为“零”</span></span><br><span class="line"><span class="keyword">int</span>[] b = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 直接初始化一个长度为3的数组</span></span><br><span class="line">Integer[] c = <span class="keyword">new</span> Integer[<span class="number">3</span>]; <span class="comment">// 创建一个对象数组，保存引用，这时初始值都为 null</span></span><br><span class="line">Random rand = <span class="keyword">new</span> Random(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> len = rand.nextInt(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[len]; <span class="comment">// 长度不一定要是一个字面值，可以是变量</span></span><br></pre></td></tr></table></figure><p>数组初始化的坑点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">InitialValues initialValues = <span class="keyword">new</span> InitialValues();</span><br><span class="line">initialValues.printInitialValues();</span><br><span class="line">String[] stringArray = &#123;<span class="string">"hello"</span>, <span class="string">"world"</span>&#125;;</span><br><span class="line"><span class="comment">// initialValues.printStringArrary(&#123;"hello", "world"&#125;); // 编译错误</span></span><br><span class="line">initialValues.printStringArrary(stringArray);</span><br><span class="line">initialValues.printStringArrary(<span class="keyword">new</span> String[]&#123;<span class="string">"hello"</span>, <span class="string">"world"</span>&#125;); <span class="comment">//正确打开方式</span></span><br><span class="line"><span class="keyword">int</span>[] intArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">// initialValues.printIntArray(&#123;1, 2, 3, 4&#125;); // 编译错误</span></span><br><span class="line">initialValues.printIntArray(intArray);</span><br><span class="line">initialValues.printIntArray(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br></pre></td></tr></table></figure><h2 id="可变参数列表"><a href="#可变参数列表" class="headerlink" title="可变参数列表"></a>可变参数列表</h2><p>在方法中，用<code>ClassName... ArgName</code>的形式可以定义可变参数列表，在方法中，ArgName 本质上是一个数组。在可变列表中可以使用任何类型，包括基础类型。这里传入基本类型时，没有依赖自动装包和解包，这意味着，ClassName 为 int 时，ArgName 是一个 int[]，而不是 Integer。<strong>在重载方法时，应该只在一个方法中使用可变参数列表</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Object arg: args) &#123;</span><br><span class="line">        System.out.print(arg + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> required, <span class="keyword">int</span>... args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Required: "</span> + required);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i: args) &#123;</span><br><span class="line">        System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    printArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    f(<span class="number">1</span>);</span><br><span class="line">    f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    Integ</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><ul><li>按照命名习惯，枚举值一般用全大写字母</li><li>为了使用 enum，需要创建一个该类型的引用</li><li>enum 会自动创建一些实用的函数，如<code>toString()</code>显示其名称，<code>ordinal()</code>表示声明顺序</li><li>enum 适合与 switch 一起使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> EnumDemo &#123;</span><br><span class="line">HELLO, WORLD, </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EnumDemo e1 = EnumDemo.HELLO;</span><br><span class="line">System.out.println(e1); <span class="comment">// 自动调用toString()</span></span><br><span class="line">System.out.println(e1.ordinal());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(EnumDemo e: EnumDemo.values()) &#123;</span><br><span class="line">    System.out.println(<span class="string">"EnumDemo: "</span> + e + <span class="string">" ordinal "</span> + e.ordinal());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// HELLO</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// EnumDemo: HELLO ordinal 0</span></span><br><span class="line"><span class="comment">// EnumDemo: WORLD ordinal 1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 《Java编程思想》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 阅读笔记 </tag>
            
            <tag> 《Java编程思想》 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《 Java 编程思想》CH04 控制执行流程</title>
      <link href="/2020/02/09/%E3%80%8A-Java-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8BCH04-%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
      <url>/2020/02/09/%E3%80%8A-Java-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8BCH04-%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java 中控制流程基本与 C/C++ 类似，所以大部分相同的部分会选择跳过。</p></blockquote><h2 id="true-和-false"><a href="#true-和-false" class="headerlink" title="true 和 false"></a>true 和 false</h2><p><strong>Java 不允许使用一个数字作为布尔值使用</strong></p><h2 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h2><p>与 C/C++ 一样：</p><ul><li>if</li><li>else </li><li>if else</li></ul><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>与 C/C++ 一样：</p><ul><li>while</li><li>do-while</li><li>for</li></ul><p>使用逗号操作符可以在 for 语句中定义多个变量（必须是同样类型）和执行多个语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span> + <span class="number">1</span>; i &lt; <span class="number">10</span>; i++, i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"i = "</span> + i + <span class="string">",j = "</span> + j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Foreach-语法"><a href="#Foreach-语法" class="headerlink" title="Foreach 语法"></a>Foreach 语法</h2><p>使用<code>foreach</code>语法可以方便的遍历数组或容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f 为一个float的数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">float</span> x: f) &#123;</span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><p><code>return</code>的两种用途：</p><ul><li>指定方法的返回值</li><li>从方法的任何位置退出</li></ul><p>返回值类型为 void 的方法可以没有 return，此时该方法的结尾处会有一个隐式的 return</p><h2 id="break-amp-continue-amp-goto"><a href="#break-amp-continue-amp-goto" class="headerlink" title="break &amp; continue  &amp; goto"></a>break &amp; continue  &amp; goto</h2><p>Java 中 break 和 continue 与 C/C++ 类似，但是 Java 中没有 goto，但可以用 break 和 continue 实现跳转。</p><p>标签：</p><ul><li>标识符 + <code>，如</code>label1:`</li><li>应该放在迭代语句之前，中间不能有任何语句</li></ul><p>continue &amp; break 与标签一起使用：</p><ul><li>一般的 continue 会退回到最内层循环的开头继续执行</li><li>带标签的 continue 会退回到标签的位置，并重新进行标签后面那个循环</li><li>一般 break 会跳出当前循环</li><li>带标签的 break 会跳出标签所指定的循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">outer:</span><br><span class="line"><span class="keyword">for</span>(;<span class="keyword">true</span>;) &#123; <span class="comment">// for1</span></span><br><span class="line">inner:</span><br><span class="line"><span class="keyword">for</span>(;<span class="keyword">true</span>;) &#123; <span class="comment">// for2</span></span><br><span class="line"><span class="keyword">continue</span>; <span class="comment">//继续执行 for2 循环</span></span><br><span class="line"><span class="keyword">continue</span> inner; <span class="comment">// 继续执行 for2 循环</span></span><br><span class="line"><span class="keyword">continue</span> outer; <span class="comment">// 继续执行 for1 循环</span></span><br><span class="line"><span class="keyword">break</span>; <span class="comment">// 跳出 for2</span></span><br><span class="line"><span class="keyword">break</span> inner; <span class="comment">// 跳出 for2</span></span><br><span class="line"><span class="keyword">break</span> outer; <span class="comment">// 跳出 for1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>与 C++ 类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(integral-selector) &#123;</span><br><span class="line"><span class="keyword">case</span> integral-value1: statement; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> integral-value2: statement; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> integral-value3: statement; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>: statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 《Java编程思想》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 阅读笔记 </tag>
            
            <tag> 《Java编程思想》 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《 Java 编程思想》CH03 操作符</title>
      <link href="/2020/02/08/%E3%80%8A-Java-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8BCH03-%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
      <url>/2020/02/08/%E3%80%8A-Java-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8BCH03-%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>在最底层，Java中的数据是通过操作符来操作的。</strong></p></blockquote><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><ul><li><code>+</code>,<code>-</code>,<code>*</code>,<code>*</code>，<code>=</code>与其他语言类似</li><li>几乎所有的操作符只能操作“基本类似”，而<code>=</code>，<code>==</code>，<code>!=</code>是例外</li><li>String 类支持<code>+</code>和<code>+=</code>操作符，表示拼接操作，在进行拼接的操作会尝试将非 String 的元素转换为 String（调用tostring())</li><li>赋值操作符<code>=</code>的左边（左值）必须是一个明确的已命名的变量。</li></ul><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>在为对象“赋值”时，其实质是拷贝“引用”，需要注意“别名现象”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch03;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tank</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Assignment</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Tank tank1 = <span class="keyword">new</span> Tank();</span><br><span class="line">        Tank tank2 = <span class="keyword">new</span> Tank();</span><br><span class="line">        tank1.level = <span class="number">12</span>;</span><br><span class="line">        tank2.level = <span class="number">13</span>;</span><br><span class="line">        System.out.println(<span class="string">"tank1 = "</span> + tank1.level);</span><br><span class="line">        System.out.println(<span class="string">"tank2 = "</span> + tank2.level);</span><br><span class="line"></span><br><span class="line">        tank1 = tank2;</span><br><span class="line">        tank1.level++;</span><br><span class="line">        System.out.println(<span class="string">"tank1 = "</span> + tank1.level);</span><br><span class="line">        System.out.println(<span class="string">"tank2 = "</span> + tank2.level);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//tank1 = 12</span></span><br><span class="line"><span class="comment">//tank2 = 13</span></span><br><span class="line"><span class="comment">//tank1 = 14</span></span><br><span class="line"><span class="comment">//tank2 = 14</span></span><br></pre></td></tr></table></figure><h3 id="方法调用中的别名问题"><a href="#方法调用中的别名问题" class="headerlink" title="方法调用中的别名问题"></a>方法调用中的别名问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.ch03;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Letter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PassObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Letter y)</span> </span>&#123;</span><br><span class="line">        y.c = <span class="string">'z'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Letter x = <span class="keyword">new</span> Letter();</span><br><span class="line">        x.c = <span class="string">'a'</span>;</span><br><span class="line">        System.out.println(<span class="string">"x.c = "</span> + x.c); <span class="comment">// a</span></span><br><span class="line">        f(x);</span><br><span class="line">        System.out.println(<span class="string">"x.c = "</span> + x.c); <span class="comment">// z</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不管是那种别名问题，关键是要理解到<strong>拷贝的是引用，不是对象。</strong></p><h2 id="算数操作符-amp-自增与自减-amp-按位操作符"><a href="#算数操作符-amp-自增与自减-amp-按位操作符" class="headerlink" title="算数操作符 &amp; 自增与自减 &amp; 按位操作符"></a>算数操作符 &amp; 自增与自减 &amp; 按位操作符</h2><ul><li>整数除法不会四舍五入，而是直接舍去小数位</li><li>其余与C++中的一样</li></ul><h2 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h2><p>关系操作符与 C++ 也是类似，有一点比较特殊的是在 Java 中<code>==</code>和<code>!=</code>可以用在对象上，其比较的是<strong>引用</strong>，而不是对象内的值，如果要比较两个对象是否相等（语义上），通常调用<code>equals</code>函数来比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer n1 = <span class="keyword">new</span> Integer(<span class="number">47</span>);</span><br><span class="line">Integer n2 = <span class="keyword">new</span> Integer(<span class="number">47</span>);</span><br><span class="line">n1 == n2; <span class="comment">// false</span></span><br><span class="line">n1.equals(n2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong><code>equals</code>默认是比较引用，所以在自己实现的类中需要覆盖<code>equals</code>方法才能进行语义上的比较</strong></p><h2 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h2><p><code>&amp;&amp;</code>,<code>||</code>和<code>!</code>操作只能用于布尔值，<strong>与C++不同，对一个非布尔值进行逻辑运算不会对该值强制转换，会报编译错误</strong></p><p>Java中的逻辑操作符也有“短路”现象</p><h2 id="直接常量"><a href="#直接常量" class="headerlink" title="直接常量"></a>直接常量</h2><ul><li>十六进制<code>0x/0X</code>前缀+<code>0-9</code>和<code>a-f</code></li><li>八进制<code>0</code>前缀+<code>0-8</code></li><li>后缀<code>l/L</code>表示<code>long</code>类型</li><li>后缀<code>f/F</code>表示<code>float</code>类型</li><li>后缀<code>d/D</code>表示<code>double</code>类型</li><li>指数记数法：<code>1.39E-43</code>表示$1.39 \times e^{-43}$</li></ul><h2 id="移位操作符"><a href="#移位操作符" class="headerlink" title="移位操作符"></a>移位操作符</h2><ul><li>移位操作符只能用于处理整数类型</li><li><code>&gt;&gt;</code>符号扩展，<code>&gt;&gt;&gt;</code>0扩展</li><li>对 char、byte、short 类型进行移位运算，在进行移位之前会先转回为 int</li></ul><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><blockquote><p>boolean-exp ? value0 : value1</p></blockquote><h2 id="字符串操作符-和"><a href="#字符串操作符-和" class="headerlink" title="字符串操作符 + 和+="></a>字符串操作符 <code>+</code> 和<code>+=</code></h2><ul><li>字符串中操作符 <code>+</code> 和<code>+=</code>表示“拼接”操作</li><li><strong>如果一个表达式以字符串开头，那么其后续操作数都必须是字符串类型（不是则进行强制转换）</strong></li></ul><h2 id="类型转换操作符"><a href="#类型转换操作符" class="headerlink" title="类型转换操作符"></a>类型转换操作符</h2><p><strong>类型转换（<code>cast</code>)</strong>是指，在适当的时候，Java 会将一种数据类型自动转换为另一种。</p><p>显式的类型转换如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">long</span> l = (<span class="keyword">long</span>)i;</span><br><span class="line"><span class="keyword">int</span> j = (<span class="keyword">int</span>)l;</span><br></pre></td></tr></table></figure><h3 id="类型转换："><a href="#类型转换：" class="headerlink" title="类型转换："></a>类型转换：</h3><ul><li>窄式转换，需要显式指定（如 long 转 int）</li><li>扩展转换，无需显式指定（如 int 转 long）</li><li><strong>Java允许任何基本类型之间的类型转换，除了布尔值。</strong></li><li>“类”数据类型不允许类型转换</li></ul><h3 id="截尾和舍入"><a href="#截尾和舍入" class="headerlink" title="截尾和舍入"></a>截尾和舍入</h3><ul><li>当 float 或 double 转向整型时，总是对数字进行截尾</li><li>如果需要舍入，可以调用<code>java.lang.Math.round()</code></li></ul><h3 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h3><p><strong>一个表达式中出现的最大的数据类型决定了该表达式最终结果的数据类型</strong>，如 int 类型与 long 类型相加，得到一个 long 类型。</p><h2 id="Java-没有-sizeof"><a href="#Java-没有-sizeof" class="headerlink" title="Java 没有 sizeof"></a>Java 没有 sizeof</h2><p>由于Java中所有基本数据类型的大小都是明确的，所以不需要sizeof。BTW，boolean 不是没有明确嘛。</p>]]></content>
      
      
      <categories>
          
          <category> 《Java编程思想》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 阅读笔记 </tag>
            
            <tag> 《Java编程思想》 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《 Java 编程思想》CH02 一切都是对象</title>
      <link href="/2020/02/08/%E3%80%8A-Java-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8BCH02-%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/02/08/%E3%80%8A-Java-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8BCH02-%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="用引用操纵对象"><a href="#用引用操纵对象" class="headerlink" title="用引用操纵对象"></a>用引用操纵对象</h2><p>尽管Java中一切都看作为对象，但是操纵的标识符实际上对象的一个“引用”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s; <span class="comment">// 这里只是创建了一个引用，而不是一个对象</span></span><br><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"abcd"</span>); <span class="comment">// 使用`new`操作符来创建一个对象，并将其与一个引用相关联</span></span><br><span class="line">String s = <span class="string">"abcd"</span>; <span class="comment">// 字符串可以直接用带引号的文本初始化</span></span><br></pre></td></tr></table></figure><h2 id="必须由你创建所有对象"><a href="#必须由你创建所有对象" class="headerlink" title="必须由你创建所有对象"></a>必须由你创建所有对象</h2><p>使用<code>new</code>操作符创建一个对象</p><h3 id="存储到什么位置"><a href="#存储到什么位置" class="headerlink" title="存储到什么位置"></a>存储到什么位置</h3><p>由五个地方可以存储数据：</p><ol><li>寄存器：由于寄存器数量有限，所有无法直接控制</li><li>堆栈（栈）：RAM中，存储在栈中的数据必须明确知道其生命周期，通常局部存放对象引用和局部基本类型的变量。</li><li>堆：存放所有的对象</li><li>常量存储：通常直接存放在代码内部，其永远不会改变</li><li>非RAM存储：数据存放在程序之外，不受程序的控制，如流对象（System.out）和持久化对象（存放在磁盘的文件）。</li></ol><h3 id="特例：基本类型"><a href="#特例：基本类型" class="headerlink" title="特例：基本类型"></a>特例：基本类型</h3><p>一些比较小的，简单的类型，如果放在堆中往往效率不高，所以这些类型不需要使用<code>new</code>来创建，而是创建一个“自动”变量来直接存储“值”，并置于栈中。</p><p><strong>Java 中所有基本类型所占据存储空间的大小都是明确的</strong>.</p><p><img src="http://imagehosting.wuxiaobai24.fun//blog/Java%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F.png" alt="Java基本类型大小"></p><ul><li>所有数值类型都有正负号</li><li><code>boolean</code>类型所占存储空间的大小没有明确，仅定义为能够去字面值<code>true</code>或<code>false</code></li><li>基本类型和其对应的包装类之间可以自动装包、自动解包</li><li>Java 提供了两个用于高精度计算的类：<code>BigInteger</code>和<code>BigDecimal</code></li></ul><h3 id="Java-中的数组"><a href="#Java-中的数组" class="headerlink" title="Java 中的数组"></a>Java 中的数组</h3><ul><li>Java 确保数组会被初始化，且会进行范围检查</li><li>当创建一个数组对象时实际就是创建一个引用数组，并且每个引用都会被自动初始化为一个特定值<code>null</code></li><li>也可以创建用来存放基本数据类型的数组，此时的初始化则是置零</li></ul><h2 id="永远不需要销毁对象"><a href="#永远不需要销毁对象" class="headerlink" title="永远不需要销毁对象"></a>永远不需要销毁对象</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul><li>作用域决定了在其内定义的变量的可见性和生命周期</li><li>在作用域里定义的变量只可用于作用域结束前</li><li>Java 中不允许“覆盖”变量的可见性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">12</span>;</span><br><span class="line"><span class="comment">// x available</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> q = <span class="number">96</span>;</span><br><span class="line"><span class="comment">// Both x &amp; q available</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">96</span> <span class="comment">// Illegal</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// only x available</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象的作用域"><a href="#对象的作用域" class="headerlink" title="对象的作用域"></a>对象的作用域</h3><ul><li>Java 对象不具备和基本类型一样的生命周期，由<code>new</code>创建的对象，只要你需要，其会一直保留下去。</li><li>Java 使用垃圾回收器来监视<code>new</code>创建的对象，辨别并释放那些不会再被引用的对象</li></ul><h2 id="创建新的数据类型：类"><a href="#创建新的数据类型：类" class="headerlink" title="创建新的数据类型：类"></a>创建新的数据类型：类</h2><p>使用<code>class</code>来创建一个新的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ATypeName</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="字段和方法"><a href="#字段和方法" class="headerlink" title="字段和方法"></a>字段和方法</h2><p>一旦定义了一个类，就可以在类中设置两种元素：字段（数据成员）和方法（成员函数）。字段可以是任何类型的对象或基础类型。每个对象都有存储其字段的空间，即普通字段不在对象间共享。</p><p>引用一个对象的成员的方式：<code>objectReference.member</code></p><p>基本数据类型的变量只有是类的成员时，才确保其获得一个默认值，否则的话，与C++一样，该变量可能是任意值（其实就是在堆还是栈的问题嘛），不过这种情况下Java会报编译错误。</p><h2 id="方法、参数和返回值"><a href="#方法、参数和返回值" class="headerlink" title="方法、参数和返回值"></a>方法、参数和返回值</h2><p>方法的基本组成部分包括：名称、参数、返回值和方法体：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ReturnType <span class="title">methodName</span> <span class="params">( <span class="comment">/* Argument list */</span>)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* Method body */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法名和参数列表唯一地标识某个方法（合起来称为“方法签名”）<strong>注意：方法签名不包含返回值</strong>。</p><p>Java 中的方法只能作为类的一部分来创建，方法通常只有通过对象才能调用，且这个对象必须有这个方法。</p><h3 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h3><p>方法的参数列表指定要传递给方法什么样的信息，这里采用的都是<strong>对象的类型</strong>，即包含指定的类型和名字，这里传递的实际上是<strong>引用</strong>，传递基础类型则通过自动包装来实现。</p><h2 id="构建一个-Java-程序"><a href="#构建一个-Java-程序" class="headerlink" title="构建一个 Java 程序"></a>构建一个 Java 程序</h2><h3 id="名字可见性"><a href="#名字可见性" class="headerlink" title="名字可见性"></a>名字可见性</h3><p>为了防止不同类库中使用了相同的类名，Java 将反过来的域名作为唯一标识符（即包名），如我的域名为<code>codeand.fun</code>,则我的类库则使用<code>fun.codeand.utils</code>的形式。</p><p><strong>包名使用小写</strong></p><h3 id="运用其他构件"><a href="#运用其他构件" class="headerlink" title="运用其他构件"></a>运用其他构件</h3><p>使用<code>import</code>导入想要的包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.*; <span class="comment">// 导入java.util下所有的类</span></span><br></pre></td></tr></table></figure><p><code>java.lang</code>默认导入到每一个Java文件中。</p><h3 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h3><p>当声明一个事物为<code>static</code>时，就意味着这个域或方法不会与包含它的类的任何对象实例关联在一起，可以理解为<em>类数据</em>和<em>类方法</em>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">47</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123; i++; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j = StaticTest.i; <span class="comment">// 47</span></span><br><span class="line">StaticTest st1 = <span class="keyword">new</span> StaticTest();</span><br><span class="line">StaticTest.inc();</span><br><span class="line">StaticTest st2 = <span class="keyword">new</span> StaticTest();</span><br><span class="line"><span class="comment">// st1.i == st2.i == 48 // 所有i都指向同一个存储空间</span></span><br></pre></td></tr></table></figure><h2 id="你的第一个-Java-程序"><a href="#你的第一个-Java-程序" class="headerlink" title="你的第一个 Java 程序"></a>你的第一个 Java 程序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloDate.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloDate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, it's"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要创建一个独立运行的程序，那么该文件中必须存在某个类与该文件同名，且那个类必须又一个<code>main</code>方法，其形式如<code>public static void main(String[] args)</code>。</p><h2 id="编译和运行"><a href="#编译和运行" class="headerlink" title="编译和运行"></a>编译和运行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ javac HelloDate.java // 编译，产生一个 HelloDate.class 文件</span><br><span class="line">$ java HelloDate // 运行</span><br></pre></td></tr></table></figure><h2 id="注释和嵌入式文档"><a href="#注释和嵌入式文档" class="headerlink" title="注释和嵌入式文档"></a>注释和嵌入式文档</h2><ul><li>多行注释：<code>/* something */</code></li><li>单行注释：<code>// something</code></li></ul><h3 id="注释文档"><a href="#注释文档" class="headerlink" title="注释文档"></a>注释文档</h3><p>Java 中可以将代码与文档放到一个文件中，这样有利于文档的维护，为了实现这一目的，这里使用一种特殊的注释语法来标记文档，此外还有一个工具<code>javadoc</code>来提取注释。javadoc的输出是一个html</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wuxiaobai24 @ wuxiaobai24-pc in ~/code/Java/ch2 [17:56:05] C:1</span></span><br><span class="line">$ javadoc HelloDate.java </span><br><span class="line">正在加载源文件HelloDate.java...</span><br><span class="line">正在构造 Javadoc 信息...</span><br><span class="line">标准 Doclet 版本 1.8.0_242</span><br><span class="line">正在构建所有程序包和类的树...</span><br><span class="line">正在生成./HelloDate.html...</span><br><span class="line">正在生成./package-frame.html...</span><br><span class="line">正在生成./package-summary.html...</span><br><span class="line">正在生成./package-tree.html...</span><br><span class="line">正在生成./constant-values.html...</span><br><span class="line">正在构建所有程序包和类的索引...</span><br><span class="line">正在生成./overview-tree.html...</span><br><span class="line">正在生成./index-all.html...</span><br><span class="line">正在生成./deprecated-list.html...</span><br><span class="line">正在构建所有类的索引...</span><br><span class="line">正在生成./allclasses-frame.html...</span><br><span class="line">正在生成./allclasses-noframe.html...</span><br><span class="line">正在生成./index.html...</span><br><span class="line">正在生成./<span class="built_in">help</span>-doc.html...</span><br><span class="line"></span><br><span class="line"><span class="comment"># wuxiaobai24 @ wuxiaobai24-pc in ~/code/Java/ch2 [17:56:11] </span></span><br><span class="line">$ ls</span><br><span class="line">allclasses-frame.html    HelloDate.class  index-all.html      package-list          stylesheet.css</span><br><span class="line">allclasses-noframe.html  HelloDate.html   index.html          package-summary.html</span><br><span class="line">constant-values.html     HelloDate.java   overview-tree.html  package-tree.html</span><br><span class="line">deprecated-list.html     <span class="built_in">help</span>-doc.html    package-frame.html  script.js</span><br></pre></td></tr></table></figure><p><img src="http://imagehosting.wuxiaobai24.fun//blog/Index%E6%98%BE%E7%A4%BA.png" alt="打开index.html"></p><h3 id="注释语法"><a href="#注释语法" class="headerlink" title="注释语法"></a>注释语法</h3><p>所有 javadoc 命令都只能在由<code>/**</code>和<code>*/</code>组成的注释中</p><p>javadoc 的注释，只能为<code>public</code>和<code>protected</code>成员进行文档注释，而<code>private</code>和<code>defaule</code>成员的注释会被忽视掉</p><p>javadoc 主要有两种形式：</p><ul><li>嵌入HTML</li><li><strong>文档标签</strong>：<ul><li><strong>独立文档标签</strong>是一些以<code>@</code>字符开头的命令，且置于注释行的最前面（除了前导的 <code>*</code>）</li><li><strong>行内文档标签</strong>则可以在 javadoc 注释中的任何位置，同样以<code>@</code>开头，但要在花括号内。</li></ul></li></ul><p>常用的标签有：</p><ul><li><code>@see</code>：引用其他类，会生成一个超链接条目（不会校验该链接是否有效），超链接文本为“See Also”  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@see</span> classname</span><br><span class="line"><span class="meta">@see</span> fully-qualified-classname</span><br><span class="line"><span class="meta">@see</span> fully-qualified-classname<span class="meta">@method</span>-name</span><br></pre></td></tr></table></figure></li><li><code>{@link package.class#member label}</code>：与<code>@see</code>类似，不过是行内标签，使用“label”来处理作为超链接文本</li><li><code>{@docRoot}</code>：该标签产生到文档根目录的相对路径</li><li><code>{@inheritDoc}</code>：该标签从当前这个类最直接的基类继承相关文档到当前文档注释中</li><li><code>@version</code>:版本信息</li><li><code>@author</code>:作者信息</li><li><code>@since</code>:指定JDK版本最低为多少</li><li><code>@param</code>:表示参数含义，形式如<code>@param parameter-name description</code></li><li><code>@return</code>:描述返回值，形式如<code>@return description</code></li><li><code>@throws</code>:异常描述，该方法可能抛出的每个异常都需要说明，形式如<code>@throws fully-qualified-class-name description</code></li><li><code>@deprecated</code>:指出一些旧特性已由改进的新特性所取代，不建议使用。调用一个标记为<code>@deprecated</code>的方法，编译器会发出警告。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloDate.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** A class comment</span></span><br><span class="line"><span class="comment"> * Test comment</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wuxiaobai24</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 0.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloDate</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** a field comment */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * a &lt;strong&gt;protected&lt;/strong&gt; filed comment</span></span><br><span class="line"><span class="comment">     * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">     *  &lt;li&gt;one&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *  &lt;li&gt;two&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *  &lt;li&gt;three&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> p;</span><br><span class="line">    <span class="comment">/** a private field comment */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** A method comment</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args args comment</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, it's"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://imagehosting.wuxiaobai24.fun//blog%E3%80%8A-Java-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8BCH02-%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1-20200208150609-2020-2-8-15-6-9" alt="javadoc输出1"><br><img src="http://imagehosting.wuxiaobai24.fun//blog%E3%80%8A-Java-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8BCH02-%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1-javadoc%E8%BE%93%E5%87%BA-2020-2-8-15-7-31" alt="《-Java-编程思想》CH02-一切都是对象-javadoc输出-2020-2-8-15-7-31"><br><img src="http://imagehosting.wuxiaobai24.fun//blog%E3%80%8A-Java-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8BCH02-%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1-javadoc%E8%BE%93%E5%87%BA2-2020-2-8-15-7-59" alt="《-Java-编程思想》CH02-一切都是对象-javadoc输出2-2020-2-8-15-7-59"></p><h2 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h2><ul><li>驼峰式写法</li><li>标识符的第一个字符采用小写，其余用大写</li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ex1.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ex1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ex1 e = <span class="keyword">new</span> Ex1();</span><br><span class="line">        System.out.println(e.i);</span><br><span class="line">        System.out.println(e.c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习2"><a href="#练习2" class="headerlink" title="练习2"></a>练习2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ex2.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ex2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习3-amp-练习4-amp-练习5"><a href="#练习3-amp-练习4-amp-练习5" class="headerlink" title="练习3 &amp; 练习4 &amp; 练习5"></a>练习3 &amp; 练习4 &amp; 练习5</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ex3.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataOnly</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">    <span class="keyword">boolean</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ATypeName</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ex3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ATypeName a = <span class="keyword">new</span> ATypeName();</span><br><span class="line">        DataOnly d = <span class="keyword">new</span> DataOnly();</span><br><span class="line">        d.i = <span class="number">1</span>;</span><br><span class="line">        d.d = <span class="number">2.0</span>;</span><br><span class="line">        d.b = <span class="keyword">false</span>;</span><br><span class="line">        System.out.println(d.i);</span><br><span class="line">        System.out.println(d.d);</span><br><span class="line">        System.out.println(d.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习6"><a href="#练习6" class="headerlink" title="练习6"></a>练习6</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ex4.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ex4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">storage</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.length() * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">"Hello"</span>);</span><br><span class="line">        Ex4 e = <span class="keyword">new</span> Ex4();</span><br><span class="line">        <span class="keyword">int</span> len = e.storage(s);</span><br><span class="line">        System.out.println(len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习7-amp-练习8"><a href="#练习7-amp-练习8" class="headerlink" title="练习7 &amp; 练习8"></a>练习7 &amp; 练习8</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ex7.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">47</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123; StaticTest.i++; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ex7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticTest st1 = <span class="keyword">new</span> StaticTest();</span><br><span class="line">        Incrementable.increment();</span><br><span class="line">        StaticTest st2 = <span class="keyword">new</span> StaticTest();</span><br><span class="line">        System.out.println(st1.i);</span><br><span class="line">        System.out.println(st2.i);</span><br><span class="line">        System.out.println(StaticTest.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习9"><a href="#练习9" class="headerlink" title="练习9"></a>练习9</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ex9.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ex9</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">24</span>;</span><br><span class="line">        Integer bi = i;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(bi);</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习10"><a href="#练习10" class="headerlink" title="练习10"></a>练习10</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ex10.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ex10</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">3</span>) &#123;</span><br><span class="line">            System.out.println(args[<span class="number">0</span>]);</span><br><span class="line">            System.out.println(args[<span class="number">1</span>]);</span><br><span class="line">            System.out.println(args[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习11"><a href="#练习11" class="headerlink" title="练习11"></a>练习11</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ex11.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AllTheColorsOfTheRainbow</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> anIntegerRepresentingColors;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeTheHueOfTheColor</span><span class="params">(<span class="keyword">int</span> newHue)</span> </span>&#123;</span><br><span class="line">        anIntegerRepresentingColors = newHue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ex11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AllTheColorsOfTheRainbow allTheColorsOfTheRainbow = <span class="keyword">new</span> AllTheColorsOfTheRainbow();</span><br><span class="line">        allTheColorsOfTheRainbow.changeTheHueOfTheColor(<span class="number">1</span>);</span><br><span class="line">        System.out.println(allTheColorsOfTheRainbow.anIntegerRepresentingColors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 《Java编程思想》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 阅读笔记 </tag>
            
            <tag> 《Java编程思想》 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《 Java 编程思想》CH01 对象的概念</title>
      <link href="/2020/02/06/%E3%80%8A-Java-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8BCH01-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
      <url>/2020/02/06/%E3%80%8A-Java-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8BCH01-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="《-Java-编程思想》CH01-对象的概念"><a href="#《-Java-编程思想》CH01-对象的概念" class="headerlink" title="《 Java 编程思想》CH01 对象的概念"></a>《 Java 编程思想》CH01 对象的概念</h1><p>@(后端开发)[Java, 阅读笔记]</p><p>[TOC]</p><h2 id="抽象过程"><a href="#抽象过程" class="headerlink" title="抽象过程"></a>抽象过程</h2><p>所有编程语言都提供抽象机制，人们所能解决的问题的复杂性直接取决于抽象的类型和质量。</p><p>OOP 允许根据问题来描述问题，而不是根据运行解决方案的计算机来描述问题。</p><h3 id="纯粹的面向对象程序设计方法："><a href="#纯粹的面向对象程序设计方法：" class="headerlink" title="纯粹的面向对象程序设计方法："></a>纯粹的面向对象程序设计方法：</h3><ul><li>万物皆对象</li><li>程序是对象的集合</li><li>每个对象都有自己的由其他对象所构成的存储</li><li>每个对象都拥有类型</li><li>某一个特定类型的所有对象都可以接收同样的信息</li></ul><p><strong>对象具有状态、行为和标识</strong></p><h2 id="每个对象都有一个接口"><a href="#每个对象都有一个接口" class="headerlink" title="每个对象都有一个接口"></a>每个对象都有一个接口</h2><p>所有的对象都是唯一的，但同时也是具有相同特性和行为的对象所归属的类的一部分。</p><p>类描述了具有相同特性（数据元素）和行为（功能）的对象集合，所以<strong>一个类实际上就是一个数据类型</strong>。</p><p>面向对象程序设计的挑战之一，就是在问题空间的元素和解空间的对象之间创建一对一的映射。</p><p>每个对象都只能满足某些请求，这些请求由对象的接口（interface）所定义，决定接口的便是类型。</p><p>接口确定了某一个特定对象所能发出的请求，但是，在程序中必须有满足这些请求的代码，这些代码与隐藏的数据一起构成了<em>实现</em>（implement）</p><h2 id="每个对象都提供服务"><a href="#每个对象都提供服务" class="headerlink" title="每个对象都提供服务"></a>每个对象都提供服务</h2><p>当正在试图开发或理解一个程序设计，最好的方法之一就是将对象想象成“服务提供者”</p><p><strong>高内聚</strong>是软件设计的基本质量要求之一：这意味着一个软件构件的各个方面“组合的好”</p><h2 id="被隐藏的具体实现"><a href="#被隐藏的具体实现" class="headerlink" title="被隐藏的具体实现"></a>被隐藏的具体实现</h2><p>将程序开发人员按照角色分为<em>类创建者</em>和<em>客户端程序员</em>：</p><ul><li>客户端程序员的目标是收集各种用来实现快速应用开发的类。</li><li>类创建者的目标是构建类，这种类只向客户端程序员暴露必需的部分，而隐藏其他部分。</li></ul><p>将实现隐藏起来可以减少程序的 bug，即<strong>访问控制</strong>，访问控制存在的原因：</p><ol><li>让客户端程序员无法触及他们不应该触及的部分。</li><li>允许库设计者可以改变类内部的工作方式而不担心会影响到客户端程序员。</li></ol><p>Java 中的四种访问权限：</p><ul><li><code>public</code>：任何人都是可用的</li><li><code>private</code>：除了类型创建者和类型的内部方法之外任何人都不能访问</li><li><code>protected</code>：与 <code>private</code> 类似，差别在与继承于该类的派生类可以访问<code>protected</code> 成员</li><li><code>default</code>：包访问权限，同一个包中其他类可以访问。</li></ul><h2 id="复用具体实现"><a href="#复用具体实现" class="headerlink" title="复用具体实现"></a>复用具体实现</h2><p><strong>代码复用是面向对象程序设计语言所提供的最了不起的优点之一</strong></p><p><strong>组合</strong>（“has-a”关系）：新的类可以由任意数量、类型的其他对象以任意可以实现新的类中想要的功能的方式组成。如果组合是动态发生的，那么它通常被称为“聚合”</p><p>*在建立新类时，应该首先考虑组合，而不是继承，因为它更加简单灵活。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>两个类型可以有相同的特性和行为，但是其中一个类型可能比另一个含有更多的特性。继承使用基类型和派生类型的概念表示了这种类型之间的相似性。</p><p>一个基类型包含所有派生类所共享的特性和行为，可以创建一个基类型来表示系统中某些对象的核心概念，从基类型中派生出其他类型，来表示该核心可以被不同的方式实现。</p><p>通过继承而产生的类型等价性是理解面向对象程序设计方法内涵的重要门槛。</p><p>基类与派生类的相似性：所有可以发送给基类对象的消息同时也可以发送给派生类对象。<br>产生基类与派生类的差异性的两种形式：</p><ol><li>在派生类添加新方法</li><li>在派生类中改变现有基类的方法，即覆盖</li></ol><h3 id="“是一个”与“像是一个”"><a href="#“是一个”与“像是一个”" class="headerlink" title="“是一个”与“像是一个”"></a>“是一个”与“像是一个”</h3><ul><li>“是一个”（is-a）：只是覆盖，没有添加新的方法。</li><li>“像是一个”（is-like-a）：添加了新的方法。</li></ul><h3 id="伴随多态的可互换对象"><a href="#伴随多态的可互换对象" class="headerlink" title="伴随多态的可互换对象"></a>伴随多态的可互换对象</h3><p>在处理类型的层次结构时，把一个对象不当做它所属的特性类型来对待，而是将其当做其基类的对象来对待，这一可以编写出不依赖于特定类型的代码。</p><p>为了实现泛型，面向对象程序设计语言使用了<em>后期绑定</em>的概念，当向对象发送消息时，被调用的代码直到运行时才能确定。编译器确保被调用方法的存在，并对调用参数和返回值执行类型检查，但是并不知道将被执行的确切代码。</p><p>Java 使用了一小段特殊的代码来代替绝对地址调用。</p><p>在某些语言中（如C++），必须明确声明希望某个方法具备后期绑定，而 Java 中，动态绑定是默认行为，不需要额外添加关键字来实现多态。</p><h2 id="单根继承结构"><a href="#单根继承结构" class="headerlink" title="单根继承结构"></a>单根继承结构</h2><blockquote><p>所有的类都最终继承自单一的基类，Java 中 这个类为 <code>Object</code>。</p></blockquote><p>在单根继承结构中的所有对象都具有一个公用接口，所以它们归根到底都是相同的基本类型。</p><p>单根继承结构使得垃圾回收的实现变得容易得多。</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><ul><li>不同容器提供了不同类型的接口和外部行为</li><li>不同容器对于某些操作具有不同的效率</li></ul><h3 id="参数化类型"><a href="#参数化类型" class="headerlink" title="参数化类型"></a>参数化类型</h3><p>容器是通过<strong>向下转型</strong>实现的，容器知道元素转型前的类型，则可以实现容器，这种解决方法即<strong>参数化类型</strong>，即<strong>泛型</strong>。</p><h2 id="对象的创建和生命期"><a href="#对象的创建和生命期" class="headerlink" title="对象的创建和生命期"></a>对象的创建和生命期</h2><ul><li>Java 完全采用动态内存分配方式，每当想要创建新对象时，就要使用 <code>new</code> 关键字来构建此对象的动态实例。</li><li>Java 提供了“垃圾回收”机制，它可以自动发现对象何时不再被使用，进而销毁它。</li></ul><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>大多数错误机制的主要问题在于，它们都依赖于程序员自身的警惕性，这种警惕性来源于一种共同的约定，而不是编程语言所强制的。这种机制容易被忽视。</p><p>被抛出的异常不像方法返回的错误值和方法设置的用来表示错误条件的标志位那样可以被忽略。<strong>异常不能被忽视，所以它保证一定会在某处得到处理</strong>。</p><p>异常处理不是面向对象的特性。</p>]]></content>
      
      
      <categories>
          
          <category> 《Java编程思想》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 阅读笔记 </tag>
            
            <tag> 《Java编程思想》 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Delete Leaves With a Given Value Medium</title>
      <link href="/2020/02/02/Delete-Leaves-With-a-Given-ValueMedium/"/>
      <url>/2020/02/02/Delete-Leaves-With-a-Given-ValueMedium/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第63天。</p></blockquote><p>水题。</p><p>今天的题目是<a href="https://leetcode.com/problems/delete-leaves-with-a-given-value/" target="_blank" rel="noopener">Delete Leaves With a Given Value Medium</a>:</p><p>太水了，不解释了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">removeLeafNodes</span><span class="params">(TreeNode* root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">root-&gt;left = removeLeafNodes(root-&gt;left, target);</span><br><span class="line">root-&gt;right = removeLeafNodes(root-&gt;right, target);</span><br><span class="line"><span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; target == root-&gt;val)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deepest Leaves Sum</title>
      <link href="/2020/01/31/Deepest-Leaves-Sum/"/>
      <url>/2020/01/31/Deepest-Leaves-Sum/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第62天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/deepest-leaves-sum/" target="_blank" rel="noopener">Deepest Leaves Sum</a>:</p><p>比较简单的题目，只要用层次遍历即可，计算每一层的和，然后把最后一层返回即可。也可以用后序遍历来完成，不过要维护每个子树的高度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deepestLeavesSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">q.push(root);</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, <span class="built_in">size</span> = q.<span class="built_in">size</span>(); i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">root = q.front(); q.pop();</span><br><span class="line">sum += root-&gt;val;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;left) q.push(root-&gt;left);</span><br><span class="line"><span class="keyword">if</span> (root-&gt;right) q.push(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jump Game III</title>
      <link href="/2020/01/28/Jump-Game-III/"/>
      <url>/2020/01/28/Jump-Game-III/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第61天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/jump-game-iii/" target="_blank" rel="noopener">Jump Game III</a>:</p><p>用广度优先遍历出来即可，为了防止死循环，所以我们需要一个<code>visited</code>数组来记录某个位置的元素是否已经访问过来（即是否压入了队列中）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canReach</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(arr.<span class="built_in">size</span>(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">q.push(start);</span><br><span class="line">visited[start] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, <span class="built_in">size</span> = q.<span class="built_in">size</span>(); i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">start = q.front(); q.pop();</span><br><span class="line"><span class="keyword">if</span> (arr[start] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (start - arr[start] &gt;= <span class="number">0</span> &amp;&amp; visited[start - arr[start]] == <span class="literal">false</span>) &#123;</span><br><span class="line">q.push(start - arr[start]);</span><br><span class="line">visited[start - arr[start]] = <span class="literal">true</span>;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="keyword">if</span> (start + arr[start] &lt; arr.<span class="built_in">size</span>() &amp;&amp; visited[start + arr[start]] == <span class="literal">false</span>) &#123; </span><br><span class="line">q.push(start + arr[start]);</span><br><span class="line">visited[start + arr[start]] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Top K Frequent Elements</title>
      <link href="/2020/01/27/Top-K-Frequent-Elements/"/>
      <url>/2020/01/27/Top-K-Frequent-Elements/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第60天。hhh，一回家就没做了。在家无聊到开始找活干了。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">347. Top K Frequent Elements</a>:</p><p>挺简单的题目，先统计元素出现的次数，然后根据元素出现的次数来进行排序，然后取出现次数最多的前K个即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(k)</span></span>;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; imap;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, n = nums.<span class="built_in">size</span>(); i &lt; n; i++) &#123;</span><br><span class="line">imap[nums[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;pair&lt;int, int&gt;&gt; temp(imap.begin(), imap.end());</span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;p1, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;p2) &#123;</span><br><span class="line"><span class="keyword">return</span> p1.second &gt; p2.second;  </span><br><span class="line">&#125;;</span><br><span class="line">sort(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>(), f);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k; i++) &#123;</span><br><span class="line">res[i] = temp[i].first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Evaluate Division</title>
      <link href="/2020/01/13/Evaluate-Division/"/>
      <url>/2020/01/13/Evaluate-Division/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第59天，有好几天没做了，太咸鱼了我。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/evaluate-division/" target="_blank" rel="noopener">Evaluate Division</a>:</p><p>一道写起来比较麻烦，但是总体来看还是比较简单的。就是分为两步走即可：</p><ol><li>利用<code>equations</code>和<code>value</code>构造一个图</li><li>然后通过在图上遍历的方式计算得到<code>queries</code>的值。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">calcEquation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; equations, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; values, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">res</span><span class="params">(queries.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// calc elem set</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; smap;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;vec: equations) &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = smap.<span class="built_in">find</span>(vec[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (it == smap.<span class="built_in">end</span>()) smap[vec[<span class="number">0</span>]] = index++;</span><br><span class="line">        it = smap.<span class="built_in">find</span>(vec[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (it == smap.<span class="built_in">end</span>()) smap[vec[<span class="number">1</span>]] = index++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// for(auto p: smap) cout &lt;&lt; p.second &lt;&lt; endl;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// build graph</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; <span class="title">graph</span><span class="params">(index, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;(index, <span class="number">-1.0</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>, <span class="built_in">size</span> = equations.<span class="built_in">size</span>(); k &lt; <span class="built_in">size</span>; k++) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = smap[equations[k][<span class="number">0</span>]], j = smap[equations[k][<span class="number">1</span>]];</span><br><span class="line">        graph[i][j] = values[k];</span><br><span class="line">        graph[j][i] = <span class="number">1</span> / values[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>, <span class="built_in">size</span> = queries.<span class="built_in">size</span>(); k &lt; <span class="built_in">size</span>; k++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> it1 = smap.<span class="built_in">find</span>(queries[k][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">auto</span> it2 = smap.<span class="built_in">find</span>(queries[k][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (it1 == smap.<span class="built_in">end</span>() || it2 == smap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            res[k] = <span class="number">-1.0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (queries[k][<span class="number">0</span>] == queries[k][<span class="number">1</span>]) &#123;</span><br><span class="line">            res[k] = <span class="number">1.0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = it1-&gt;second, j = it2-&gt;second;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(index, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (dfs(graph, visited,i, j, res[k]) == <span class="literal">false</span>) &#123;</span><br><span class="line">            res[k] = <span class="number">-1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; &amp;graph, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;visited, <span class="keyword">int</span> s, <span class="keyword">int</span> e, <span class="keyword">double</span> &amp;res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == e) &#123; res = <span class="number">1.0</span>; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; graph.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">double</span> temp;</span><br><span class="line">        <span class="keyword">if</span> (visited[i] == <span class="literal">false</span> &amp;&amp; graph[s][i] &gt; <span class="number">0</span> &amp;&amp; dfs(graph, visited, i, e, temp)) &#123;</span><br><span class="line">            res = temp * graph[s][i];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Construct Binary Tree from Inorder and Postorder Traversal</title>
      <link href="/2020/01/07/Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/"/>
      <url>/2020/01/07/Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第58天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">Construct Binary Tree from Inorder and Postorder Traversal</a>:</p><p>一道很久之前嫌麻烦没做的题目，因为之前做过从中序遍历和先序遍历中重构二叉树了，所以从中序遍历和后序遍历重构二叉树就之前换一下取值的位置而已：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buildTree(inorder, postorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">0</span>, postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;inorder, <span class="keyword">int</span> beg, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(beg &lt;= <span class="built_in">end</span> &amp;&amp; inorder[beg] != val) beg++;</span><br><span class="line">    <span class="keyword">return</span> beg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder, <span class="keyword">int</span> ibeg, <span class="keyword">int</span> iend, <span class="keyword">int</span> pbeg, <span class="keyword">int</span> pend)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ibeg &gt; iend || pbeg &gt; pend) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (ibeg == iend || pbeg == pend) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(postorder[pend]);</span><br><span class="line">    <span class="keyword">int</span> val = postorder[pend];</span><br><span class="line">    <span class="keyword">int</span> mid = search(inorder, ibeg, iend, val);</span><br><span class="line">    TreeNode *node = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    <span class="keyword">int</span> leftsize = mid - ibeg;</span><br><span class="line">    node-&gt;left = buildTree(inorder, postorder, ibeg, mid<span class="number">-1</span>, pbeg, pbeg + leftsize<span class="number">-1</span>);</span><br><span class="line">    node-&gt;right = buildTree(inorder, postorder, mid + <span class="number">1</span>, iend, pbeg + leftsize, pend<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asteroid Collision</title>
      <link href="/2020/01/06/Asteroid-Collision/"/>
      <url>/2020/01/06/Asteroid-Collision/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第57天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/asteroid-collision/submissions/" target="_blank" rel="noopener">Asteroid Collision</a>:</p><p>用栈去模拟整个过程，因为<code>STL</code>中的栈没法直接顺序迭代出来，所以我们用<code>vector</code>模拟一个栈出来使用。</p><p>不难发现，最终的结果一定是小于 0 的值在前面，而大于 0 的值在后面，所以我们只用栈维护大于 0 的值。而小于 0 的值如果前面没有 大于 0 的值的话（即已经确定没有碰撞后），直接将其放入答案中。又因为我们是用<code>vector</code>进行的模拟，所以可以在维护栈顶指针的时候也维护一个栈底指针来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">asteroidCollision</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; asteroids)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = asteroids.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">st</span><span class="params">(<span class="built_in">size</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> top, beg;</span><br><span class="line">    <span class="keyword">for</span>(beg = <span class="number">0</span>;beg &lt; <span class="built_in">size</span> &amp;&amp; asteroids[beg] &lt; <span class="number">0</span>; beg++) st[beg] = asteroids[beg];</span><br><span class="line">    top = beg;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = beg; i &lt; <span class="built_in">size</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = asteroids[i];</span><br><span class="line">        <span class="keyword">if</span> (top == beg) &#123; </span><br><span class="line">            st[top++] = a;</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span>) beg++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; <span class="number">0</span>) st[top++] = a;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (st[top<span class="number">-1</span>] == -a) top--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (st[top<span class="number">-1</span>] &gt; -a) <span class="comment">/* do nothing */</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(top != beg &amp;&amp; st[top<span class="number">-1</span>] &lt; -a)</span><br><span class="line">                top--;</span><br><span class="line">            <span class="keyword">if</span> (top != beg &amp;&amp; st[top<span class="number">-1</span>] == -a) top--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (top == beg) &#123;</span><br><span class="line">                st[top] = a;</span><br><span class="line">                top = beg = beg + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(st.<span class="built_in">begin</span>(), st.<span class="built_in">begin</span>() + top);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flip Equivalent Binary Trees</title>
      <link href="/2020/01/05/Flip-Equivalent-Binary-Trees/"/>
      <url>/2020/01/05/Flip-Equivalent-Binary-Trees/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第56天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/flip-equivalent-binary-trees/" target="_blank" rel="noopener">Flip Equivalent Binary Trees</a>:</p><p>简单题，先序遍历判断当前节点的值是否相等，如果不相等则返回<code>false</code>，如果相等的话，判断两个子树是否<code>filpEquiv</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">flipEquiv</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root1 &amp;&amp; !root2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root1 &amp;&amp; root2 &amp;&amp; root1-&gt;val == root2-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> (flipEquiv(root1-&gt;left, root2-&gt;left) &amp;&amp; flipEquiv(root1-&gt;right, root2-&gt;right))</span><br><span class="line">                || (flipEquiv(root1-&gt;left, root2-&gt;right) &amp;&amp; flipEquiv(root1-&gt;right, root2-&gt;left));    </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maximum Difference Between Node and Ancestor</title>
      <link href="/2020/01/04/Maximum-Difference-Between-Node-and-Ancestor/"/>
      <url>/2020/01/04/Maximum-Difference-Between-Node-and-Ancestor/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第55天</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/" target="_blank" rel="noopener">Maximum Difference Between Node and Ancestor</a>:</p><p>我们做一次后序遍历，维护一个子树的最大值和最小值，用当前节点的值与最大最小值求距离，并返回距离的最大值即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxAncestorDiff</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> minVal, maxVal;</span><br><span class="line">    <span class="keyword">return</span> maxAncestorDiff(root, minVal, maxVal);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxAncestorDiff1</span><span class="params">(TreeNode *root, <span class="keyword">int</span> &amp;minVal, <span class="keyword">int</span> &amp;maxVal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    minVal = maxVal = root-&gt;val;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">-1</span>, leftMin, leftMax, rightMin, rightMax;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = maxAncestorDiff(root-&gt;left, leftMin, leftMax);</span><br><span class="line">        d = <span class="built_in">max</span>(r, <span class="built_in">max</span>(<span class="built_in">abs</span>(root-&gt;val - leftMin), <span class="built_in">abs</span>(root-&gt;val - leftMax)));</span><br><span class="line">        minVal = <span class="built_in">min</span>(minVal, leftMin);</span><br><span class="line">        maxVal = <span class="built_in">max</span>(maxVal, leftMax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = maxAncestorDiff(root-&gt;right, rightMin, rightMax);</span><br><span class="line">        d = <span class="built_in">max</span>(d,<span class="built_in">max</span>(r, <span class="built_in">max</span>(<span class="built_in">abs</span>(root-&gt;val - rightMax), <span class="built_in">abs</span>(root-&gt;val - rightMin))));</span><br><span class="line">        minVal = <span class="built_in">min</span>(minVal, rightMin);</span><br><span class="line">        maxVal = <span class="built_in">max</span>(maxVal, rightMax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做可能有点过于复杂了，我们可以把后序遍历转成先序遍历来，同样也需要维护最大值和最小值，不过因为是先序遍历，所以比较简单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxAncestorDiff</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> minVal, maxVal;</span><br><span class="line">    minVal = maxVal = root-&gt;val;</span><br><span class="line">    <span class="keyword">return</span> maxAncestorDiff(root, minVal, maxVal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxAncestorDiff</span><span class="params">(TreeNode *root, <span class="keyword">int</span> maxVal, <span class="keyword">int</span> minVal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> maxVal - minVal;</span><br><span class="line">    maxVal = <span class="built_in">max</span>(maxVal, root-&gt;val);</span><br><span class="line">    minVal = <span class="built_in">min</span>(minVal, root-&gt;val);</span><br><span class="line">    <span class="comment">// cout &lt;&lt; maxVal &lt;&lt; " " &lt;&lt; minVal &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(maxAncestorDiff(root-&gt;left, maxVal, minVal),</span><br><span class="line">                maxAncestorDiff(root-&gt;right, maxVal, minVal));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>All Elements in Two Binary Search Trees</title>
      <link href="/2020/01/03/All-Elements-in-Two-Binary-Search-Trees/"/>
      <url>/2020/01/03/All-Elements-in-Two-Binary-Search-Trees/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第54天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/all-elements-in-two-binary-search-trees/" target="_blank" rel="noopener">All Elements in Two Binary Search Trees</a>:</p><p>先用先序遍历拿到每棵树上的值，因为是二叉搜索树，所以先序得到的就是有序的值，所以做一次归并即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getAllElements</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right;</span><br><span class="line">    getAllElements(root1, left);</span><br><span class="line">    getAllElements(root2, right);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> len = left.<span class="built_in">size</span>() + right.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(len)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; left.<span class="built_in">size</span>() &amp;&amp; j &lt; right.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left[i] &lt; right[j]) vec[k++] = left[i++];</span><br><span class="line">        <span class="keyword">else</span> vec[k++] = right[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; left.<span class="built_in">size</span>()) vec[k++] = left[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt; right.<span class="built_in">size</span>()) vec[k++] = right[j++];</span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getAllElements</span><span class="params">(TreeNode *root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode *&gt; st;</span><br><span class="line">    <span class="keyword">while</span>(root || !st.empty()) &#123;</span><br><span class="line">        <span class="keyword">while</span>(root) &#123;</span><br><span class="line">            st.push(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!st.empty()) &#123;</span><br><span class="line">            root = st.top(); st.pop();</span><br><span class="line">            vec.push_back(root-&gt;val);</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Implement Rand10() Using Rand7()</title>
      <link href="/2020/01/02/Implement-Rand10-Using-Rand7/"/>
      <url>/2020/01/02/Implement-Rand10-Using-Rand7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第53天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/implement-rand10-using-rand7/" target="_blank" rel="noopener">Implement Rand10() Using Rand7()</a></p><p>如果我们是用<code>Rand10()</code>去实现<code>Rand7()</code>的话就简单，因为 10 比 7 大，所以：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">while</span>((r = rand10) &gt; <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是题目是用<code>Rand7()</code>去实现<code>Rand10</code>，所以我们需要转换一下。</p><p>由于<code>1/10 = 1/2 * 1/5</code>，所以我们可以用<code>rand5()</code>和<code>rand2()</code>来实现<code>rand10()</code>，而<code>rand5()</code>和<code>rand2()</code>又可以用<code>rand7()</code>来实现，所以：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rand5() + <span class="number">5</span> * (rand2() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">while</span>((r = rand7()) &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">while</span>((r = rand7()) &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其期望为<code>7/2 + 7/5</code>，所以调用<code>rand7()</code>的次数会比较大，我们可以用<code>rand7()</code>去实现<code>rand49()</code>，由于<code>49 = 7 * 7</code>，所以我们只需要调用两次<code>rand7()</code>即可实现出<code>rand49()</code><br>然后用<code>rand49()</code>去实现一个<code>rand40()</code>，而<code>rand40() % 10 + 1</code>即实现了<code>rand10()</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">while</span>((r = rand49()) &gt; <span class="number">40</span>);</span><br><span class="line">    <span class="keyword">return</span> r % <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand49</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (rand7()<span class="number">-1</span>)*<span class="number">7</span> + rand7();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Count Servers that Communicate</title>
      <link href="/2019/12/29/Count-Servers-that-Communicate/"/>
      <url>/2019/12/29/Count-Servers-that-Communicate/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第52天，有点浪的一天。survey一点没动的我。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/count-servers-that-communicate/" target="_blank" rel="noopener">Count Servers that Communicate</a>。</p><p>水题，只要遍历一次计算每一行和每一列之和，然后再遍历判断是否为1，且所在行或列不止一个节点即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countServers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>(); </span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j]) &#123;</span><br><span class="line">                a[i]++;</span><br><span class="line">                b[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] &amp;&amp; (a[i] &gt; <span class="number">1</span> || b[j] &gt; <span class="number">1</span>))</span><br><span class="line">                res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还看到一种做法，先遍历一遍，每一行都记录下值为1的grid的个数，如果个数大于一，则表示这些点都是能通信的点，如果等于一，则将该点位置记录下来。</p><p>然后将对所有记录下来的点判断一次是否其所在列的点的个数大于2。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countServers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>(); </span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j]) temp.push_back(j);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (temp.<span class="built_in">size</span>() &gt; <span class="number">1</span>) res += temp.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (temp.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            vec.push_back(temp[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;j: vec) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j]) count++;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                res += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Satisfiability of Equality Equations</title>
      <link href="/2019/12/28/Satisfiability-of-Equality-Equations/"/>
      <url>/2019/12/28/Satisfiability-of-Equality-Equations/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第51天，考完期末了，hhh。<br>虽然还有一门恶心的Survey没写。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/satisfiability-of-equality-equations/" target="_blank" rel="noopener">Satisfiability of Equality Equations</a>:</p><p>一道并查集的题目，先遍历一次<code>==</code>的式子，建立并查集，然后再遍历一次<code>!=</code>的式子，判断<code>!=</code>两边的字符是否属于不同的两个集合即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">equationsPossible</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; equations)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">imap</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>; i++) imap[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e: equations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[<span class="number">1</span>] == <span class="string">'!'</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> i1 = e[<span class="number">0</span>] - <span class="string">'a'</span>, i2 = e[<span class="number">3</span>] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">while</span>(imap[i1] != i1) i1 = imap[i1];</span><br><span class="line">        <span class="keyword">while</span>(imap[i2] != i2) i2 = imap[i2];</span><br><span class="line">        imap[i1] = i2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e: equations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[<span class="number">1</span>] == <span class="string">'='</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> i1 = e[<span class="number">0</span>] - <span class="string">'a'</span>, i2 = e[<span class="number">3</span>] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">while</span>(imap[i1] != i1) i1 = imap[i1];</span><br><span class="line">        <span class="keyword">while</span>(imap[i2] != i2) i2 = imap[i2];</span><br><span class="line">        <span class="keyword">if</span> (i1 == i2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Binary Tree Coloring Game</title>
      <link href="/2019/12/27/Binary-Tree-Coloring-Game/"/>
      <url>/2019/12/27/Binary-Tree-Coloring-Game/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第50天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/binary-tree-coloring-game/" target="_blank" rel="noopener">Binary Tree Coloring Game</a></p><p>挺唬人的题目，搞清楚题意的话，还是挺简单的。</p><p>大概的意思是，现在有一个树，然后已经有个人将其中一个节点上色成红色，问你，现在按顺序涂颜色，最后你能不能赢。这个的规则有两个：</p><ul><li>除了第一个颜色可以随便找节点上色外，其他的都只能对自己临近的节点上色。</li><li>有颜色的节点不能再次上色</li><li>所以节点上完色后，节点多的人获胜</li></ul><p><img src="https://assets.leetcode.com/uploads/2019/08/01/1480-binary-tree-coloring-game.png" alt=""></p><p>因为是在树上，所以给第二个以及之后的节点上色的话，只有三种选择，向父节点、向左节点、向右节点。</p><p>所以我们只要判断对手上色的第一个节点，三个方向中，是否存在一个方向的节点比剩余节点都要多。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">btreeGameWinningMove</span><span class="params">(TreeNode* root, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    TreeNode *node = search(root, x);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> leftNum = getNodeNum(node-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> rightNum = getNodeNum(node-&gt;right);</span><br><span class="line">    <span class="keyword">int</span> upNum = n - <span class="number">1</span> - leftNum - rightNum;</span><br><span class="line">    <span class="keyword">int</span> maxNum = <span class="built_in">max</span>(<span class="built_in">max</span>(leftNum, rightNum), upNum);</span><br><span class="line">    <span class="comment">// cout &lt;&lt; leftNum &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; rightNum &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; upNum &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; maxNum &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> maxNum &gt; (n - maxNum);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNodeNum</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + getNodeNum(root-&gt;left) + getNodeNum(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">search</span><span class="params">(TreeNode *root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root || root-&gt;val == x) <span class="keyword">return</span> root;</span><br><span class="line">    TreeNode *node = search(root-&gt;left, x);</span><br><span class="line">    <span class="keyword">if</span> (node) <span class="keyword">return</span> node;</span><br><span class="line">    <span class="keyword">return</span> search(root-&gt;right, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maximum Level Sum of a Binary Tree</title>
      <link href="/2019/12/26/Maximum-Level-Sum-of-a-Binary-Tree/"/>
      <url>/2019/12/26/Maximum-Level-Sum-of-a-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第49天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/" target="_blank" rel="noopener">Maximum Level Sum of a Binary Tree</a>:</p><p>送分题，直接用层次便利计算每一层的元素之和，然后去最大即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxLevelSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> max_level = <span class="number">-1</span>, max_sum = INT_MIN;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cur_level = <span class="number">1</span>, cur_sum;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        cur_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, <span class="built_in">size</span> = q.<span class="built_in">size</span>(); i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">            root = q.front(); q.pop();</span><br><span class="line">            cur_sum += root-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left) q.push(root-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right) q.push(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur_sum &gt; max_sum) &#123;</span><br><span class="line">            max_sum = cur_sum;</span><br><span class="line">            max_level = cur_level;</span><br><span class="line">        &#125;</span><br><span class="line">        cur_level++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max_level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maximum Length of Repeated Subarray &amp; Edit Distance</title>
      <link href="/2019/12/24/Maximum-Length-of-Repeated-Subarray/"/>
      <url>/2019/12/24/Maximum-Length-of-Repeated-Subarray/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第48天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/maximum-length-of-repeated-subarray/" target="_blank" rel="noopener">Maximum Length of Repeated Subarray</a>:</p><p>一道DP的题目，有点像LCS。</p><p>我们假定<code>dp[i, j]</code>为以<code>A[i]</code>结尾和以<code>B[j]</code>结尾的最长重合子数组的长度，则：</p><p>$$<br>dp[i, j] = \left{<br>    \begin{aligned}<br>        0 &amp;, &amp; A[i] \neq B[i] \<br>        dp[i-1, j-1] + 1 &amp;, &amp; A[i] = B[i]<br>    \end{aligned}<br>\right.<br>$$</p><p>然后我们只需要对<code>dp</code>求最大值即可得到最长重复子数组的长度：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n;j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">            dp[j] = (A[i<span class="number">-1</span>] == B[j<span class="number">-1</span>]) ? (dp[j<span class="number">-1</span>] + <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">            res = <span class="built_in">max</span>(dp[j], res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来多一道<a href="https://leetcode.com/problems/edit-distance/" target="_blank" rel="noopener">Edit Distance</a>:</p><p>一道hard的题目，一次直接AC了。也是DP的题目，这道题让人觉得麻烦的是，它支持三种操作：</p><ul><li>插入</li><li>删除</li><li>替换</li></ul><p>一开始会觉得，插入和删除有点难区分，后来想了想，好像他们的代价是一样的，所以我们可以只用删除，不用插入，所以我们可以来解决这个问题：</p><p><code>dp[i, j]</code>为<code>word1[0..i]</code>和<code>word2[0..j]</code>的编辑距离：</p><ul><li>如果<code>word1[i] == word2[j]</code>的话，<code>dp[i,j] = dp[i-1, j-1]</code>，即不需要做任何编辑</li><li>如果<code>word1[i] != word2[j]</code>的话，我们可以尝试删除或替换两种操作<ul><li>删除<code>word1[i]</code></li><li>删除<code>word2[i]</code></li><li>替换<code>word1[i]</code>或<code>word2[i]</code></li></ul></li></ul><p>则<code>dp[i, j] = min(dp[i-1, j], dp[i, j-1], dp[i-1, j-1])</code></p><p>边界条件就是，当<code>i==0</code>时，<code>dp[i, j] = j</code>,当<code>j==0</code>时，<code>dp[i, j] = i</code>。</p><p>所以我们可以写出动规方程：</p><p>$$<br>dp[i, j] = \left{<br>    \begin{aligned}<br>        i &amp;, &amp; i = 0 \<br>        j &amp;, &amp; j = 0 \<br>        dp[i-1, j-1] &amp;, &amp; word1[i] = word2[j] \<br>        min(dp[i-1, j], dp[i, j-1], dp[i-1, j-1]) &amp;, &amp; A[i] \neq B[i]<br>    \end{aligned}<br>\right.<br>$$</p><p>因此，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1 = word1.<span class="built_in">size</span>(), n2 = word2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n2 + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= n2; j++) &#123;</span><br><span class="line">        dp[j] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> prev;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">        prev = dp[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n2; j++) &#123;</span><br><span class="line">            swap(dp[j], prev);</span><br><span class="line">            <span class="keyword">if</span> (word1[i<span class="number">-1</span>] != word2[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                dp[j] = <span class="built_in">min</span>(<span class="built_in">min</span>(dp[j<span class="number">-1</span>], dp[j]), prev) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flipping an Image</title>
      <link href="/2019/12/23/Flipping-an-Image/"/>
      <url>/2019/12/23/Flipping-an-Image/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第47天</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/flipping-an-image/" target="_blank" rel="noopener">Flipping an Image</a>:</p><p>考试周，做一道<code>Easy</code>题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">flipAndInvertImage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v: A) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = v.<span class="built_in">size</span>() - <span class="number">1</span>;i &lt;= j; i++, j--) &#123;</span><br><span class="line">            t = (v[j]==<span class="number">1</span>) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">            v[j] = (v[i]==<span class="number">1</span>) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">            v[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interval List Intersections</title>
      <link href="/2019/12/22/Interval-List-Intersections/"/>
      <url>/2019/12/22/Interval-List-Intersections/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第46天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/interval-list-intersections/" target="_blank" rel="noopener">Interval List Intersections</a>:</p><p>挺简单的题目，用两个指针控制就好了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">intervalIntersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; A.<span class="built_in">size</span>() &amp;&amp; j &lt; B.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// check A[i] and B[j]</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="built_in">max</span>(A[i][<span class="number">0</span>], B[j][<span class="number">0</span>]), right = <span class="built_in">min</span>(A[i][<span class="number">1</span>], B[j][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= right) res.push_back(&#123;left, right&#125;);</span><br><span class="line">        <span class="comment">// update i and j</span></span><br><span class="line">        <span class="keyword">if</span> (A[i][<span class="number">1</span>] &gt; B[j][<span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A[i][<span class="number">1</span>] &lt; B[j][<span class="number">1</span>]) i++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            i++; j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Binary Search Tree to Greater Sum Tree</title>
      <link href="/2019/12/21/Binary-Search-Tree-to-Greater-Sum-Tree/"/>
      <url>/2019/12/21/Binary-Search-Tree-to-Greater-Sum-Tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第45天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/" target="_blank" rel="noopener">Binary Search Tree to Greater Sum Tree</a>:</p><p>感觉这道题的题意很奇怪，不清不楚的，不过看Example还是看的出他问的是什么的，挺简单的题目：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">bstToGst</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> bstToGst(root, sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">bstToGst</span><span class="params">(TreeNode* root, <span class="keyword">int</span> &amp;sum)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="comment">// TreeNode *node = new TreeNode(root-&gt;val);</span></span><br><span class="line">    root-&gt;right = bstToGst(root-&gt;right, sum);</span><br><span class="line">    root-&gt;val = sum = root-&gt;val + sum;</span><br><span class="line">    root-&gt;left = bstToGst(root-&gt;left, sum);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Find Eventual Safe States</title>
      <link href="/2019/12/20/Find-Eventual-Safe-States/"/>
      <url>/2019/12/20/Find-Eventual-Safe-States/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第44天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/find-eventual-safe-states/" target="_blank" rel="noopener">Find Eventual Safe States</a>:</p><p>最开始的想法是，从安全的节点开始在图中进行扩散，当一个节点所有边都指向一个安全的节点时，那它也是一个安全的节点，但是这样复杂度挺高的，所以虽然能过：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;color, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;j: graph[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!color[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">eventualSafeNodes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = graph.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">color</span><span class="params">(<span class="built_in">size</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> change = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="built_in">size</span>; i++) </span><br><span class="line">        <span class="keyword">if</span> (graph[i].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            color[i] = <span class="literal">true</span>;</span><br><span class="line">            change = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(change) &#123;</span><br><span class="line">        change = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (color[i] == <span class="literal">false</span> &amp;&amp; check(graph, color, i)) &#123;</span><br><span class="line">                color[i] = <span class="literal">true</span>;</span><br><span class="line">                change = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (color[i]) res.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后来发现好像可以用深度优先来做，主要的想法是，一个环中所有的节点都是不安全的，我们把不安全的节点都筛选出来，即可得到所有安全的节点。<br>因此就把问题变成了找到图中所有在环中的节点。在DFS时，维护一个状态，这个状态可能为：</p><ul><li>0：未访问（初始状态）</li><li>1：访问中</li><li>2：访问完成（安全状态）</li><li>3：在环中（不安全状态）</li></ul><p>先把所有节点的状态都初始化为<code>0</code>,当对第 i 个节点调用 dfs 时，则将其转换为<code>1</code>,然后遍历该节点所有能走的边，<br>如果下一个节点的状态为<code>0</code>，则对其调用dfs，如果下一个节点的状态为<code>1</code>或<code>2</code>，则该节点出现在环中，将状态转换为<code>3</code>，并直接返回为<code>3</code>。<br>当 i 节点对 j 节点调用 dfs 后，返回值如果为3的话，则 i 节点状态也变为 <code>3</code>, 并直接返回<code>3</code>。</p><p>如果第 <code>i</code> 个节点对所有路径都调用了 dfs 后，没有遇到返回值为 <code>3</code> 的情况，则该节点为安全的，所以将其状态转换为 <code>2</code>。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">eventualSafeNodes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = graph.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">color</span><span class="params">(<span class="built_in">size</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 0 mean unvisit</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (color[i] == <span class="number">0</span>) dfs(graph, color, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (color[i] == <span class="number">2</span>) res.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;graph, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;color, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; "visit" &lt;&lt; node &lt;&lt; endl;</span></span><br><span class="line">    color[node] = <span class="number">1</span>; <span class="comment">// in dfs</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; graph[node].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = graph[node][j];</span><br><span class="line">        <span class="keyword">if</span> ( (color[i] == <span class="number">0</span> &amp;&amp; dfs(graph, color, i) == <span class="number">3</span>) ||</span><br><span class="line">            color[i] == <span class="number">1</span> || color[i] == <span class="number">3</span></span><br><span class="line">            ) &#123;</span><br><span class="line">            color[node] = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    color[node] = <span class="number">2</span>;<span class="comment">// safe node</span></span><br><span class="line">    <span class="keyword">return</span> color[node];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flatten a Multilevel Doubly Linked List</title>
      <link href="/2019/12/19/Flatten-a-Multilevel-Doubly-Linked-List/"/>
      <url>/2019/12/19/Flatten-a-Multilevel-Doubly-Linked-List/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第43天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/" target="_blank" rel="noopener">Flatten a Multilevel Doubly Linked List</a>:</p><p>蛮好玩的一道题。</p><p>本来想用递归做的，但是发现好像需要一层一层的返回最后一个指针，觉得有点麻烦，就直接用栈做了。</p><p>这个栈是用来保存上一层的指针的，而且看起来每一层最多一个节点有<code>child</code>，所以我们可以这样做：</p><ul><li>遍历当前层，如果有孩子，则把当前节点压入栈中，并跳到下一层去遍历</li><li>如果遍历完当前层，则从栈中取出<code>parent</code>，然后进行<code>flatten</code>,为了避免没有必要的重复遍历，当前层最后一个节点压入栈中,这样下一次遍历时，就从上一层中第一个未被遍历的节点开始了。</li></ul><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Node*&gt; st;</span><br><span class="line">    st.push(head);</span><br><span class="line">    <span class="comment">// if (head-&gt;child) st.push(head-&gt;child);</span></span><br><span class="line">    <span class="keyword">while</span>(!st.empty()) &#123;</span><br><span class="line">        Node *p = st.top(); st.pop();</span><br><span class="line">        <span class="keyword">while</span>(!p-&gt;child &amp;&amp; p-&gt;next) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;child) &#123;</span><br><span class="line">            st.push(p);</span><br><span class="line">            st.push(p-&gt;child);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!st.empty()) &#123;</span><br><span class="line">            Node *parent = st.top(); st.pop();</span><br><span class="line">            p-&gt;next = parent-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;next) p-&gt;next-&gt;prev = p;</span><br><span class="line">            parent-&gt;next = parent-&gt;child;</span><br><span class="line">            parent-&gt;next-&gt;prev = parent;</span><br><span class="line">            parent-&gt;child = <span class="literal">nullptr</span>;</span><br><span class="line">            st.push(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Find Largest Value in Each Tree Row</title>
      <link href="/2019/12/18/Find-Largest-Value-in-Each-Tree-Row/"/>
      <url>/2019/12/18/Find-Largest-Value-in-Each-Tree-Row/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第42天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/find-largest-value-in-each-tree-row/" target="_blank" rel="noopener">Find Largest Value in Each Tree Row</a>:</p><p>水题，用队列做树的层次遍历即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> max_v = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, <span class="built_in">size</span> = q.<span class="built_in">size</span>(); i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">            root = q.front(); q.pop();</span><br><span class="line">            max_v = <span class="built_in">max</span>(max_v, root-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left) q.push(root-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right) q.push(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(max_v);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Validate Stack Sequences</title>
      <link href="/2019/12/17/Validate-Stack-Sequences/"/>
      <url>/2019/12/17/Validate-Stack-Sequences/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第41天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/validate-stack-sequences/" target="_blank" rel="noopener">Validate Stack Sequences</a>:</p><p>简单题，直接模拟就好了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validateStackSequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pushed, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;t: popped) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st.empty() &amp;&amp; st.top() == t) &#123;</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; pushed.<span class="built_in">size</span>() &amp;&amp; pushed[i] != t) &#123;</span><br><span class="line">                st.push(pushed[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pushed.<span class="built_in">size</span>() == i) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Network Delay Time</title>
      <link href="/2019/12/16/Network-Delay-Time/"/>
      <url>/2019/12/16/Network-Delay-Time/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第40天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/network-delay-time/" target="_blank" rel="noopener">Network Delay Time</a>:</p><p>一道图的题目，比较常规，用Dijkstra求单源最短路，然后取距离最远的那个即可得到<code>Network Delay Time</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDisNode</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;visited, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;dis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min_v = INT_MAX, min_i = <span class="number">-1</span>;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; dis.<span class="built_in">size</span>();j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[j] &amp;&amp; dis[j] &lt; min_v) &#123;</span><br><span class="line">            min_v = dis[j];</span><br><span class="line">            min_i = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min_i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (times.<span class="built_in">size</span>() == <span class="number">0</span> || N==<span class="number">0</span> || K &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    <span class="comment">//build graph;</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">graph</span><span class="params">(N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, INT_MAX))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;t: times) &#123;</span><br><span class="line">        graph[t[<span class="number">0</span>]<span class="number">-1</span>][t[<span class="number">1</span>]<span class="number">-1</span>] = t[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    K--;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dis</span><span class="params">(N, INT_MAX)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(N, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    visited[K] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; dis.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        dis[i] = graph[K][i];</span><br><span class="line">    &#125;</span><br><span class="line">    dis[K] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; N; i++) &#123;</span><br><span class="line">        <span class="comment">// find a unvisited node which dis is min</span></span><br><span class="line">        <span class="keyword">int</span> j = minDisNode(visited, dis);</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        visited[j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; dis.<span class="built_in">size</span>(); k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph[j][k] != INT_MAX) &#123;</span><br><span class="line">                dis[k] = <span class="built_in">min</span>(dis[k], dis[j] + graph[j][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dis[i] != INT_MAX)</span><br><span class="line">            res = <span class="built_in">max</span>(res, dis[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Largest Sum of Averages</title>
      <link href="/2019/12/15/Largest-Sum-of-Averages/"/>
      <url>/2019/12/15/Largest-Sum-of-Averages/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第39天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/largest-sum-of-averages/" target="_blank" rel="noopener">Largest Sum of Averages</a>:</p><p>一道动态规划的题目，有点想切钢管的问题。</p><p>动规方程如下：</p><p>$$<br>dp[i, j] = \left{<br>    \begin{aligned}<br>        \sum_{z=0}^j A[z] &amp; &amp; i = 1\<br>        \underset{ {i-1 \leq t \leq n-1} }{max} { dp[i-1, t] + \frac {\sum_{z=t+1}^n A[z]} {n-t+1}  } &amp; &amp; others<br>    \end{aligned}<br>\right.<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">largestSumOfAverages</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// vector&lt;vector&lt;double&gt;&gt; dp(K + 1, vector&lt;double&gt;(A.size(), 0));</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">dp</span><span class="params">(A.<span class="built_in">size</span>(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; A.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">        sum += A[j];</span><br><span class="line">        dp[j] = sum / (j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; K; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = A.<span class="built_in">size</span>() - <span class="number">1</span>;j &gt;= i; j--) &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t = j;t &gt;= i; t--) &#123;</span><br><span class="line">                sum += A[t];</span><br><span class="line">                count++;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[t<span class="number">-1</span>] + sum/count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[A.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unique Substrings in Wraparound String</title>
      <link href="/2019/12/14/Unique-Substrings-in-Wraparound-String/"/>
      <url>/2019/12/14/Unique-Substrings-in-Wraparound-String/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第38天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/unique-substrings-in-wraparound-string/" target="_blank" rel="noopener">Unique Substrings in Wraparound String</a>:</p><p>这道题麻烦的地方在于，子串需要去除重复。我们把问题转换一下，即以字符 c 结尾的子串的个数。不难发现，最长长度和子串个数是相同的。这样的话，我们可以在遍历时维护一个变量<code>len</code>来保存，以当前字符结尾的子串的长度，通过判断当前字符与上一个字符是否在<code>s</code>中相邻，来确定以当期字符结尾的子串的个数。同时，为了去除重复，我们可以用一个长度为26的字典来保存每个以字符 c 结尾的子串的最长长度。最后，我们只需要对字典进行一次求和即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findSubstringInWraproundString</span><span class="params">(<span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dict</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> prev = p[<span class="number">0</span>] - <span class="string">'a'</span>;</span><br><span class="line">    dict[prev] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; p.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = p[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> ((prev + <span class="number">1</span>) % <span class="number">26</span> == temp) &#123;</span><br><span class="line">            dict[temp] = <span class="built_in">max</span>(++len, dict[temp]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; len = <span class="number">1</span>; dict[temp] = <span class="built_in">max</span>(dict[temp], <span class="number">1</span>); &#125;</span><br><span class="line">        prev = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sum</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i: dict) res += i;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redundant Connection</title>
      <link href="/2019/12/13/Redundant-Connection/"/>
      <url>/2019/12/13/Redundant-Connection/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第37天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/redundant-connection/" target="_blank" rel="noopener">Redundant Connection</a>:</p><p>这道题用并查集可以解决掉，具体思路如下：</p><p>首先初始化一个并查集，然后遍历输入<code>edges</code>，使用并查集查找两个节点所在的集合，如果两个节点在同一个节点中，那么往图里面加入这条边就会出现环，即无法构成树，因此这条边就是我们要求的边；如果不在集合，那么就将这条边插入到图中（即合并两个集合）。具体实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">root</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ids, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(ids[i] != i) i = ids[i];</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (edges.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ids</span><span class="params">(edges.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ids.<span class="built_in">size</span>(); i++) ids[i] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e: edges) &#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = root(ids, e[<span class="number">0</span>]<span class="number">-1</span>), n2 = root(ids, e[<span class="number">1</span>]<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (n1 == n2) <span class="keyword">return</span> e;</span><br><span class="line">        ids[n1] = n2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *edges.rbegin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Print FooBar Alternately</title>
      <link href="/2019/12/12/Print-FooBar-Alternately/"/>
      <url>/2019/12/12/Print-FooBar-Alternately/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第36天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/print-foobar-alternately/" target="_blank" rel="noopener">Print FooBar Alternately</a>:</p><p>一道简单的并发的题目，交替输出<code>Foo</code>和<code>Bar</code>，就是要并发的两个线程，按顺序交替执行，我们可以用两个<code>mutxe</code>去实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    mutex m1, m2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FooBar(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        m2.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printFoo)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            m1.lock();</span><br><span class="line">        <span class="comment">// printFoo() outputs "foo". Do not change or remove this line.</span></span><br><span class="line">        printFoo();</span><br><span class="line">            m2.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printBar)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            m2.lock();</span><br><span class="line">        <span class="comment">// printBar() outputs "bar". Do not change or remove this line.</span></span><br><span class="line">        printBar();</span><br><span class="line">            m1.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Binary Tree Pruning</title>
      <link href="/2019/12/11/Binary-Tree-Pruning/"/>
      <url>/2019/12/11/Binary-Tree-Pruning/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第35天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/binary-tree-pruning/" target="_blank" rel="noopener">Binary Tree Pruning</a>:</p><p>简单题，用先序遍历做就好了，而且不需要使用<code>flag</code>或<code>count</code>等额外的变量来判断是否要删除当前节点。</p><p>大概逻辑如下：</p><p>先序遍历时，用<code>left = pruneTree(left)</code>的方式去调用，在遍历完子树后，当前节点的子树都是只包含<code>1</code>的树了，我们可以通过判断指针是否为空来确定子树中是否有<code>1</code>，进而判断出是否要删除当前节点，所以我们不需要维护额外的变量来判断。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">pruneTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    root-&gt;left = pruneTree(root-&gt;left);</span><br><span class="line">    root-&gt;right = pruneTree(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left || root-&gt;right || root-&gt;val == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Friend Circles</title>
      <link href="/2019/12/10/Friend-Circles/"/>
      <url>/2019/12/10/Friend-Circles/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第34天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/friend-circles/" target="_blank" rel="noopener">Friend Circles</a>:</p><p>一道图论的题目，求连通分量的个数。这道题之前考研复试面试时遇到过。</p><p>用并查集去做会比较快，但是需要对并查集做一定修改。</p><p>简单来说，并查集的数组全初始化为0，然后在遍历到<code>M[i][j]==true</code>时进行<code>union</code>操作.</p><p>遍历完后，<code>arr</code>中值为<code>-1</code>的元素的个数就是连通分量的个数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">root</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root = i;</span><br><span class="line">    <span class="keyword">while</span>(arr[root] != <span class="number">-1</span>) root = arr[root];</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionFunc</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    i = root(arr, i); </span><br><span class="line">    j = root(arr, j);</span><br><span class="line">    <span class="keyword">if</span> (i == j) <span class="keyword">return</span>;</span><br><span class="line">    arr[j] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (M.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = M.<span class="built_in">size</span>();</span><br><span class="line">    arr = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">size</span>, <span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; <span class="built_in">size</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (M[i][j]) &#123;</span><br><span class="line">                unionFunc(i, j);</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="built_in">size</span>; i++) res += (arr[i] == <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Minimum ASCII Delete Sum for Two Strings</title>
      <link href="/2019/12/09/Minimum-ASCII-Delete-Sum-for-Two-Strings/"/>
      <url>/2019/12/09/Minimum-ASCII-Delete-Sum-for-Two-Strings/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第33天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/" target="_blank" rel="noopener">Minimum ASCII Delete Sum for Two Strings</a>:</p><p>一道动态规划的问题，而且挺常规的。这道题的动规方程如下：</p><p>$$<br>dp[i, j] = \left{<br>\begin{aligned}<br>    \sum_{k=0}^{j} s2[k] &amp; ,&amp; i == 0 \<br>    \sum_{k=0}^{i} s1[k] &amp; ,&amp; j == 0 \<br>    dp[i-1, j-1] &amp; ,&amp; s1[i] == s2[j] \<br>    min{dp[i-1][j] + s1[i], dp[i][j-1] + s2[j]  } &amp; ,&amp; s1[i] == s2[j]<br>\end{aligned}<br>\right.<br>$$</p><p>其中<code>d[i, j]</code>表示字符串<code>s1[0, i)</code>和字符串<code>s2[0, j)</code>的最小删除ASCII之和。根据动规方程可以写出如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumDeleteSum</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(s2.<span class="built_in">size</span>() + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; dp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] + s2[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> prev;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        prev = dp[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>] += s1[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= s2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1[i] == s2[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                swap(prev, dp[j]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev = dp[j];</span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j] + s1[i], dp[j<span class="number">-1</span>] + s2[j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[s2.<span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rotate Function</title>
      <link href="/2019/12/08/Rotate-Function/"/>
      <url>/2019/12/08/Rotate-Function/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第32天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/rotate-function/" target="_blank" rel="noopener">Rotate Function</a>。</p><p>这道题是一道数学题，直接求解的话显然复杂度很高，然后这道题也没法把大问题化简到小问题，所以用常规的分治、动规和贪心去想这道题的话，是没法找到答案的。</p><p>为了解决这道题，我们先把 $F(k)$ 的写出来：</p><p>$$<br>F(k) = 0 * B_k[0] + 1 * B_k[1] + … + (n - 1) * B_k[n-1]<br>$$</p><p>然后我们通过题意可以知道 $B_k[i] = A[(i+k) % n]$ ，所以：</p><p>$$<br>\begin{aligned}<br>F(k) &amp;= 0 * B_k[0] + 1 * B_k[1] + … + (n - 1) * B_k[n-1] \<br>     &amp;= 0 * A[(0+k) % n] + A[(1+k) % n] + … + (n - 1) * A[(n-1+k) % n] \<br>     &amp;= \sum_{i=0}^{n-1} i * A[(i+k) % n]<br>\end{aligned}<br>$$</p><p>我们可以尝试把 $(i + k) % n$ 中的 取模运算去掉：</p><p>$$</p><p>\begin{aligned}<br>F(k) &amp;= \sum_{i=0}^{n-1} i * A[(i+k) % n] \<br>     &amp;= \sum_{i=1}^{n-k-1} i * A[i+k] + \sum_{i=n-k}^{n-1} i * A[i + k -n] \<br>\end{aligned}</p><p>$$</p><p>我们把 $j = i - k$ 代入 $\sum_{i=1}^{n-k-1} i * A[i+k]$ 和 $j = i + k -n$ 代入 $\sum_{i=n-k}^{n-1} i * A[i + k -n]$ :</p><p>$$<br>\begin{aligned}<br>F(k) &amp;= \sum_{j=k}^{n-1} (j - k) * A[j] + \sum_{j=0}^{k-1} (j + n -k) * A[j] \<br>     &amp; = \sum_{j=0}^{n-1} j * A[j] + n * \sum_{j=0}^{k-1} A[j] - k * \sum_{j=0}^{n-1} A[j]<br>\end{aligned}<br>$$</p><p>上面的公式中 $\sum_{j=0}^{n-1} j * A[j]$ 和 $\sum_{j=0}^{n-1} A[j]$ 都是常数，因此我们可以可以用 $O(n)$ 的时间复杂度解决这道题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxRotateFunction</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> s1 = <span class="number">0</span>, s2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, <span class="built_in">size</span> = A.<span class="built_in">size</span>(); i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">        s1 += A[i];</span><br><span class="line">        s2 += i*A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = LONG_MIN;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>, n = A.<span class="built_in">size</span>();k &lt; n; k++) &#123;</span><br><span class="line">        t += A[k];</span><br><span class="line">        res = <span class="built_in">max</span>(res,n * t - (k+<span class="number">1</span>) * s1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res + s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Longest Word in Dictionary through Deleting</title>
      <link href="/2019/12/07/Longest-Word-in-Dictionary-through-Deleting/"/>
      <url>/2019/12/07/Longest-Word-in-Dictionary-through-Deleting/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第31天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/" target="_blank" rel="noopener">Longest Word in Dictionary through Deleting</a>:</p><p>很常规的题目。</p><p>因为题目要求返回的是最长的字符串，同时如果有多个解的话，就返回字典序最小的那个，所以我们先按要求进行一次排序。然后在 check 一下是否符合即可。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">const</span> <span class="built_in">string</span> &amp;t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>, i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; s.<span class="built_in">size</span>() &amp;&amp; s[index] != t[i]) index++;</span><br><span class="line">        <span class="keyword">if</span> (index == s.<span class="built_in">size</span>()) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> index++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> i == t.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">findLongestWord</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">    sort(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>(),[](<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.<span class="built_in">size</span>() != s2.<span class="built_in">size</span>()) <span class="keyword">return</span> s1.<span class="built_in">size</span>() &gt; s2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> s1 &lt; s2;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; d.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (check(s, d[i])) <span class="keyword">return</span> d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Partition Labels</title>
      <link href="/2019/12/06/Partition-Labels/"/>
      <url>/2019/12/06/Partition-Labels/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第30天，一个月了。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/partition-labels/" target="_blank" rel="noopener">Partition Labels</a>:</p><p>这道题的解法如下：</p><p>先遍历一次字符串统计字符出现的次数保存在<code>c1</code>上，然后在遍历一次字符串，这次遍历时同样进行统计字符出现次数保存在<code>c2</code>上，并维护一个变量<code>cnum</code>，这个变量<code>cnum</code>表示当前出现过但是未出现完全的字符的种类数。当出现<code>cnum</code>为 0 时，就表示完成了一次划分。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, <span class="built_in">size</span> = S.<span class="built_in">size</span>(); i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">        c1[S[i] - <span class="string">'a'</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">c2</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">1</span>, cnum = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, <span class="built_in">size</span> = S.<span class="built_in">size</span>(); i &lt; <span class="built_in">size</span>; i++, temp++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = S[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (c2[index] == <span class="number">0</span>) &#123;</span><br><span class="line">            cnum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (++c2[index]== c1[index] &amp;&amp; --cnum == <span class="number">0</span>) &#123;</span><br><span class="line">            res.push_back(temp); temp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Add and Search Word - Data structure design</title>
      <link href="/2019/12/05/Add-and-Search-Word-Data-structure-design/"/>
      <url>/2019/12/05/Add-and-Search-Word-Data-structure-design/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第29天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/add-and-search-word-data-structure-design/" target="_blank" rel="noopener">Add and Search Word - Data structure design</a>:</p><p>一道字典树的题目，如果知道字典树是怎样的话，应该不难做。不过这道题直接套字典树是不行的，因为它需要支持 <code>.</code> 字符来标识任意字符，所以我们在Search的时候需要做一定的修改。<br>简单的来说就是原本用一个指针进行搜索，现在需要一个队列来维护多个指针进行搜索，恩，仅此而已。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>&#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TrieNode*&gt; childs;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">    TrieNode(<span class="keyword">char</span> _c):c(_c),childs(<span class="number">26</span>, <span class="literal">nullptr</span>),flag(<span class="literal">false</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TrieNode *<span class="title">addChild</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (childs[c - <span class="string">'a'</span>]) <span class="keyword">return</span> childs[c - <span class="string">'a'</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> childs[c - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> &#123;</span></span><br><span class="line">    TrieNode *root;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    WordDictionary():root(<span class="keyword">new</span> TrieNode(<span class="string">'?'</span>)) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds a word into the data structure. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWord</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "Add " &lt;&lt; word &lt;&lt; endl;</span></span><br><span class="line">        TrieNode *p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: <span class="keyword">word</span>) &#123;</span><br><span class="line">            p = p-&gt;addChild(c);</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; "Search " &lt;&lt; word &lt;&lt; endl;</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;TrieNode *&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: <span class="keyword">word</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; c &lt;&lt; " ";</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'.'</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,<span class="built_in">size</span> = q.<span class="built_in">size</span>();i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">                    TrieNode *p = q.front(); q.pop();</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">26</span>;j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (p-&gt;childs[j]) q.push(p-&gt;childs[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,<span class="built_in">size</span> = q.<span class="built_in">size</span>();i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">                    TrieNode *p = q.front(); q.pop();</span><br><span class="line">                    <span class="keyword">if</span> (p-&gt;childs[c - <span class="string">'a'</span>]) q.push(p-&gt;childs[c - <span class="string">'a'</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.front()-&gt;flag) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Best Sightseeing Pair</title>
      <link href="/2019/12/04/Best-Sightseeing-Pair/"/>
      <url>/2019/12/04/Best-Sightseeing-Pair/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第28天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/best-sightseeing-pair/" target="_blank" rel="noopener">Best Sightseeing Pair</a>:</p><p>这道题的关键就是什么时候移动 i 这个下标，我们观察一下这个公式：<code>A[i] + A[j] + i - j</code>，转化一下就成了<code>(A[i] + i) + (A[j] - j)</code>，因此如果存在两个<code>i</code>，即<code>i1</code>和<code>i2</code>的话，当<code>A[i1] + i1 &gt; A[i2] + i2</code>成立时，我们就可以用 <code>i2</code>去替代原来的<code>i1</code>。至于<code>j</code>的话，我们只需要从头到尾遍历一遍即可，同时在穷举<code>j</code>的时候，可以顺便穷举出<code>i</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> =  A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;j &lt; <span class="built_in">size</span>; j++) &#123;</span><br><span class="line">        res = <span class="built_in">max</span>(res, A[i] + A[j] + i - j);</span><br><span class="line">        <span class="keyword">if</span> (A[j] + j &gt; A[i] + i) i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把式子重写成<code>A[j] + (A[i] + i - j)</code>，随着<code>j++</code>，<code>i - j</code>会减一，如果不改变 <code>i</code>的话，<code>(A[i] + i - j)</code>相比于之前就只是减一而已，如果要改变的话，<code>A[i] + i - j = A[j] - 1</code>,则我们可以将循环简化成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int maxScoreSightseeingPair(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">    int size &#x3D;  A.size();</span><br><span class="line">    int res &#x3D; 0;</span><br><span class="line">    if (size &#x3D;&#x3D; 0) return res;</span><br><span class="line">    int cur &#x3D; 0;</span><br><span class="line">    for(int j &#x3D; 0;j &lt; size; j++) &#123;</span><br><span class="line">        res &#x3D; max(res, cur + A[j]);</span><br><span class="line">        cur &#x3D; max(cur, A[j]) - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Longest Palindromic Subsequence</title>
      <link href="/2019/12/03/Longest-Palindromic-Subsequence/"/>
      <url>/2019/12/03/Longest-Palindromic-Subsequence/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第27天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">Longest Palindromic Subsequence</a>：</p><p>一道动态规划的问题，我们假定<code>dp[i, j]</code>是字符串<code>S[i:j]</code>最长回文串的长度。那么我们可以写出如下动规方程：</p><p>$$<br>dp[i, j] = \left{<br>\begin{aligned}<br>dp[i-1, j-1] + 2 &amp; &amp;,s[i] = s[j] \<br>max{d[i-1,j], dp[i, j-1]} &amp; &amp;,s[i] \neq s[j]<br>\end{aligned}<br>\right.<br>$$</p><p>有了动规方程后，这个问题就简单多了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq1</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(<span class="built_in">size</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">size</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="built_in">size</span> - <span class="number">1</span>;i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; <span class="built_in">size</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i+<span class="number">1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="built_in">size</span><span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了减少空间复杂度，我们可以这样优化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = s.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; dp1(size, 0), dp2(size, 0);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="built_in">size</span> - <span class="number">1</span>;i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        dp2[i] = <span class="number">1</span>;</span><br><span class="line">        dp1[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; <span class="built_in">size</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                <span class="comment">// dp[i][j] = dp[i+1][j-1] + 2;</span></span><br><span class="line">                dp2[j] = dp1[j<span class="number">-1</span>] + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// dp[i][j] = max(dp[i+1][j], dp[i][j-1]);</span></span><br><span class="line">                dp2[j] = <span class="built_in">max</span>(dp1[j], dp2[j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        swap(dp1, dp2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp1[<span class="built_in">size</span><span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Global and Local Inversions</title>
      <link href="/2019/12/02/Global-and-Local-Inversions/"/>
      <url>/2019/12/02/Global-and-Local-Inversions/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第26天</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/global-and-local-inversions/" target="_blank" rel="noopener">Global and Local Inversions</a>：</p><p>看上去挺复杂的题目，但是我们可以从题目中知道，输入的数组是一个 <code>[0,1,...,N-1]</code> 的一个排列，所以A中的元素是有限定的，</p><p>多举几个例子就可以发现如果一个排列要满足 <code>local inversion</code> 和 <code>global inversion</code> 个数相同的话，必须满足：</p><ul><li><code>A[i] == i</code></li><li><code>A[i] == i+1 &amp;&amp; A[i+1] == i</code></li></ul><p>所以我们就可以写出这段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isIdealPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minLimit = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, <span class="built_in">size</span> = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] == i) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A[i] == i + <span class="number">1</span> &amp;&amp; A[i+<span class="number">1</span>] == i) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Insert into a binary search tree</title>
      <link href="/2019/12/01/Insert-into-a-binary-search-tree/"/>
      <url>/2019/12/01/Insert-into-a-binary-search-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第25天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/insert-into-a-binary-search-tree/submissions/" target="_blank" rel="noopener">Insert into a binary search tree</a>:</p><p>看名字就知道是水题，就是在BST中插入一个节点罢了，所以只需要递归查找到插入的位置，然后 new 一个 TreeNode即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &gt; val) root-&gt;left = insertIntoBST(root-&gt;left, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; val) root-&gt;right = insertIntoBST(root-&gt;right, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shifting Letters</title>
      <link href="/2019/11/30/Shifting-Letters/"/>
      <url>/2019/11/30/Shifting-Letters/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第25天。我决定以后不贴题目了。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/shifting-letters/" target="_blank" rel="noopener">Shifting Letters</a>。</p><hr><p>混进 Medium 的 Easy 题目，简单的取模和循环就能解决的问题。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">shiftingLetters</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; shifts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = shifts.<span class="built_in">size</span>() - <span class="number">1</span> ; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        temp = (shifts[i] + temp) % <span class="number">26</span>;</span><br><span class="line">        S[i] = ((S[i] - <span class="string">'a'</span>) + temp) % <span class="number">26</span> + <span class="string">'a'</span>;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; shifts[i] &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Delete Node in a BST</title>
      <link href="/2019/11/28/Delete-Node-in-a-BST/"/>
      <url>/2019/11/28/Delete-Node-in-a-BST/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第24天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener"> Delete Node in a BST </a>:</p><hr><p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.</p><p>Basically, the deletion can be divided into two stages:</p><ol><li>Search for a node to remove.</li><li>If the node is found, delete the node.</li></ol><p><strong>Note:</strong> Time complexity should be O(height of tree).</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">root &#x3D; [5,3,6,2,4,null,7]</span><br><span class="line">key &#x3D; 3</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   6</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">2   4   7</span><br><span class="line"></span><br><span class="line">Given key to delete is 3. So we find the node with value 3 and delete it.</span><br><span class="line"></span><br><span class="line">One valid answer is [5,4,6,2,null,null,7], shown in the following BST.</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   6</span><br><span class="line"> &#x2F;     \</span><br><span class="line">2       7</span><br><span class="line"></span><br><span class="line">Another valid answer is [5,2,6,null,4,null,7].</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   6</span><br><span class="line">   \   \</span><br><span class="line">    4   7</span><br></pre></td></tr></table></figure><hr><p>水题，只要先在<code>BST</code>上做搜索，然后删除就好了，因为只是<code>BST</code>，所以可以不考虑平衡的问题：</p><ul><li><code>left</code>和<code>right</code>都为空：直接删除，返回<code>nullptr</code>即可</li><li><code>left</code>和<code>right</code>都不为空：默认采用把右子树的节点拉上来的方式，即把左子树插入到右子树中，然后再返回<code>right</code>即可。</li><li><code>left</code>和<code>right</code>有一个不为空，则返回不为空的子树即可。</li></ul><p>则代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> left = node-&gt;left, right = node-&gt;right;</span><br><span class="line">    <span class="keyword">delete</span> node;</span><br><span class="line">    <span class="keyword">if</span> (left &amp;&amp; right) &#123;</span><br><span class="line">        <span class="keyword">auto</span> temp = right;</span><br><span class="line">        <span class="keyword">while</span>(temp-&gt;left) &#123;</span><br><span class="line">            temp = temp-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;left = left;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> (left ? left : (right ? right : <span class="literal">nullptr</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val == key) &#123;</span><br><span class="line">        <span class="keyword">return</span> deleteNode(root);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt;  root-&gt;val) &#123;</span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, key);    </span><br><span class="line">    &#125; <span class="keyword">else</span> </span><br><span class="line">        root-&gt;left = deleteNode(root-&gt;left, key);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Longest Common Subsequence</title>
      <link href="/2019/11/27/Longest-Common-Subsequence/"/>
      <url>/2019/11/27/Longest-Common-Subsequence/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第23天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/longest-common-subsequence/" target="_blank" rel="noopener"> Longest Common Subsequence </a>:</p><hr><p>Given two strings <code>text1</code> and <code>text2</code>, return the length of their longest common subsequence.</p><p>A <em>subsequence</em> of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, “ace” is a subsequence of “abcde” while “aec” is not). A <em>common subsequence</em> of two strings is a subsequence that is common to both strings.</p><p>If there is no common subsequence, return 0.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; </span><br><span class="line">Output: 3  </span><br><span class="line">Explanation: The longest common subsequence is &quot;ace&quot; and its length is 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;abc&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest common subsequence is &quot;abc&quot; and its length is 3.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;def&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no such common subsequence, so the result is 0.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= text1.length &lt;= 1000</code></li><li><code>1 &lt;= text2.length &lt;= 1000</code></li><li>The input strings consist of lowercase English characters only.</li></ul><hr><p>这是一道比较经典的动态规划问题吧，它的动规方程为：<br>$$<br>\begin{equation}<br>LCS(i,j) = \left{<br>\begin{array}{rcl}</p><p> &amp; LCS[i-1, j-1] + 1 &amp; ,{s1[i] = s2[j]} \<br>&amp; max(LCS[i, j-1], LCS[i-1, j]) &amp; ,{s1[i] \neq s2[j]}</p><p>\end{array}<br>\right.<br>\end{equation}<br>$$<br>根据动规方程我们可以写出如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(text1.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(text2.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; dp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; dp[<span class="number">0</span>].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[text1.<span class="built_in">size</span>()][text2.<span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的空间复杂度可以继续进行优化，因为<code>LCS[i,j]</code>只与当前行和上一行有关系，所以可以优化成两个数组来做：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = text1.<span class="built_in">size</span>() + <span class="number">1</span>, m = text2.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp1</span><span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp2</span><span class="params">(m)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n; i++) &#123;</span><br><span class="line">        dp1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                dp2[j] = dp1[j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp2[j] = <span class="built_in">max</span>(dp1[j], dp2[j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(dp1, dp2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp1[m<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再进一步的话，我们可以发现<code>dp[i][j]</code>只与 <code>dp[i-1][j-1]</code>，<code>dp[i-1][j]</code>，<code>dp[i][j-1]</code> 相关，如果我们只用一个数组的话，<code>dp[i][j]</code>与<code>dp[i-1][j]</code>其实存在同一个位置，而<code>dp[i][j-1]</code>是在同一行，所以我们只需要维护一个<code>prev</code>变量来保存<code>dp[i-1][j-1]</code>的值即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = text1.<span class="built_in">size</span>(), m = text2.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = prev;</span><br><span class="line">            prev = dp[j];</span><br><span class="line">            dp[j] = (text1[i] == text2[j<span class="number">-1</span>]) ? (temp + <span class="number">1</span>) : (<span class="built_in">max</span>(dp[j], dp[j<span class="number">-1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Possible Bipartition</title>
      <link href="/2019/11/26/Possible-Bipartition/"/>
      <url>/2019/11/26/Possible-Bipartition/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第22天</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/possible-bipartition/" target="_blank" rel="noopener"> Possible Bipartition </a>：</p><hr><p>Given a set of <code>N</code> people (numbered <code>1, 2, ..., N</code>), we would like to split everyone into two groups of <strong>any</strong> size.</p><p>Each person may dislike some other people, and they should not go into the same group. </p><p>Formally, if <code>dislikes[i] = [a, b]</code>, it means it is not allowed to put the people numbered <code>a</code> and <code>b</code> into the same group.</p><p>Return <code>true</code> if and only if it is possible to split everyone into two groups in this way.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: N &#x3D; 4, dislikes &#x3D; [[1,2],[1,3],[2,4]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: group1 [1,4], group2 [2,3]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N &#x3D; 3, dislikes &#x3D; [[1,2],[1,3],[2,3]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N &#x3D; 5, dislikes &#x3D; [[1,2],[2,3],[3,4],[4,5],[1,5]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><code>1 &lt;= N &lt;= 2000</code></li><li><code>0 &lt;= dislikes.length &lt;= 10000</code></li><li><code>1 &lt;= dislikes[i][j] &lt;= N</code></li><li><code>dislikes[i][0] &lt; dislikes[i][1]</code></li><li>There does not exist <code>i != j</code> for which <code>dislikes[i] == dislikes[j]</code>.</li></ol><hr><p>又是一道图的题目，而且和昨天的题目思路是一样的，先遍历染色，然后再判断是否满足即可。</p><p>这里有些不同的是，这道题给出的输入是边的列表，然后我们需要手动建个图。同时，这道题还可以用在遍历时判断是否已经不符合了，进而可以提前退出。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">possibleBipartition</span><span class="params">(<span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dislikes)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">graph</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; dislikes.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        graph[dislikes[i][<span class="number">0</span>]<span class="number">-1</span>].push_back(dislikes[i][<span class="number">1</span>]<span class="number">-1</span>);</span><br><span class="line">        graph[dislikes[i][<span class="number">1</span>]<span class="number">-1</span>].push_back(dislikes[i][<span class="number">0</span>]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> color = <span class="string">'b'</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; <span class="title">visited</span><span class="params">(N, <span class="string">'w'</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i] == <span class="string">'w'</span> &amp;&amp; dfs(graph, visited ,i, color) == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;graph, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &amp;visited, <span class="keyword">int</span> index, <span class="keyword">char</span> color)</span> </span>&#123;</span><br><span class="line">    visited[index] = color;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; graph[index].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = graph[index][i];</span><br><span class="line">        <span class="keyword">if</span> ((visited[j] == <span class="string">'w'</span> &amp;&amp; !dfs(graph, visited, j, ~color)) || visited[j] == color)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Is Graph Bipartite?</title>
      <link href="/2019/11/25/Is-Graph-Bipartite/"/>
      <url>/2019/11/25/Is-Graph-Bipartite/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第21天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/is-graph-bipartite/" target="_blank" rel="noopener">  Is Graph Bipartite? </a>：</p><hr><p>Given an undirected <code>graph</code>, return <code>true</code> if and only if it is bipartite.</p><p>Recall that a graph is <em>bipartite</em> if we can split it’s set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.</p><p>The graph is given in the following form: <code>graph[i]</code> is a list of indexes <code>j</code> for which the edge between nodes <code>i</code> and <code>j</code> exists. Each node is an integer between <code>0</code> and <code>graph.length - 1</code>. There are no self edges or parallel edges: <code>graph[i]</code> does not contain <code>i</code>, and it doesn’t contain any element twice.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [[1,3], [0,2], [1,3], [0,2]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: </span><br><span class="line">The graph looks like this:</span><br><span class="line">0----1</span><br><span class="line">|    |</span><br><span class="line">|    |</span><br><span class="line">3----2</span><br><span class="line">We can divide the vertices into two groups: &#123;0, 2&#125; and &#123;1, 3&#125;.</span><br><span class="line">Example 2:</span><br><span class="line">Input: [[1,2,3], [0,2], [0,1,3], [0,2]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: </span><br><span class="line">The graph looks like this:</span><br><span class="line">0----1</span><br><span class="line">| \  |</span><br><span class="line">|  \ |</span><br><span class="line">3----2</span><br><span class="line">We cannot find a way to divide the set of nodes into two independent subsets.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><code>graph</code> will have length in range <code>[1, 100]</code>.</li><li><code>graph[i]</code> will contain integers in range <code>[0, graph.length - 1]</code>.</li><li><code>graph[i]</code> will not contain <code>i</code> or duplicate values.</li><li>The graph is undirected: if any element <code>j</code> is in <code>graph[i]</code>, then <code>i</code> will be in <code>graph[j]</code>.</li></ul><hr><p>这是一道关于图的问题，题目的意思很简单，就是要判断一个图是不是一个二部图，所谓的二部图，就是一个图可以把所有节点划分到两个不相交的两个集合，这两个集合内部没有边相连。</p><p>我们可以对图进行一次遍历，遍历的时候对节点进行着色，着色的规律是这样的，当从一个节点跳到另一个节点的时候，我们就切换一次颜色（共有三种颜色，其中一种表示没有访问，即白色）。因为遍历完了之后，整个图的节点就被划分成两部分了，接下来我们只需要判断所有节点的邻居是否和它是不同色的即可。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> color;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBipartite</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = graph.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; <span class="title">flags</span><span class="params">(<span class="built_in">size</span>, <span class="string">'w'</span>)</span></span>;</span><br><span class="line">    <span class="comment">// w g b</span></span><br><span class="line">    color = <span class="string">'b'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="built_in">size</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flags[i] == <span class="string">'w'</span>) &#123;</span><br><span class="line">            dfs(graph, flags, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="built_in">size</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j: graph[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flags[i] == flags[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;graph, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &amp;flags, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    flags[index] = color;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> j: graph[index]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flags[j] == <span class="string">'w'</span>) &#123;</span><br><span class="line">            color = ~color;</span><br><span class="line">            dfs(graph, flags, j);</span><br><span class="line">            color = ~color;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Minimum Moves to Equal Array Elements II</title>
      <link href="/2019/11/24/Minimum-Moves-to-Equal-Array-Elements-II/"/>
      <url>/2019/11/24/Minimum-Moves-to-Equal-Array-Elements-II/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第20天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/" target="_blank" rel="noopener"> Minimum Moves to Equal Array Elements II </a>：</p><hr><p>Given a <strong>non-empty</strong> integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1.</p><p>You may assume the array’s length is at most 10,000.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[1,2,3]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Only two moves are needed (remember each move increments or decrements one element):</span><br><span class="line"></span><br><span class="line">[1,2,3]  &#x3D;&gt;  [2,2,3]  &#x3D;&gt;  [2,2,2]</span><br></pre></td></tr></table></figure><hr><p>这道题需要一些数学推导，它的目标就是：</p><p>$$<br>min_k { \sum_{i=1}^n |n_i - n_k| }<br>$$<br>其中 $n_i$ 表示数组排序后中第 $i$ 个元素。</p><p>我们将式子展开可以得到：<br>$$<br>min_k { \sum_{i=1}^n |n_i - n_k| } = </p><p>min_k { \sum_{i=1}^k (n_k-n_i) + \sum_{i=k+1}^n(n_i-n_k) } \</p><p>= min_k { \sum_{i=1}^k n_k - \sum_{i=1}^k n_i + \sum_{i=k+1}^n n_i - \sum_{i=k+1}^n n_k  } \</p><p>= min_k { \sum_{i=k+1}^n n_i - \sum_{i=1}^k n_i + (2k - n)n_k  }<br>$$<br>因此，我们可以写出如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minMoves2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = LONG_MAX;</span><br><span class="line">    sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> rightSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i: nums) rightSum += i;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> leftSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++i) &#123;</span><br><span class="line">        res = <span class="built_in">min</span>(res, rightSum - leftSum + (<span class="number">2</span>*i - n) * (<span class="keyword">long</span> <span class="keyword">long</span>)nums[i]);</span><br><span class="line">        rightSum -= nums[i];</span><br><span class="line">        leftSum += nums[i];</span><br><span class="line">        <span class="comment">// cout &lt;&lt; res &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样还不是最优解，然而最优解我没看懂（捂脸），为什么用中位数求就是对的呢？：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minMoves2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">    sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        </span><br><span class="line">        mid = (nums[nums.<span class="built_in">size</span>()/<span class="number">2</span>] + nums[(nums.<span class="built_in">size</span>()/<span class="number">2</span>) - <span class="number">1</span>])/<span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        </span><br><span class="line">        mid = nums[nums.<span class="built_in">size</span>()/<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        </span><br><span class="line">        result += <span class="built_in">abs</span>(nums[i] - mid);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>N-ary Tree Level Order Traversal</title>
      <link href="/2019/11/23/N-ary-Tree-Level-Order-Traversal/"/>
      <url>/2019/11/23/N-ary-Tree-Level-Order-Traversal/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第19天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener"> N-ary Tree Level Order Traversal </a>:</p><hr><p>Given an n-ary tree, return the <em>level order</em> traversal of its nodes’ values.</p><p><em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,null,3,2,4,null,5,6]</span><br><span class="line">Output: [[1],[3,2,4],[5,6]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]</span><br><span class="line">Output: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The height of the n-ary tree is less than or equal to <code>1000</code></li><li>The total number of nodes is between <code>[0, 10^4]</code></li></ul><hr><p>一道水题，简单的<code>BFS</code>或<code>DFS</code>即可，除了是一个多叉树外，和另外一道题基本是一样的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node*&gt; children;</span><br><span class="line"></span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> _val, <span class="built_in">vector</span>&lt;Node*&gt; _children) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以，我们既可以用队列去做层次遍历(BFS)，也可以用递归来实现DFS，然后按当前节点所在的高度插入到对于的数组即可：</p><ol><li>DFS</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    dfsWithHeight(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfsWithHeight</span><span class="params">(Node *root, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (h == res.<span class="built_in">size</span>()) res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    res[h].push_back(root-&gt;val);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; root-&gt;children.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        dfsWithHeight(root-&gt;children[i], h + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>BFS</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder2</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node *&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    q.push(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>() != <span class="number">1</span>) &#123;</span><br><span class="line">        vec.<span class="built_in">clear</span>();</span><br><span class="line">        root = q.front();</span><br><span class="line">        <span class="keyword">while</span>(root) &#123;</span><br><span class="line">            q.pop();</span><br><span class="line">            vec.push_back(root-&gt;val);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; root-&gt;val &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; root-&gt;children.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                q.push(root-&gt;children[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            root = q.front();</span><br><span class="line">        &#125;</span><br><span class="line">        q.pop();</span><br><span class="line">        q.push(<span class="literal">nullptr</span>);</span><br><span class="line">        res.push_back(vec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder1</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node *&gt; nodes;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node *&gt; nextLevelNodes;</span><br><span class="line">    nodes.push_back(root);</span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty()) &#123;</span><br><span class="line">        vec.<span class="built_in">clear</span>();</span><br><span class="line">        nextLevelNodes.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nodes.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            vec.push_back(nodes[i]-&gt;val);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; nodes[i]-&gt;children.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                nextLevelNodes.push_back(nodes[i]-&gt;children[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nodes, nextLevelNodes);</span><br><span class="line">        res.push_back(vec);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>All Possible Full Binary Trees</title>
      <link href="/2019/11/22/All-Possible-Full-Binary-Trees/"/>
      <url>/2019/11/22/All-Possible-Full-Binary-Trees/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第18天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/all-possible-full-binary-trees/" target="_blank" rel="noopener"> All Possible Full Binary Trees </a>:</p><hr><p>A <em>full binary tree</em> is a binary tree where each node has exactly 0 or 2 children.</p><p>Return a list of all possible full binary trees with <code>N</code> nodes. Each element of the answer is the root node of one possible tree.</p><p>Each <code>node</code> of each tree in the answer <strong>must</strong> have <code>node.val = 0</code>.</p><p>You may return the final list of trees in any order.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 7</span><br><span class="line">Output: [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]</span><br><span class="line">Explanation:</span><br></pre></td></tr></table></figure><p> <img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/22/fivetrees.png" alt=""></p><p><strong>Note:</strong></p><ul><li><code>1 &lt;= N &lt;= 20</code></li></ul><hr><p>这道题就是一个穷举的问题，我们知道完全二叉树的节点个数一定是奇数，所以可以先把<code>N</code>为偶数的输入先处理掉，然后就是怎么穷举的问题了。显然，一个完全二叉树的子树一定也是完全二叉树，所以我们可以以<code>1,3,5...,N-2</code>的方式穷举出出左子树中节点的个数<code>i</code>，已知左子树节点个数，那么右子树节点的个数就为<code>N-i-1</code>,我们先把左子树和右子树的可能都算出来，然后就再计算它们两两组合的所有可能即可得到所有节点个数为<code>N</code>的完全二叉树的情况。总的来说，就是一个大问题化简成小问题的思路。所以我们可以写出如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">copyTree</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode *res = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">    res-&gt;left = copyTree(root-&gt;left);</span><br><span class="line">    res-&gt;right = copyTree(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">allPossibleFBT</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; res;   </span><br><span class="line">    <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;TreeNode*&gt;&gt; <span class="title">dp</span><span class="params">(N+<span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">1</span>].push_back(<span class="keyword">new</span> TreeNode(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; dp.<span class="built_in">size</span>();i+=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// dp[i];</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; i;j+=<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; &amp;left = dp[j];</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; &amp;right = dp[(i-j<span class="number">-1</span>)];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;l: left) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;r: right) &#123;</span><br><span class="line">                    TreeNode *node = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">                    node-&gt;left = copyTree(l);</span><br><span class="line">                    node-&gt;right = copyTree(r);</span><br><span class="line">                    dp[i].push_back(node);        </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你会发现好像可以用一个数组来存在已经求解出来的结果，如果再一次求，我们可以直接返回了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; &amp;<span class="title">allPossibleFBT</span><span class="params">(<span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;TreeNode*&gt;&gt; &amp;cache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache[N].<span class="built_in">size</span>() != <span class="number">0</span>) <span class="keyword">return</span> cache[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; N;i++) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; &amp;left = allPossibleFBT(i, cache);</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; &amp;right = allPossibleFBT(N - i - <span class="number">1</span>, cache);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> l: left) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> r: right) &#123;</span><br><span class="line">                TreeNode *node = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">                node-&gt;left = l;</span><br><span class="line">                node-&gt;right = r;</span><br><span class="line">                cache[N].push_back(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache[N];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">allPossibleFBT</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; res;   </span><br><span class="line">    <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;TreeNode*&gt;&gt; <span class="title">cache</span><span class="params">(<span class="number">21</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    cache[<span class="number">1</span>].push_back(<span class="keyword">new</span> TreeNode(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> allPossibleFBT(N, cache);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果熟悉动态规划的话，就会发现可以自顶向下的求解方式转成自底向上的求解方式，这里我们就不需要用递归去求解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">allPossibleFBT</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; res;   </span><br><span class="line">    <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;TreeNode*&gt;&gt; <span class="title">dp</span><span class="params">(N+<span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">1</span>].push_back(<span class="keyword">new</span> TreeNode(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; dp.<span class="built_in">size</span>();i+=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// dp[i];</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; i;j+=<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> l: dp[j]) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> r: dp[i-j<span class="number">-1</span>]) &#123;</span><br><span class="line">                    TreeNode *node = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">                    node-&gt;left = copyTree(l);</span><br><span class="line">                    node-&gt;right = copyTree(r);</span><br><span class="line">                    dp[i].push_back(node);        </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，这份代码在<code>LeetCode</code>大概只能超过50%，如果要进一步，只有把<code>copyTree</code>去掉，直接赋值。这种方式是可行的，但是感觉只是在刷题时的一种技巧而已：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">allPossibleFBT</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; res;   </span><br><span class="line">    <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;TreeNode*&gt;&gt; <span class="title">dp</span><span class="params">(N+<span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">1</span>].push_back(<span class="keyword">new</span> TreeNode(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; dp.<span class="built_in">size</span>();i+=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// dp[i];</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; i;j+=<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> l: dp[j]) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> r: dp[i-j<span class="number">-1</span>]) &#123;</span><br><span class="line">                    TreeNode *node = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">                    node-&gt;left = l;<span class="comment">//copyTree(l);</span></span><br><span class="line">                    node-&gt;right = r;<span class="comment">//copyTree(r);</span></span><br><span class="line">                    dp[i].push_back(node);        </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kth Smallest Element in a BST</title>
      <link href="/2019/11/21/Kth-Smallest-Element-in-a-BST/"/>
      <url>/2019/11/21/Kth-Smallest-Element-in-a-BST/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第17天，又是一道之前没做出来的题目，然而好像并不难啊。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener"> Kth Smallest Element in a BST </a>:</p><hr><p>Given a binary search tree, write a function <code>kthSmallest</code> to find the <strong>k</strong>th smallest element in it.</p><p><strong>Note:</strong><br>You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">       5</span><br><span class="line">      &#x2F; \</span><br><span class="line">     3   6</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   4</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Follow up:</strong><br>What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?</p><hr><p>题意很简单就是求BST中第k小的数字，然后BST本身就包含一定的顺序信息，利用BST中序遍历是有序的性质，我们可以很快的把这道题写出来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    kthSmallestR(root, k);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">kthSmallestR</span><span class="params">(TreeNode *root, <span class="keyword">int</span> &amp;k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; root &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kthSmallestR(root-&gt;left, k)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; root-&gt;val &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">if</span> ((--k) == <span class="number">0</span>) &#123;</span><br><span class="line">        res = root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> kthSmallestR(root-&gt;right, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们可以写出非递归版本的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode *&gt; st;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(root || !st.empty()) &#123;</span><br><span class="line">        <span class="keyword">while</span>(root) &#123;</span><br><span class="line">            st.push(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (st.empty()) <span class="keyword">break</span>;</span><br><span class="line">        root = st.top(); st.pop();</span><br><span class="line">        <span class="keyword">if</span> (--k == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root) <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BTW，这道题的测试有点不稳定，同一个代码会测试出不同的时间。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Triangle</title>
      <link href="/2019/11/20/Triangle/"/>
      <url>/2019/11/20/Triangle/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第16天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/triangle/" target="_blank" rel="noopener"> Triangle </a>：</p><hr><p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p><p>For example, given the following triangle</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>The minimum path sum from top to bottom is <code>11</code> (i.e., <strong>2</strong> + <strong>3</strong> + <strong>5</strong> + <strong>1</strong> = 11).</p><p><strong>Note:</strong></p><p>Bonus point if you are able to do this using only <em>O</em>(<em>n</em>) extra space, where <em>n</em> is the total number of rows in the triangle.</p><hr><p>一道很常规的动态规划问题。</p><p>虽然例子中画出来的数组看起来很难确定路径，但是如果把它规整一下就可以得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3 4</span><br><span class="line">6 5 7</span><br><span class="line">4 1 8 3</span><br></pre></td></tr></table></figure><p>因此对于位置<code>(i,j)</code>来说，到达它的路径一定经过上一层的<code>(i-1, j)</code>和<code>(i-1,j-1)</code>（注意其实triangle中必须保证<code>0&lt;=j&lt;=i</code>，那个位置才会有值)。</p><p>所以我们可以写出动态规划方程：</p><p>$$<br>dp[i, j]=min{dp[i-1, j], dp[i-1, j-1] } + triangle[i][j]<br>$$</p><p>其中<code>dp[i,j]</code>表示从顶端出发到达第<code>i</code>层第<code>j</code>个位置的最短路径的距离。其中<code>dp[0,0]=triangle[0]</code>以及<code>dp[i,j]=INT_MAX,i&lt;j</code>，根据动态规划方程我们可以很容易的写出代码，同时为了使得空间复杂度为<code>O(n)</code>，我们可以只使用一个长度为<code>n</code>的数组来保存，之所以能做到是因为<code>d[i, *]</code>只依赖于<code>d[i-1, *]</code>，进一步的说，它只依赖于<code>d[i-1, *-1]</code>和<code>d[i-1, *]</code>，所以可以很容易改成一个用一个一维数组实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = triangle.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, INT_MAX)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &gt;= <span class="number">0</span>;j--) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">min</span>(dp[j], j&gt;<span class="number">0</span>?dp[j<span class="number">-1</span>]:INT_MAX) + triangle[i][j];</span><br><span class="line">            <span class="comment">// cout &lt;&lt; dp[j] &lt;&lt; " ";</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) res = <span class="built_in">min</span>(res, dp[i]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Advantage Shuffle</title>
      <link href="/2019/11/19/Advantage-Shuffle/"/>
      <url>/2019/11/19/Advantage-Shuffle/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第15天。emmm，这就半个月了？？</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/advantage-shuffle/" target="_blank" rel="noopener"> Advantage Shuffle </a>:</p><hr><p>Given two arrays <code>A</code> and <code>B</code> of equal size, the <em>advantage of <code>A</code> with respect to <code>B</code></em> is the number of indices <code>i</code> for which <code>A[i] &gt; B[i]</code>.</p><p>Return <strong>any</strong> permutation of <code>A</code> that maximizes its advantage with respect to <code>B</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A &#x3D; [2,7,11,15], B &#x3D; [1,10,4,11]</span><br><span class="line">Output: [2,11,7,15]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A &#x3D; [12,24,8,32], B &#x3D; [13,25,32,11]</span><br><span class="line">Output: [24,32,8,12]</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><code>1 &lt;= A.length = B.length &lt;= 10000</code></li><li><code>0 &lt;= A[i] &lt;= 10^9</code></li><li><code>0 &lt;= B[i] &lt;= 10^9</code></li></ol><hr><p>这道题就是个贪心的思路，确保每个位置上，<code>A[i]</code>的值要么是<code>A</code>中第一个比<code>B[i]</code>大，要么是最小能用的值，这就涉及到了怎么找到第一个比<code>B[i]</code>大的值的问题了，我们可以二叉查找树来实现，这里用STL中的<code>multiset</code>即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">advantageCount1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; <span class="title">S</span><span class="params">(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>())</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; B.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = S.upper_bound(B[i]);</span><br><span class="line">        <span class="keyword">if</span> (it == S.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            it = S.<span class="built_in">begin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        A[i] = *it;</span><br><span class="line">        S.erase(it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法虽然可以AC，但是时间效率不高，所以我们可以用排序的方法来代替二叉查找树，我们按B从大到小的顺序来填A的值，这样如果A中当前能用的最大值比<code>B[i]</code>要大，那么<code>A[i]</code>为A中当前能用的最大值，否则为A中当前能用的最小值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">advantageCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(A.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">    vector&lt;pair&lt;int, int&gt;&gt; val2index(A.size());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; val2index.<span class="built_in">size</span>(); i++) val2index[i] = make_pair(B[i], i);</span><br><span class="line">    sort(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());</span><br><span class="line">    sort(val2index.<span class="built_in">begin</span>(), val2index.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">0</span>, last = A.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val2index[i].first &gt;= A[last]) &#123;</span><br><span class="line">            res[val2index[i].second] = A[first++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res[val2index[i].second] = A[last--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Delete Nodes And Return Forest</title>
      <link href="/2019/11/18/Delete-Nodes-And-Return-Forest/"/>
      <url>/2019/11/18/Delete-Nodes-And-Return-Forest/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第14天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/delete-nodes-and-return-forest/" target="_blank" rel="noopener">Delete Nodes And Return Forest</a>：</p><hr><p>Given the <code>root</code> of a binary tree, each node in the tree has a distinct value.</p><p>After deleting all nodes with a value in <code>to_delete</code>, we are left with a forest (a disjoint union of trees).</p><p>Return the roots of the trees in the remaining forest. You may return the result in any order.</p><p><strong>Example 1:</strong></p><p><strong><img src="https://assets.leetcode.com/uploads/2019/07/01/screen-shot-2019-07-01-at-53836-pm.png" alt="img"></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3,4,5,6,7], to_delete &#x3D; [3,5]</span><br><span class="line">Output: [[1,2,null,4],[6],[7]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the given tree is at most <code>1000</code>.</li><li>Each node has a distinct value between <code>1</code> and <code>1000</code>.</li><li><code>to_delete.length &lt;= 1000</code></li><li><code>to_delete</code> contains distinct values between <code>1</code> and <code>1000</code>.</li></ul><hr><p>这道题的题意很简单，就是要通过删节点来把分割树，关键的问题是，删除一个节点既需要对子节点进行处理，还要在父节点中删除对应的指针，为了方便，我们这里采用后续遍历的方法来实现：</p><p>先递归调用函数，使得子树中的节点已经完成遍历和删除，然后通过返回值来判断该子节点是否需要删除，如果需要删除，则将对于的指针置空。然后在判断当前节点是否需要删除，就将非空的子节点插入到返回数组中（全局变量）。</p><p>还有一点就是，因为节点的值在<code>1-1000</code>间，所以我们可以用一个长度为1000的数组来加快对要删除节点的判断。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;TreeNode *&gt; res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">delNodes</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; to_delete)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">delmap</span><span class="params">(<span class="number">1001</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; to_delete.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        delmap[to_delete[i]] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!toDelNodes(root, delmap)) &#123;</span><br><span class="line">        res.push_back(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">toDelNodes</span><span class="params">(TreeNode *root, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; delmap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (toDelNodes(root-&gt;left, delmap)) &#123;</span><br><span class="line">        root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (toDelNodes(root-&gt;right, delmap)) &#123;</span><br><span class="line">        root-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (delmap[root-&gt;val]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) res.push_back(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) res.push_back(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Boats to Save People</title>
      <link href="/2019/11/17/Boats-to-Save-People/"/>
      <url>/2019/11/17/Boats-to-Save-People/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第13天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/boats-to-save-people/" target="_blank" rel="noopener"> Boats to Save People </a>:</p><hr><p>The <code>i</code>-th person has weight <code>people[i]</code>, and each boat can carry a maximum weight of <code>limit</code>.</p><p>Each boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most <code>limit</code>.</p><p>Return the minimum number of boats to carry every given person. (It is guaranteed each person can be carried by a boat.)</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: people &#x3D; [1,2], limit &#x3D; 3</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: 1 boat (1, 2)</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: people &#x3D; [3,2,2,1], limit &#x3D; 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 3 boats (1, 2), (2) and (3)</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: people &#x3D; [3,5,3,4], limit &#x3D; 5</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: 4 boats (3), (3), (4), (5)</span><br></pre></td></tr></table></figure><p><strong>Note</strong>:</p><ul><li><code>1 &lt;= people.length &lt;= 50000</code></li><li><code>1 &lt;= people[i] &lt;= limit &lt;= 30000</code></li></ul><hr><p>一道贪心的题目，仔细分析下题目就会发现，如果一个<code>weight</code>比较大的人要坐船，一定是和<code>weight</code>小的人坐船，才能保证做的船数最少。因此，只要先排序，然后在双指针判断是否能做两个人即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numRescueBoats1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; people, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">    sort(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = people.<span class="built_in">size</span>() <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">        res += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (limit &gt;= people[i] + people[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Diagonal Traverse</title>
      <link href="/2019/11/16/Diagonal-Traverse/"/>
      <url>/2019/11/16/Diagonal-Traverse/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第12天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/diagonal-traverse/" target="_blank" rel="noopener">Diagonal Traverse</a>：</p><hr><p>Given a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 4, 5, 6 ],</span><br><span class="line"> [ 7, 8, 9 ]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Output:  [1,2,4,7,5,3,6,8,9]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br></pre></td></tr></table></figure><p> <img src="https://assets.leetcode.com/uploads/2018/10/12/diagonal_traverse.png" alt=""></p><p><strong>Note:</strong></p><p>The total number of elements of the given matrix will not exceed 10,000.</p><hr><p>这道题好像是之前没做出来的。</p><p>题意很好理解，这道题的关键就在于如何处理在边界时的移动。</p><p>首先，常规的移动就分为两种：</p><ul><li>向右上移动</li><li>向左下移动</li></ul><p>实现常规移动，这里就不赘述了。</p><p>然后就是在边界时如何移动了，经过观察移动的情况，我们可以总结出：</p><ul><li>边界时，只有向右移动和向下移动两种情况</li><li>在向右上移动时遇到边界，优先向右移动</li><li>在向左下移动时遇到边界，优先向左移动</li></ul><p>根据上面的结论，我们就可以写出代码了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">nextRightUp</span><span class="params">(<span class="keyword">int</span> &amp;i, <span class="keyword">int</span> &amp;j, <span class="keyword">int</span> &amp;m, <span class="keyword">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; j + <span class="number">1</span> &lt; n) &#123; <span class="comment">// move right up</span></span><br><span class="line">        i--; j++; <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j + <span class="number">1</span> &lt; n) &#123; <span class="comment">// move right</span></span><br><span class="line">        j++; <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i  + <span class="number">1</span> &lt; m)&#123; <span class="comment">// move down</span></span><br><span class="line">        i++; <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// mean in the last elem</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">nextLeftDown</span><span class="params">(<span class="keyword">int</span> &amp;i, <span class="keyword">int</span> &amp;j, <span class="keyword">int</span> &amp;m, <span class="keyword">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span> &lt; m &amp;&amp; j <span class="number">-1</span> &gt;= <span class="number">0</span>) &#123; <span class="comment">// move right up</span></span><br><span class="line">        i++; j--; <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i + <span class="number">1</span> &lt; m) &#123; <span class="comment">// move down </span></span><br><span class="line">        i++; <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j + <span class="number">1</span>  &lt; n) &#123; <span class="comment">// move right</span></span><br><span class="line">        j++; <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDiagonalOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> up = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; m*n;k++) &#123;</span><br><span class="line">        res.push_back(matrix[i][j]);</span><br><span class="line">        <span class="keyword">if</span> (up) &#123;</span><br><span class="line">            up = nextRightUp(i, j, m, n);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            up = !nextLeftDown(i, j, m, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Keys and Rooms</title>
      <link href="/2019/11/15/Keys-and-Rooms/"/>
      <url>/2019/11/15/Keys-and-Rooms/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第11天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/keys-and-rooms/" target="_blank" rel="noopener">Keys and Rooms</a>：</p><hr><p>There are <code>N</code> rooms and you start in room <code>0</code>. Each room has a distinct number in <code>0, 1, 2, ..., N-1</code>, and each room may have some keys to access the next room. </p><p>Formally, each room <code>i</code> has a list of keys <code>rooms[i]</code>, and each key <code>rooms[i][j]</code> is an integer in <code>[0, 1, ..., N-1]</code> where <code>N = rooms.length</code>. A key <code>rooms[i][j] = v</code> opens the room with number <code>v</code>.</p><p>Initially, all the rooms start locked (except for room <code>0</code>). </p><p>You can walk back and forth between rooms freely.</p><p>Return <code>true</code> if and only if you can enter every room.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1],[2],[3],[]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation:  </span><br><span class="line">We start in room 0, and pick up key 1.</span><br><span class="line">We then go to room 1, and pick up key 2.</span><br><span class="line">We then go to room 2, and pick up key 3.</span><br><span class="line">We then go to room 3.  Since we were able to go to every room, we return true.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,3],[3,0,1],[2],[0]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: We can&#39;t enter the room with number 2.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><code>1 &lt;= rooms.length &lt;= 1000</code></li><li><code>0 &lt;= rooms[i].length &lt;= 1000</code></li><li>The number of keys in all rooms combined is at most <code>3000</code>.</li></ol><hr><p>很简单的一道题，仔细分析一下题目的话，就会发现这个输入其实构成一张图，<code>rooms[i]</code>表示从第<code>i</code>个节点出发走向的节点列表。然后这个问题就转变成，从<code>0</code>号节点出发，能不能遍历完所有节点的问题了，这个问题直接无脑<code>dfs</code>就好了，实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canVisitAllRooms</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(rooms.<span class="built_in">size</span>(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">    dfs(rooms, visited, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; visited.<span class="built_in">size</span>(); ++i) &#123; </span><br><span class="line">        <span class="keyword">if</span> (visited[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;visited, <span class="keyword">int</span> index = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    visited[index] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rooms[index].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[rooms[index][i]] == <span class="literal">false</span>) &#123;</span><br><span class="line">            dfs(rooms, visited, rooms[index][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Populating Next Right Pointers in Each Node II</title>
      <link href="/2019/11/14/Populating-Next-Right-Pointers-in-Each-Node-II/"/>
      <url>/2019/11/14/Populating-Next-Right-Pointers-in-Each-Node-II/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第10天了。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener"> 117. Populating Next Right Pointers in Each Node II </a>：</p><hr><p>Given a binary tree</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p><p>Initially, all next pointers are set to <code>NULL</code>.</p><p><img src="https://assets.leetcode.com/uploads/2019/02/15/117_sample.png" alt=""></p><p> <strong>Example:</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;val&quot;:3&#125;,&quot;val&quot;:1&#125;</span><br><span class="line"></span><br><span class="line">Output: &#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;5&quot;&#125;,&quot;val&quot;:3&#125;,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;4&quot;&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;6&quot;&#125;,&quot;val&quot;:1&#125;</span><br><span class="line"></span><br><span class="line">Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li>You may only use constant extra space.</li><li>Recursive approach is fine, implicit stack space does not count as extra space for this problem.</li></ul><hr><p>这是一道之前没做出来的问题，最开始想出来的解法也和之前差不多，大概的想法是递归求解时返回子树的最左和最右节点，然后通过一些判断来相连，但是这个问题主要是没法处理两个子树高度不一样的问题。</p><p>后面尝试用分治的方法来做，主要的想法是，假设我现在已经有了连接好的左子树和右子树，现在只需要将两个子树连接起来即可。而连接方法就是一层一层的去连接两个子树：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">nextLayer</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">        root = root-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connectLeftRight</span><span class="params">(Node *left, Node *right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// level 1</span></span><br><span class="line">    Node *pl, *pr;</span><br><span class="line">    <span class="keyword">while</span>(left &amp;&amp; right) &#123;</span><br><span class="line">        pl = left;</span><br><span class="line">        pr = right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// next layer</span></span><br><span class="line">        left = nextLayer(left);</span><br><span class="line">        right = nextLayer(right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// connect left and right tree in this layer</span></span><br><span class="line">        <span class="keyword">while</span>(pl-&gt;next) pl = pl-&gt;next;</span><br><span class="line">        pl-&gt;next = pr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">connect1</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    Node *left = connect1(root-&gt;left);</span><br><span class="line">    Node *right = connect1(root-&gt;right);</span><br><span class="line">    connectLeftRight(left, right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的时间复杂度大概是<code>O(h^2)</code>，其中<code>h</code>是树的高度。</p><p>后面又发现一种方法，这种方法大概的思路是连接孩子，然后在递归求解。这样会保证在求解到<code>root</code>节点时，<code>root</code>节点的<code>next</code>是已知的，同时在连接孩子时，需要利用到右子树的<code>next</code>指针，所以需要先求解右子树再求解左子树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connectChild</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) root-&gt;left-&gt;next = root-&gt;right;</span><br><span class="line">        <span class="keyword">else</span> root-&gt;left-&gt;next = helper(root-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">        root-&gt;right-&gt;next = helper(root-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">helper</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left) <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right) <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> helper(root-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">connect2</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root ==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>; </span><br><span class="line">    connectChild(root);</span><br><span class="line">    <span class="comment">// 先求右边的。</span></span><br><span class="line">    connect2(root-&gt;right);</span><br><span class="line">    connect3(root-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Next Greater Element III</title>
      <link href="/2019/11/13/Next-Greater-Element-III/"/>
      <url>/2019/11/13/Next-Greater-Element-III/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第9天了。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/next-greater-element-iii/" target="_blank" rel="noopener"> Next Greater Element III </a>:</p><hr><p>Given a positive <strong>32-bit</strong> integer <strong>n</strong>, you need to find the smallest <strong>32-bit</strong> integer which has exactly the same digits existing in the integer <strong>n</strong> and is greater in value than n. If no such positive <strong>32-bit</strong> integer exists, you need to return -1.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 12</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 21</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><hr><p>这道题我的解法是：</p><ol><li>先将数字转换成数组，由于是除法和取余解析出来的数组，所以整个数组是倒过来的，即<code>123</code>得到<code>[3,2,1]</code></li><li>从前向后遍历找到第一个逆序（即<code>vec[i-1] &gt; vec[i</code>)的情况。</li><li>从<code>vec[0: i]</code>找到第一个小于等于<code>vec[i]</code>的元素<code>vec[j]</code>。</li><li>交换<code>vec[i]</code>和<code>vec[j]</code>，然后将<code>vec[0: i]</code>逆序。</li><li>将<code>vec</code>转换回数字，最后判断一下是否溢出即可。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nextGreaterElement</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">while</span>(n) &#123;</span><br><span class="line">        vec.push_back(n % <span class="number">10</span>);</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt; vec.<span class="built_in">size</span>() &amp;&amp; vec[i<span class="number">-1</span>] &lt;= vec[i] ;++i) &#123;   </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == vec.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>;vec[i] &gt;= vec[j];++j) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    swap(vec[i], vec[j]);</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>, i = i - <span class="number">1</span>; j &lt; i; j++, i--) &#123;</span><br><span class="line">        swap(vec[i], vec[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = vec.<span class="built_in">size</span>() <span class="number">-1</span>;i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">        res = res * <span class="number">10</span> + vec[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res &gt; INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实写到这里基本上发现，这道题就是找全排列中的下一个元素，而这个功能，在C++中提供了一个好用的函数：<code>next_permutation</code>，所以我们可以先用<code>to_string</code>转换成字符数组，然后用<code>next_permutation</code>来解这道题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nextGreaterElement</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = to_string(n);</span><br><span class="line">    <span class="keyword">if</span> (next_permutation(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>())) &#123;</span><br><span class="line">        <span class="keyword">long</span> temp = atol(s.c_str());</span><br><span class="line">        <span class="keyword">if</span> (temp &lt;= INT_MAX)  <span class="keyword">return</span> temp;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Replace Words</title>
      <link href="/2019/11/12/Replace-Words/"/>
      <url>/2019/11/12/Replace-Words/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第8天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/replace-words/" target="_blank" rel="noopener"> Replace Words </a></p><hr><p>In English, we have a concept called <code>root</code>, which can be followed by some other words to form another longer word - let’s call this word <code>successor</code>. For example, the root <code>an</code>, followed by <code>other</code>, which can form another word <code>another</code>.</p><p>Now, given a dictionary consisting of many roots and a sentence. You need to replace all the <code>successor</code> in the sentence with the <code>root</code> forming it. If a <code>successor</code> has many <code>roots</code> can form it, replace it with the root with the shortest length.</p><p>You need to output the sentence after the replacement.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: dict &#x3D; [&quot;cat&quot;, &quot;bat&quot;, &quot;rat&quot;]</span><br><span class="line">sentence &#x3D; &quot;the cattle was rattled by the battery&quot;</span><br><span class="line">Output: &quot;the cat was rat by the bat&quot;</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The input will only have lower-case letters.</li><li>1 &lt;= dict words number &lt;= 1000</li><li>1 &lt;= sentence words number &lt;= 1000</li><li>1 &lt;= root length &lt;= 100</li><li>1 &lt;= sentence words length &lt;= 1000</li></ol><hr><p>看到题目给出了一个字符串字典，然后要根据单词中是否包含字典中的前缀来生成结果，想都不用想，就是用前缀树/字典树来做，关于前缀树的介绍可以看 <a href="https://oi-wiki.org/string/trie/" target="_blank" rel="noopener">https://oi-wiki.org/string/trie/</a> 。</p><p>首先先根据字典建立字典树，然后根据空格分隔单词，然后检查是否有前缀，如果没有前缀就将原始的单词插入结果中，如果有，则将前缀插入。由于在进行检查时，每次从一个节点跳到其子节点时都会检查者是否是一个在词典出现的前缀，所以所求的前缀一定是最短的。</p><p>具体代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">childs</span>[26];</span></span><br><span class="line">    <span class="keyword">bool</span> isLeaf;</span><br><span class="line">    Node():isLeaf(<span class="literal">false</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++) childs[i] = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Node() &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++) <span class="keyword">if</span> (childs[i]) <span class="keyword">delete</span> childs[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(struct Node *root, <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, <span class="built_in">size</span> = s.<span class="built_in">size</span>(); i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = s[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;childs[index] == <span class="literal">nullptr</span>) root-&gt;childs[index] = <span class="keyword">new</span> Node;</span><br><span class="line">        root = root-&gt;childs[index];</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;isLeaf = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMinLen</span><span class="params">(struct Node *root, <span class="built_in">string</span> &amp;sentence, <span class="keyword">int</span> beg, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = beg;i &lt; <span class="built_in">end</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = sentence[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;childs[index] == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="built_in">end</span>;</span><br><span class="line">        root = root-&gt;childs[index];</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;isLeaf) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">end</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">replaceWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; dict, <span class="built_in">string</span> sentence)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// sort(dict.begin(), dict.end());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// build dict tree</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">root</span> = <span class="title">new</span> <span class="title">Node</span>();</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; dict.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        insert(root, dict[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">p</span> = <span class="title">root</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// parse sentence</span></span><br><span class="line">    <span class="built_in">string</span> res, <span class="keyword">word</span>;</span><br><span class="line">    <span class="keyword">int</span> beg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, <span class="built_in">size</span> = sentence.<span class="built_in">size</span>(); i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sentence[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">end</span> = getMinLen(root, sentence, beg, i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = beg;j &lt; <span class="built_in">end</span>; j++) res.push_back(sentence[j]);</span><br><span class="line">            res.push_back(<span class="string">' '</span>);</span><br><span class="line">            beg = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">word</span> = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span> = getMinLen(root, sentence, beg, sentence.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = beg;j &lt; <span class="built_in">end</span>; j++) res.push_back(sentence[j]);</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sort Characters By Frequency</title>
      <link href="/2019/11/11/Sort-Characters-By-Frequency/"/>
      <url>/2019/11/11/Sort-Characters-By-Frequency/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第7天了</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/sort-characters-by-frequency/" target="_blank" rel="noopener"> Sort Characters By Frequency </a>:</p><hr><p>Given a string, sort it in decreasing order based on the frequency of characters.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;tree&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;eert&quot;</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">&#39;e&#39; appears twice while &#39;r&#39; and &#39;t&#39; both appear once.</span><br><span class="line">So &#39;e&#39; must appear before both &#39;r&#39; and &#39;t&#39;. Therefore &quot;eetr&quot; is also a valid answer.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;cccaaa&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;cccaaa&quot;</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Both &#39;c&#39; and &#39;a&#39; appear three times, so &quot;aaaccc&quot; is also a valid answer.</span><br><span class="line">Note that &quot;cacaca&quot; is incorrect, as the same characters must be together.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;Aabb&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;bbAa&quot;</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">&quot;bbaA&quot; is also a valid answer, but &quot;Aabb&quot; is incorrect.</span><br><span class="line">Note that &#39;A&#39; and &#39;a&#39; are treated as two different characters.</span><br></pre></td></tr></table></figure><hr><p>比较简单的一道题，具体解法如下：</p><ol><li>计数算频率，用<code>unordered_map</code>就搞定了</li><li>按频率排序，先把<code>unoredred_map</code>转成<code>vector</code>，然后再<code>sort</code></li><li>生成字符串。</li></ol><p>具体代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">frequencySort</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; cmap;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.<span class="built_in">size</span>(); i++) cmap[s[i]]++;</span><br><span class="line">    vector&lt;pair&lt;char, int&gt;&gt; pvec(cmap.begin(), cmap.end());</span><br><span class="line">    sort(pvec.<span class="built_in">begin</span>(), pvec.<span class="built_in">end</span>(), [](<span class="keyword">const</span> pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; &amp;p1, <span class="keyword">const</span> pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; &amp;p2) &#123;</span><br><span class="line">        <span class="keyword">return</span> p1.second &gt; p2.second; </span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = pvec.<span class="built_in">begin</span>(); it != pvec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        res += <span class="built_in">string</span>(it-&gt;second, it-&gt;first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为中途需要把<code>unordered_map</code>转成<code>vector</code>，所以使用的空间就有点多了（统计数据存了两份），所以我们尝试直接使用<code>vector</code>来统计。之所以能直接用<code>vector</code>来统计，是因为char类型总共就256个字符而已，所以我们用一个长度为<code>256</code>的<code>vector</code>即可完成，具体代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">frequencySort</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    vector&lt;pair&lt;char, int&gt; &gt; pvec(256);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">256</span>; i++) pvec[i] = make_pair(i, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        pvec[s[i]].second++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = pvec.<span class="built_in">begin</span>(); it != pvec.<span class="built_in">end</span>() &amp;&amp; it-&gt;second; ++it) &#123;</span><br><span class="line">        res += <span class="built_in">string</span>(it-&gt;second, it-&gt;first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Longest String Chain</title>
      <link href="/2019/11/10/Longest-String-Chain/"/>
      <url>/2019/11/10/Longest-String-Chain/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第6天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/longest-string-chain/" target="_blank" rel="noopener">Longest String Chain</a>：</p><hr><p>Given a list of words, each word consists of English lowercase letters.</p><p>Let’s say <code>word1</code> is a predecessor of <code>word2</code> if and only if we can add exactly one letter anywhere in <code>word1</code> to make it equal to <code>word2</code>. For example, <code>&quot;abc&quot;</code> is a predecessor of <code>&quot;abac&quot;</code>.</p><p>A <em>word chain</em> is a sequence of words <code>[word_1, word_2, ..., word_k]</code> with <code>k &gt;= 1</code>, where <code>word_1</code> is a predecessor of <code>word_2</code>, <code>word_2</code> is a predecessor of <code>word_3</code>, and so on.</p><p>Return the longest possible length of a word chain with words chosen from the given list of <code>words</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;a&quot;,&quot;b&quot;,&quot;ba&quot;,&quot;bca&quot;,&quot;bda&quot;,&quot;bdca&quot;]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: one of the longest word chain is &quot;a&quot;,&quot;ba&quot;,&quot;bda&quot;,&quot;bdca&quot;.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><code>1 &lt;= words.length &lt;= 1000</code></li><li><code>1 &lt;= words[i].length &lt;= 16</code></li><li><code>words[i]</code> only consists of English lowercase letters.</li></ol><hr><p>看到这道题的时候，一开始以为要先转化成图来做，但是感觉好像有点复杂化这个问题了，尝试手动跑了一下样例，发现存在最优子结构，因此我们可以用动态规划来做。动规方程如下：</p><p>$$<br>dp[i] = max({dp[j] + 1 | isPredecessor(words[i], words[j]) == true });<br>$$</p><p>简单解释一下这个方程（可能写的不是很规范），$dp[i]$ 表示以第i 个字符串为结尾的最长<code>String Chain</code>的长度。我们可以用第 i 个字符串的所有<code>Predecessor</code>的 dp 值最大值再加一得到。</p><p>同时，为了加速，我们可以先对原始的字符串序列做一次按长度的排序。这样就很容易找到和当前字符串长度相差1的字符串了，这样我们在找所有<code>Predecessor</code>的时候不需要遍历所有数组。</p><p>有了动规方程，我们写出这个代码就简单多了，只要按着类似的套路即可。</p><p>这样我们代码就只剩下如何判读一个字符串是否是另一个字符串的<code>Predecessor</code>，其实这个问题也挺简单的，只要两个循环即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPredecessor</span><span class="params">(<span class="built_in">string</span> &amp;s1, <span class="built_in">string</span> &amp;s2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// check s2 is s1's predecessor</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s1.<span class="built_in">size</span>() != s2.<span class="built_in">size</span>() + <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = s2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(;i &lt; len  &amp;&amp; s1[i] == s2[i]; i++)</span><br><span class="line">        <span class="comment">/* pass */</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i &lt; len &amp;&amp; s1[i+<span class="number">1</span>] == s2[i]; i++)</span><br><span class="line">        <span class="comment">/* pass */</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i == len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestStrChain</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort by size</span></span><br><span class="line">    sort(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2) &#123;</span><br><span class="line">        <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(words.<span class="built_in">size</span>(), <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> beg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; dp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(words[beg].<span class="built_in">size</span>() + <span class="number">1</span> &lt; words[i].<span class="built_in">size</span>()) beg++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = beg; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPredecessor(words[i], words[j])) dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">max</span>(dp[i], res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reverse Substrings Between Each Pair of Parentheses</title>
      <link href="/2019/11/09/Reverse-Substrings-Between-Each-Pair-of-Parentheses/"/>
      <url>/2019/11/09/Reverse-Substrings-Between-Each-Pair-of-Parentheses/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第5天。</p></blockquote><p>今天的题目是：<a href="https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/" target="_blank" rel="noopener">Reverse Substrings Between Each Pair of Parentheses</a>：</p><hr><p>You are given a string <code>s</code> that consists of lower case English letters and brackets. </p><p>Reverse the strings in each pair of matching parentheses, starting from the innermost one.</p><p>Your result should <strong>not</strong> contain any brackets.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;(abcd)&quot;</span><br><span class="line">Output: &quot;dcba&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;(u(love)i)&quot;</span><br><span class="line">Output: &quot;iloveu&quot;</span><br><span class="line">Explanation: The substring &quot;love&quot; is reversed first, then the whole string is reversed.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;(ed(et(oc))el)&quot;</span><br><span class="line">Output: &quot;leetcode&quot;</span><br><span class="line">Explanation: First, we reverse the substring &quot;oc&quot;, then &quot;etco&quot;, and finally, the whole string.</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;a(bcdefghijkl(mno)p)q&quot;</span><br><span class="line">Output: &quot;apmnolkjihgfedcbq&quot;</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= s.length &lt;= 2000</code></li><li><code>s</code> only contains lower case English characters and parentheses.</li><li>It’s guaranteed that all parentheses are balanced.</li></ul><hr><p>很简单的一道题，和昨天那道差不多的思路，都是用栈来解决嵌套问题就好了，甚至比昨天那道题还要简单，所以直接放代码了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">reverseParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; st;</span><br><span class="line">    st.push(<span class="built_in">string</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">            st.push(<span class="built_in">string</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">            <span class="built_in">string</span> s = st.top(); st.pop();</span><br><span class="line">            st.top() += <span class="built_in">string</span>(s.rbegin(), s.rend());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            st.top().push_back(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Decode String</title>
      <link href="/2019/11/08/Decode-String/"/>
      <url>/2019/11/08/Decode-String/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第四天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/decode-string/" target="_blank" rel="noopener">Decode String</a>：</p><hr><p>Given an encoded string, return its decoded string.</p><p>The encoding rule is: <code>k[encoded_string]</code>, where the <em>encoded_string</em> inside the square brackets is being repeated exactly <em>k</em> times. Note that <em>k</em> is guaranteed to be a positive integer.</p><p>You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.</p><p>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, <em>k</em>. For example, there won’t be input like <code>3a</code> or <code>2[4]</code>.</p><p><strong>Examples:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s &#x3D; &quot;3[a]2[bc]&quot;, return &quot;aaabcbc&quot;.</span><br><span class="line">s &#x3D; &quot;3[a2[c]]&quot;, return &quot;accaccacc&quot;.</span><br><span class="line">s &#x3D; &quot;2[abc]3[cd]ef&quot;, return &quot;abcabccdcdcdef&quot;.</span><br></pre></td></tr></table></figure><hr><p>比较简单的一道题，先分析一下题目，首先输入的格式是<code>k[encoded_string]</code>，要将其扩展成k 个 encoded_string 组成的字符串，我们暂且先不考虑嵌套的情况，我们通过一个简单的状态机就可以解决这个问题：</p><p><img src="http://imagehosting.wuxiaobai24.fun/20191108204429.png" alt="有限状态机"></p><p>这个代码写起来也很简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="built_in">string</span> temp;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, <span class="built_in">size</span> = s.<span class="built_in">size</span>(); i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">            num = num * <span class="number">10</span> + s[i] - <span class="string">'0'</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'['</span>) &#123;</span><br><span class="line">           temp = <span class="string">""</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">']'</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; num;i++)</span><br><span class="line">            res += temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// charar</span></span><br><span class="line">            res.push_back(s[i]);</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这道题不需要考虑嵌套问题的话，上面就是正确的答案了。虽然需要处理嵌套的问题，但是其实只需要用栈来模拟多个层次的嵌套即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; sst;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; nst;</span><br><span class="line">    nst.push(<span class="number">1</span>);</span><br><span class="line">    sst.push(<span class="built_in">string</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, <span class="built_in">size</span> = s.<span class="built_in">size</span>(); i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">            num = num * <span class="number">10</span> + s[i] - <span class="string">'0'</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'['</span>) &#123;</span><br><span class="line">            beg = <span class="built_in">end</span> = i + <span class="number">1</span>;</span><br><span class="line">            nst.push(num); num = <span class="number">0</span>;</span><br><span class="line">            sst.push(<span class="built_in">string</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">']'</span>) &#123;</span><br><span class="line">            <span class="built_in">string</span> s = sst.top(); sst.pop();</span><br><span class="line">            <span class="keyword">int</span> n = nst.top(); nst.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++) sst.top() += s;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// char</span></span><br><span class="line">            sst.top().push_back(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sst.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Serialize and Deserialize BST</title>
      <link href="/2019/11/07/Serialize-and-Deserialize-BST/"/>
      <url>/2019/11/07/Serialize-and-Deserialize-BST/</url>
      
        <content type="html"><![CDATA[<h1 id="Serialize-and-Deserialize-BST"><a href="#Serialize-and-Deserialize-BST" class="headerlink" title="Serialize and Deserialize BST"></a>Serialize and Deserialize BST</h1><blockquote><p>第三天。</p></blockquote><p>今天的题是[<a href="https://leetcode.com/problems/serialize-and-deserialize-bst/]" target="_blank" rel="noopener">https://leetcode.com/problems/serialize-and-deserialize-bst/]</a>(Serialize and Deserialize BST):</p><hr><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p><p>Design an algorithm to serialize and deserialize a <strong>binary search tree</strong>. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure.</p><p><strong>The encoded string should be as compact as possible.</strong></p><p><strong>Note:</strong> Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</p><hr><p>这个题目需要我们实现两个函数，一个对BST进行序列化，一个对BST进行反序列化。总的来说对算法要求不高（时间上），但是要求序列化出来的字符串尽量小。</p><p>首先要解决两个问题：</p><ul><li>如何序列化一个正常节点</li><li>如何序列化一个NULL节点</li></ul><p>这里面我们采取这样一个方法，一个正常的节点由以下结构组成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> flag = <span class="string">'Y'</span>;</span><br><span class="line"><span class="keyword">union</span> INT &#123;</span><br><span class="line"><span class="keyword">int</span> iv;</span><br><span class="line"><span class="keyword">char</span> cv[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中flag来标识，这是一个正常的节点，而INT则是存放节点的值，通过<code>union</code>,我们可以方便的将int转换为char数组。</p><p>一个NULL的节点当然也可以通过上面的结构组成，但是对于NULL节点来说，后面的INT其实没有必要，所以我们直接通过字符<code>N</code>来标识NULL节点。</p><p>因此，我们的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">union</span> INT &#123;</span><br><span class="line">        <span class="keyword">int</span> iv;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> cv[<span class="number">4</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        serialize(root, str);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">serialize</span><span class="params">(TreeNode *root, <span class="built_in">string</span> &amp;str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            str.push_back(<span class="string">'N'</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        INT val;</span><br><span class="line">        val.iv = root-&gt;val;</span><br><span class="line">        </span><br><span class="line">        str.push_back(<span class="string">'Y'</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123; </span><br><span class="line">            str.push_back(val.cv[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        serialize(root-&gt;left, str);</span><br><span class="line">        serialize(root-&gt;right, str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> deserialize(data, index);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode *<span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> &amp;data, <span class="keyword">int</span> &amp;index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= data.<span class="built_in">size</span>() || data[index] == <span class="string">'N'</span>) &#123;</span><br><span class="line">            index += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;  </span><br><span class="line">        &#125; </span><br><span class="line">        index += <span class="number">1</span>;</span><br><span class="line">        INT val;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) val.cv[i] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)data[index + i];</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        index += <span class="number">4</span>;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(val.iv);</span><br><span class="line">        root-&gt;left = deserialize(data, index);</span><br><span class="line">        root-&gt;right = deserialize(data, index);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K Closest Points to Origin</title>
      <link href="/2019/11/06/K-Closest-Points-to-Origin/"/>
      <url>/2019/11/06/K-Closest-Points-to-Origin/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第2天了。</p></blockquote><p>今天的题目是[<a href="https://leetcode.com/problems/k-closest-points-to-origin/]" target="_blank" rel="noopener">https://leetcode.com/problems/k-closest-points-to-origin/]</a>(K Closest Points to Origin):</p><hr><p>We have a list of <code>points</code> on the plane. Find the <code>K</code> closest points to the origin <code>(0, 0)</code>.</p><p>(Here, the distance between two points on a plane is the Euclidean distance.)</p><p>You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in.)</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: points &#x3D; [[1,3],[-2,2]], K &#x3D; 1</span><br><span class="line">Output: [[-2,2]]</span><br><span class="line">Explanation: </span><br><span class="line">The distance between (1, 3) and the origin is sqrt(10).</span><br><span class="line">The distance between (-2, 2) and the origin is sqrt(8).</span><br><span class="line">Since sqrt(8) &lt; sqrt(10), (-2, 2) is closer to the origin.</span><br><span class="line">We only want the closest K &#x3D; 1 points from the origin, so the answer is just [[-2,2]].</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: points &#x3D; [[3,3],[5,-1],[-2,4]], K &#x3D; 2</span><br><span class="line">Output: [[3,3],[-2,4]]</span><br><span class="line">(The answer [[-2,4],[3,3]] would also be accepted.)</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><code>1 &lt;= K &lt;= points.length &lt;= 10000</code></li><li><code>-10000 &lt; points[i][0] &lt; 10000</code></li><li><code>-10000 &lt; points[i][1] &lt; 10000</code></li></ol><hr><p>今天的题目比较简单，虽然是一道<code>Mediem</code>的题目，但是不知道为什么好像常规做法就AC了。解法就是算每个点到原点的距离先，然后排序，最后取出前K个就好了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">kClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; index;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, <span class="built_in">size</span> = points.<span class="built_in">size</span>(); i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p = &#123;i, points[i][<span class="number">0</span>]*points[i][<span class="number">0</span>] + points[i][<span class="number">1</span>]*points[i][<span class="number">1</span>]&#125;;</span><br><span class="line">        index.push_back(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(index.<span class="built_in">begin</span>(), index.<span class="built_in">end</span>(), [](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;pi, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;pj) &#123;</span><br><span class="line">        <span class="keyword">return</span> pi.second &lt; pj.second;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; K;i++) &#123;</span><br><span class="line">        res.push_back(points[index[i].first]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chromebook 体验</title>
      <link href="/2019/10/07/Chromebook/"/>
      <url>/2019/10/07/Chromebook/</url>
      
        <content type="html"><![CDATA[<h2 id="剁手的心路历程"><a href="#剁手的心路历程" class="headerlink" title="剁手的心路历程"></a>剁手的心路历程</h2><h3 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h3><p>大概是暑假的时候，刷手机的时候刷到了和Chromebook有点关系的东西吧，好像是在v2ex上看到了FydeOS的软文。随后就去了解了一下这个操作系统，从描述上来看，轻办公的话，好像还是不错的。讲道理，当时就挺心动了，好奇心驱使着我下载了FydeOS的ISO，并在U盘上体验了一番，感觉略卡，顿时就没有了兴趣，而且他们家推的那款电脑好像看起来很廉价，2k的价格为啥我不去买iPad呢？因为当时刚发布没多久好像没看到几个评测，所以慢慢就对其失去了想法，但是关于Chromebook的种子已经埋在了我心里。</p><h3 id="重逢"><a href="#重逢" class="headerlink" title="重逢"></a>重逢</h3><p>开学没多久就到了中秋，因为是新生，所以入学那几天都是不用上课的，但是也上了一天（刚好周四课贼多），所以感觉在上那些无聊的课程时如果能有个iPad或轻薄本的话应该会挺方便的。</p><p>大概是中秋假期的某个晚上，刷手机时又刷到了和Chromebook有关的东西吧，买一台Chromebook的想法又从我心中浮起。当时刚好比较闲，在Chromebook吧上看各位老哥关于Chromebook的分享和评测，并跑去下来一个CloudReady的镜像在虚拟机上玩耍了一下。虽然说是因为比较闲才去干这些的，但是其实当时应该是算在评估Chromebook对自己是否适合了。回想一下当时得出的结果应该是这样的：</p><ul><li>Chromebook大多数比较轻薄，续航较好，很适合做二奶机（自己的笔记本太大太重了）</li><li>买对的机器的话，可以很方便的开一个Linux的虚拟机（对自己来说有一定的生产力，本人常年使用Linux）</li><li>很多情况需要梯子（反正我的梯子也没断过）</li></ul><p>从上面来看，这东西应该是挺适合我的。因为贴吧有位老哥对三星那款Chromebook Plus做了评测，而且本人有点颜值党，所以对三星这款还是比较满意的。</p><h3 id="剁手"><a href="#剁手" class="headerlink" title="剁手"></a>剁手</h3><p>由于Chromebook没有在国内发行，所以淘宝和京东什么的是搜不到什么东西的，想要买Chromebook大概就只有几种途径：</p><ol><li>海淘</li><li>肉身翻出去买（因为在深圳，所以去香港澳门买东西还是比较方便的）</li><li>闲鱼收二手</li></ol><p>恩，因为价格的原因，所以我还是选择了最轻松方便的闲鱼。在多次翻阅和比较后，我发现了一个比Chromebook Plus更好的选择，那就是Chromebook Plus v2。之所以说他是更好的选择，最主要是因为当时有位老哥给出来1k4的价格（因为机器A面有个小坑和两条划痕所以才那么低的），而且这款是支持电信LTE的。剁手嘛，总是会有点冲动的，在看到这个价格后没多久，我就和那位老哥联系了一下，并拍下了这款。</p><h2 id="Chromebook-Plus-V2-体验"><a href="#Chromebook-Plus-V2-体验" class="headerlink" title="Chromebook Plus V2 体验"></a>Chromebook Plus V2 体验</h2><h3 id="硬件篇"><a href="#硬件篇" class="headerlink" title="硬件篇"></a>硬件篇</h3><p>因为不是特别懂这块的东西，所以就不班门弄斧了，这里之见见主观的想法：</p><ul><li>键盘不算好，应该是低于笔记本的平均水平的，但是也不差，起码比MacBook的好（前几天刚好去体检店玩了一下，没有回弹的键盘实在是太难受了），同时键盘和普通的有点区别，首先没有Win键（这可以理解，毕竟本来就不打算让你装window嘛），其次caps lock键被换成了搜索键（搞得我现在用其他笔记本的时候老是按caps lock），最后他的F1-F12全部被替换成了一些功能键（好像问题不大，有些情况下好像还是会映射成对于F<em>键的，比如开启开发者模式后，Ctrl+Shift+F</em>打开另一个tty，这和Linux的传统是一样的）。</li><li>触控板挺好用的，用来那么久了，基本没想过要插一个鼠标。</li><li>4G内存+32GB SSD实在是有点不够用啊，内存占有常年是满的，32GB装完系统和必要的东西后，基本上10GB都不一定有。</li><li>屏幕相当不错，触摸屏也挺好的。</li><li>摄像头没怎么体验过，两个摄像头好像都挺烂的，不过一般人也不会在笔记本上用到摄像头。</li><li>S Pen配合一些软件用起来相当好，就是笔有点小，拿久了会不舒服。</li><li>Chromebook Plus V2相比与Chromebook Plus多了一个LTE版本，亲测，可以插电信卡（应该是只能插电信卡），而且网络效果还行，没事不会断掉（断掉就重启），个人认为对于Chromebook这种上网本来说，随时随地的网络还是比较重要的，这也是我买V2版本的原因。</li></ul><h3 id="软件篇"><a href="#软件篇" class="headerlink" title="软件篇"></a>软件篇</h3><p>这部分是这篇文章的重点（写这篇文章的主要想法就是想记录下Chromebook上一些好用的应用），主要分为3个部分来展开，这三个部分是分别从Chrome，Linux，Android三个平台来介绍各个软件。</p><h4 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h4><blockquote><p>Chrome主要是介绍一些插件和应用。</p></blockquote><ul><li>Proxy SwitchyOmega：搭梯子时用到的</li><li>Adblock Plus：广告拦截</li><li>Evernote Web Clipper: 其实我已经弃用Evernote挺久的了，但是在Chromebook上Evernote的确是一个挺好的选择（主要是他安卓上优化的好，后面会提）</li><li>OneTab：一键把所有打开的Tab收起来，在Chromebook这种小内存的机子上，这东西太有用了</li><li>Vimium：在浏览器上使用vim快捷键，喜欢vim的和键盘党可以试一下，不适合大部分人</li><li>All-in-One Messenger：用来打开网页版的微信还是不错的选择，但在Chromebook上用微信的次数不多，不确定有没有更好的选择</li><li>Cog：用来看Chromebook的硬件信息的，感觉还可以，主要是能看到内存和CPU占用（Chromebook自带的任务管理器看不了，不过最近发现Ctrl + Alt + T打开crosh，里面自带了top命令，会用的人可以考虑用top）</li><li>Google Keep：ChromeOS自带，和S Pen配合还是挺好用的，但是同步需要梯子。</li><li>Minimalist Markdown Editor：很小巧的Markdown编辑器，这篇文章就是在这上面编辑的（当初码字还是很舒服的）</li><li>Secure Shell App：SSH Client，大半的生产力在上面，不过对中文的兼容不是很好，主要体现在输入中文时，显示会乱掉（估计是没有实时刷新），但是现在还没有找到更好的选择。同时他还可以安装SFTP到文件管理器上，感觉还算挺好用的</li><li>TeamViewer：TeamViewer是我见过全平台做的最好的一款产品了，虽然不常用，但是总是会有需要它的时候。</li><li>Text：自带的文本编辑器，编辑一下简单的文本文件（比如V2ray的配置文件）还是挺好用的。</li><li>Code Pad Text Editor: 代码编辑器，写这篇文章期间发现的，第一感觉还可以</li><li><del>马克飞象：用来做Markdown编辑器还是挺好的，足够好看，而且能够同步到印象笔记中，但是他要收费，所以最后还是弃了</del></li><li>Firefox Send：传一些中小文件用的，速度上还不错，但是有点比较麻烦的就是它不是通过特殊的PIN码来分享，而是URL。把一个URL传到另一个机器上和传一个文件到另一个机器上的麻烦程度其实是一样的，个人认为这是它最大的缺点。不过我后面会有解决（妥协）办法。</li><li>Pushbullet：一个多平台的App，可以比较方便的传输信息，文件（传文件和图片什么的其实很慢），这就是用来解决Firefox Send需要把URL传到另一个机器上的方法。</li></ul><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>这部分只是简单介绍一下Chromebook上三个不同的Linux环境以及对它们的一些评价吧。</p><ul><li><p>ChromeOS</p><p>  众所周知，ChromeOS其实是一个Linux的发行版，所以在crosh输入shell其实是可以进入一个Linux环境的，但是ChromeOS的确不像其他常用的Linux发行版，他的终端支持的东西太少了，以至于很多东西想要安装上去其实很困难，例如如果你想要安装v2ray的话，通过go.sh其实是安装不上去的（反正我没成功）。同时，这个环境好像会因为ChromeOS的升级而被破换掉（亲身经历过，但不确定是不是运气刚好比较差）。因此，个人是不建议在这个环境安装太多东西的，不过还是有人弄出来一个ChromeOS的包管理器（chromebrew)，梯子好的话，安装起来并不困难，但是感觉没什么太大用处，我机子上只是用它安装了V2ray而已。</p></li><li><p>Crostini</p><p>  这个东西是现在官方在推的，弄起来比较方便，在设置里面开启Linux终端，用起来还是比较方便的。这东西就是在ChromeOS上起了一个Linux的虚拟机，装的是Debian系统（有需要是可以换成其他系统的，在Reddit上有帖子介绍如何在把Debian换成Arch Linux），如果只是想要个命令行来跑一些小程序，用这个还是不错的，debian虽然装东西不如Arch那么方便，但是生态还是不错的，大部分Linux的软件都会有deb包。同时这个东西还有一点比较好的就是在这里面装GUI软件的话，其实可以很方便的在ChromeOS上打开（有点像VirtualBox的无缝模式），不过这样打开的软件是没法使用ChromeOS的输入法的，需要在debian上安装中文环境和输入法（这个网上介绍挺多的，不细讲）。BTW，由于屏幕是高分屏，然后Linux对其支持不太好，所以字体会显示的很小（有低分辨率模式，不过建议不要用，太糊了）</p></li></ul><ul><li><p>Crouton</p><p>  没搞懂这东西的原理，简单介绍一下他的效果吧。看起来也像是开了一个Linux虚拟机的样子，安装时可以选择不同的发行版（不过选择不多，基本都是debian系的，比如Ubuntu，Kail），同时可以选择安装不同的桌面（比如Unity，xfce，KDE）。一般情况下打开后切换到装好的Linux系统的桌面上，然后你就可以使用这个Linux啦，就像在虚拟机里面开全屏模式一样，可以用<code>Ctrl + Alt + -&gt;</code>和<code>Ctrl + Alt + &lt;-</code>在ChromeOS和Linux之间切换。这东西和Crostini一样也需要自己安装中文环境和输入法。要切来切去肯定比较麻烦，但是它还有个叫xiwi的东西可以实现在ChromeOS上打开LinuxGUI应用，不过体验没有Crostini好，也一样会有高分屏的问题。<br>  还有一点比较重要的就是，Crouton安装起来比较麻烦，大部分包可以用镜像很快的下载下来，但是有个包没办法。个人的解决方法就是先直接用镜像安装，失败后再加http代理。</p></li></ul><p>说实话，ChromeOS对Linux的支持是我最不满意的一部分，无论那种方式都有很多坑，而且有些好像没法解决（起码我现在还没有解决办法）。我现在的情况是，在ChromeOS上只使用Chromebrew安装v2ray，然后开发用Crostini。对于Crouton，我是直接弃掉了。不过Crostini中文上的确支持不好，他的终端App和Secure Shell App采用的估计是同一套代码，所以中文输入时一样会乱掉。不知道什么原因，在Crostini上使用vscode实在是太卡了，卡成PPT的那种。</p><h4 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h4><p>个人觉得，ChromeOS蹭Android的应用的确满足了一部分人的刚需，Android上的一部分应用在Chromebook表现的非常好，当然也有坑点，但是相对于Linux那部分，个人还是比较满意Android的表现的。</p><ul><li>MS Office 三件套：Word和ppt应该对大部分人来说是无法避免的东西。不过有点不好的就是，这个东西如果没有Office 365账号的话，是只能看，不能修改的。（hhh，我有学生账号）如果不想订阅Office 365的话，可以考虑下WPS，但是我感觉没有微软出的好用。BTW，<strong>大部分Android应用在用键盘输入的时候，输入法的提示栏会跑到左上方去，所以会很难受。</strong></li><li>OneDrive：同步神器（才不是因为有1TB容量我才用它的呢）</li><li>Squid：手写神器，试了很多款，就这个好用点，做做简单的笔记，免费版其实已经够用了。其实收费版好像也就导入PDF有点吸引力，不过这东西不支持PDF的书签，能导入PDF好像也没太大作用</li><li>Xodo：PDF神器，手写支持的很好（就是有时候有点卡）</li><li>Evernote：点名表扬一下，这个可能是对Chromebook支持最好的了，他会把输入法的提示栏拉到当前输入的位置（虽然会闪一下，但是相比其他的好很多了）</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，Chromebook作为一个二奶机，还是很不错的选择，不贵的价格（特指二手的），足够好的屏幕和续航。虽然软件应用上还做的不够，但是这在一些轻办公环境下已经相当不错了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂事一堆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chromebook </tag>
            
            <tag> ChromeOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Use Travis CI</title>
      <link href="/2019/08/20/Use-Travis-CI/"/>
      <url>/2019/08/20/Use-Travis-CI/</url>
      
        <content type="html"><![CDATA[<p>今天简单使用了一下<a href="https://travis-ci.org" target="_blank" rel="noopener">Travis CI</a>。</p><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>因为搭建<a href="https://github.com/wuxiaobai24/django-blog" target="_blank" rel="noopener">Django-blog</a>时，每次更新一次代码，就需要手动登陆到服务器上进行一系列操作来重启服务，感觉过于麻烦且容易出错，因此想使用 CI/CD 工具来自动化这一过程。</p><p>所以这里就简单了解了一下 CI/CD，并尝试使用 <a href="https://travis-ci.org" target="_blank" rel="noopener">Travis CI</a> 来实现 Hexo 的自动化部署。</p><p>但考虑到 Travis CI 是一个 SaaS 服务，需要开发服务器的权限来完成部署，所以后面应该会先将<code>Django-blog</code>的部署方式转换成<code>Docker</code>的方式，然后在搭建<code>Drone</code>或<code>Jenkins</code>来完成 CI/CD</p><h2 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI/CD"></a>CI/CD</h2><ul><li>CI(Continuous Integration)即<strong>持续集成</strong>，个人理解是在提交代码后进行一些了测试来确保代码的正确性，保证每个开发者每次提交都会进行测试。</li><li>CD(Continuous Deploy)即<strong>自动部署</strong>，个人理解是在完成了测试后将代码自动化的部署到服务器上，这样就不需要开发者或运维来手动进行代码拉取，设置配置，重启服务等操作了，而是将其自动化。<strong>这个东西其实就是我想要的</strong></li></ul><h2 id="Travis-CI"><a href="#Travis-CI" class="headerlink" title="Travis CI"></a>Travis CI</h2><p>要使用<code>Travis CI</code>来完成自动化部署<code>hexo</code>可以分为以下几个步骤：</p><ul><li>在<code>Travis CI</code>网站上将 repo 加入构建</li><li>在Github生成<code>Github Access Token</code>并将其加入到<code>Travis CI</code>的环境变量中，这里使用的变量名是<code>GITHUB_TOKEN</code></li><li>在repo上添加一个<code>Travis CI</code>的配置文件：</li></ul><p>下面是<code>.travis.yml</code>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">langaue:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span> <span class="string">stable</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">    <span class="attr">only:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">save</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">hexo-cli</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">https://github.com/smduan/next.git</span> <span class="string">themes/next</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-deployer-git</span> <span class="string">--save</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mv</span> <span class="string">_next_config.yml</span> <span class="string">themes/next/_config.yml</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line"></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.name</span> <span class="string">"wuxiaobai24"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.email</span> <span class="string">"wuxiaobai24@foxmail.com"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sed</span> <span class="string">-i</span> <span class="string">"s/GITHUB_TOKEN/$&#123;GITHUB_TOKEN&#125;/g"</span> <span class="string">./_config.yml</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CI/CD </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maximum Binary Tree</title>
      <link href="/2019/03/21/Maximum-Binary-Tree/"/>
      <url>/2019/03/21/Maximum-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第15天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/maximum-binary-tree/" target="_blank" rel="noopener">Maximum Binary Tree</a>。</p><p>并不难的一道题，而且不同寻常的是用栈去做比用递归去做要方便一点。</p><p>我这里的想法是，从左向右一直插入就好了，例如输入是<code>[3, 2, 1, 6, 0, 5]</code></p><p>先插入 3 ，然后插入下一个元素时进行讨论：</p><ul><li>如果比上一次插入的元素要小，我就直接插入到上一次插入节点的右孩子处就好了。</li><li>如果比上一次插入的元素要大，我就用栈回溯到上上次插入节点的位置，进行判断，以此类推。<ul><li>如果在栈中找到了，我就将新元素插入到该节点的右孩子处，并把原来的右子树当成是新元素的左子树。</li><li>如果没在栈中找到，我就把新元素当成新的根节点，并把原来的数当成新元素的左子树。</li></ul></li></ul><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">constructMaximumBinaryTree1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">end</span> = nums.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">TreeNode *root = <span class="keyword">new</span> TreeNode(nums[<span class="number">0</span>]);</span><br><span class="line">TreeNode *p = root;</span><br><span class="line"></span><br><span class="line">st.push(root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = nums.<span class="built_in">begin</span>() + <span class="number">1</span>; it != <span class="built_in">end</span>; ++it) &#123;</span><br><span class="line"><span class="keyword">int</span> val = *it;</span><br><span class="line">TreeNode *t = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (val &lt; p-&gt;val) &#123;</span><br><span class="line">p-&gt;right = t;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(!st.empty() &amp;&amp; val &gt; st.top()-&gt;val) st.pop();</span><br><span class="line"><span class="keyword">if</span> (!st.empty()) &#123;</span><br><span class="line">p = st.top();</span><br><span class="line">t-&gt;left = p-&gt;right;</span><br><span class="line">p-&gt;right = t;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">t-&gt;left = root;</span><br><span class="line">root = t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">p = t;</span><br><span class="line">st.push(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Daily Temperatures</title>
      <link href="/2019/03/20/Daily-Temperatures/"/>
      <url>/2019/03/20/Daily-Temperatures/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第14天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/daily-temperatures/" target="_blank" rel="noopener">Daily Temperatures</a>.</p><p>这道题会给我一个数组代表温度，如：<code>T = [73, 74, 75, 71, 69, 72, 76, 73]</code></p><p>我们返回一个数组来表示，多少天会回暖（即比当天温度要高），如<code>[1, 1, 4, 2, 1, 1, 0, 0]</code></p><p>如 74 比 73 高，则返回的数组中第一个数值应该为1，而对于 75 ，因为他后面只有76比他高，那么就得4天后才回暖，那么对应的位置应该放置4.</p><p>简单的想法当然是对每一个数字，从前向后找啦，但是这样复杂度就是<code>O(N^2)</code>了，所以我们换钟思路，从后向前去获取答案，看看能不能通过这种方式来减少复杂度。</p><p>之所以这样做，是想着能否利用之前已经求过的结果来推断当前的结果，比如求解 75 时，我们先猜答案是1，然后发现向前一天的温度是71，那么显然猜错了，这时我们要继续向前猜 69 吗？显然没必要啊，因为 69 都还没 71 大，我们应该利用之前求出的答案，发现比 71 大的数再他后面 2 天，所以我们直接猜答案是 1 + 2 即可，用这种方式就可以把前面的结果利用上了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = T.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = len<span class="number">-2</span>; i&gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(T[i + t] &lt;= T[i] &amp;&amp; res[i+t] != <span class="number">0</span>)</span><br><span class="line">t += res[i+t];</span><br><span class="line">res[i] = (T[i+t] &lt;= T[i])?<span class="number">0</span>:t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stone Game</title>
      <link href="/2019/03/13/Stone-Game/"/>
      <url>/2019/03/13/Stone-Game/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第13天，今天的题目有点有趣，也有点快。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/stone-game/" target="_blank" rel="noopener">Stone Game</a>。</p><p>恩，这道题的答案是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">stoneGame</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解释如下：</p><p>假设有<code>2n</code>个石头。</p><p>因为<code>Alex</code>先选，那么<code>Alex</code>可以选第<code>1</code>或者<code>2n</code>个石头，如果选了<code>1</code>，那么<code>Lee</code>就只能选择<code>2</code>或者<code>2n</code>,<code>Lee</code>不管选哪个，<code>Alex</code>都可以选择一个奇数位的石头，如<code>3</code>或<code>2n-1</code>,即如果<code>Alex</code>先选了<code>1</code>,那么他可以让<code>Lee</code>一直选到的是偶数位的石头，反之亦然。因此<code>Alex</code>只要在开始选择的时候，计算所有石头奇数位之和以及偶数位之和，判断谁大就可以知道怎么选才能胜利了，因此，直接<code>return true</code>就好了。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Array Nesting</title>
      <link href="/2019/03/12/Array-Nesting/"/>
      <url>/2019/03/12/Array-Nesting/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第12天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/array-nesting/" target="_blank" rel="noopener">565. Array Nesting</a></p><p>总感觉这道题是刷过的。这道题的输入是一个由0到 N-1 组成的数组，按照<code>S[i] = {A[i], A[A[i]], A[A[A[i]]], ... }</code>的规则，找到<code>S[i]</code>最长的长度。</p><p>显然按这种走法，这个数组会是由多个环组成的，也就是我们要找出最长那个环的长度，我们只需要简单的去寻找即可，而且一旦我们经过了某个元素，一定不会出现在其他人的环中了，所以我们可以将其赋值为-1表示已经使用过来。</p><p>这样，我们的算法就是<code>O(n)</code>的复杂度了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">arrayNesting</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            res = <span class="built_in">max</span>(res, helper(nums, i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>, j = nums[index];</span><br><span class="line">        nums[index] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = nums[j];</span><br><span class="line">            nums[j] = <span class="number">-1</span>;</span><br><span class="line">            j = t;</span><br><span class="line">            c++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bitwise ORs of Subarrays</title>
      <link href="/2019/03/11/Bitwise-ORs-of-Subarrays/"/>
      <url>/2019/03/11/Bitwise-ORs-of-Subarrays/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第11天，今天刷的是一道动态规划的题目。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/bitwise-ors-of-subarrays/" target="_blank" rel="noopener">Bitwise ORs of Subarrays</a>:</p><p>这道题的时间复杂度很高，我们用个例子来解释解法：</p><p>首先输入是<code>[1, 2, 4]</code>,我们先看下能不能用<code>[1, 2]</code>的答案来推出<code>[1, 2, 4]</code>的答案：</p><p><code>[1, 2]</code>的答案是<code>1, 2, 3</code>如果都与<code>4</code>或一下的话，会得到的是<code>[5, 6, 7]</code>，而<code>[1, 2, 4]</code>的答案中应该是没有<code>5</code>的，那么问题出在哪里了呢？如果仔细想一下的话，会发现这里要求的是连续子数组，而以<code>4</code>为结尾的连续子数组只有：<code>[4], [2, 4], [1, 2, 4]</code>，对它们进行或也就是说其实<code>1</code>其实是不会和<code>4</code>进行或运算的。</p><p>那么要和<code>4</code>进行或运算的数组是什么呢？答案是一个空数组和所有以<code>2</code>结尾的连续子数组的或运算结果，而进行完或运算后得到的结果就是所有以<code>4</code>结尾的或运算结果。</p><p>这时候我们就很容易想到解法了：</p><p>用一个<code>set</code>保存所有以<code>A[i-1]</code>结尾的或运算结果，记为<code>set[i-1]</code>，然后分别与<code>A[i]</code>进行或运算插入到另一个<code>set</code>中，并在最后插入一个<code>A[i]</code>就可以得到<code>set[i]</code>。</p><p>故：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarrayBitwiseORs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; res, cur, cur2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i: A) &#123;</span><br><span class="line">            cur2 = &#123;i&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;j : cur) cur2.insert(i | j);</span><br><span class="line">            cur = cur2;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;j: cur) res.insert(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Odd Even Linked List</title>
      <link href="/2019/03/09/Odd-Even-Linked-List/"/>
      <url>/2019/03/09/Odd-Even-Linked-List/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第10天，今天的题目总感觉做过，但是翻记录又没有，难道是在学校的OJ上做的？？？</p></blockquote><p>今天的题目是 <a href="https://leetcode.com/problems/odd-even-linked-list/" target="_blank" rel="noopener">Odd Even Linked List</a>。</p><p>好久没碰到链表的题了，这题比较简单。我们用一个新的链表来存奇数位的元素即可，而且这里没必要重新建立一个链表，只需要把原来链表里面的连接过来就好了，完成后，自然就把一个链表分成两个链表了。</p><p>区分奇偶数位，可以用一个 flag 来标识当前元素是奇数还是偶数，然后每移动一次就翻转该 flag ，当然更简单的是，我们循环一次移动两个元素，这样看起来会简洁一点，而且在循环内部不需要任何的条件判断，只需要在循环结束后做一些后处理即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="function">ListNode <span class="title">even</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        ListNode *q = &amp;even;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next &amp;&amp; p-&gt;next-&gt;next) &#123;</span><br><span class="line">            q-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            q-&gt;next = p-&gt;next;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = even.next;</span><br><span class="line">        q-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Linked List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matchsticks to Square</title>
      <link href="/2019/03/08/Matchsticks-to-Square/"/>
      <url>/2019/03/08/Matchsticks-to-Square/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第9天，恩，忘记洗衣服了，写完就去洗。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/matchsticks-to-square/" target="_blank" rel="noopener">Matchsticks to Square</a>。</p><p>没想到是一道暴搜的题。。。</p><p>既然是暴搜，那思路就比较简单了：</p><p>我们先计算出数组和，然后除以4就是每条边的长度了，然后用暴力搜索的方式看是否能连续四次移除长度之和为边长的火柴。</p><p>暴搜时可以用一些小技巧，比如先排序来保证先用掉比较长的火柴，这样一旦发现，剩下的火柴比需要的长度还长就可以直接判定失败了，减少搜索次数。</p><p>而且标记是否使用掉该火柴的<code>used</code>数组也可以省略掉，因为火柴长度一定大于0， 可以用其相反数来表示已经用掉了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">makesquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sort(nums.rbegin(), nums.rend());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i: nums) sum+=i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">4</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfs(nums, sum/<span class="number">4</span>) == <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (len &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (len &lt; nums[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            nums[i] = -nums[i];</span><br><span class="line">            <span class="keyword">if</span> (dfs(nums, len + nums[i])) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">            nums[i] = -nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>All Nodes Distance K in Binary Tree</title>
      <link href="/2019/03/07/All-Nodes-Distance-K-in-Binary-Tree/"/>
      <url>/2019/03/07/All-Nodes-Distance-K-in-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第8天，感觉快要把每天刷题的习惯找回来了。。。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/" target="_blank" rel="noopener">All Nodes Distance K in Binary Tree</a></p><p>这道题可以分为几个部分来解决：</p><ul><li>寻找<code>target</code>节点</li><li>向下寻找距离当前节点K步的节点</li><li>从<code>target</code>节点向前寻找</li></ul><p>虽说是三部分，但是在实现“寻找target节点”的时候，我们需要考虑到如何向前寻找，我们先把“向下寻找距离当前节点K步的节点”实现了。</p><p>很容易发现，这是一个递归的过程，做遍历的时候维护好K值即可，然后加一些判断条件就能实现了。</p><p>如果忽略掉“从target节点向前寻找”这个要求，我们要怎么实现寻找target节点呢？</p><p>也是一个很简单的问题，就直接用递归形式的先序遍历即可，遍历时判断当前节点是否为target节点。</p><p>现在就剩下最后一部分了，也是这道题的难点所在。</p><p>要实现向前移动，我们可以利用“寻找target节点”的一些信息，通过一个返回值来确定，是否在某个子分支中找到 target 节点：</p><p>如果找到了，我们就可以从当前节点开始向另一个分支寻找了，因为需要计算到target节点的距离，所以我们干脆把返回值设置为还需要走多少步才能到达”距离target节点K步“的位置，故：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">distanceK</span><span class="params">(TreeNode* root, TreeNode* target, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span> || target == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        downSearch(res, target, K);</span><br><span class="line">        findTarget(res, root, target, K);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTarget</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;res, TreeNode *root, TreeNode *target, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == target) <span class="keyword">return</span> K - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// left</span></span><br><span class="line">        <span class="keyword">int</span> left_k = findTarget(res, root-&gt;left, target, K);</span><br><span class="line">        <span class="keyword">if</span> (left_k == <span class="number">0</span>) &#123;</span><br><span class="line">            res.push_back(root-&gt;val); <span class="keyword">return</span> left_k - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left_k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            downSearch(res, root-&gt;right, left_k<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span> left_k - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> right_k = findTarget(res, root-&gt;right, target, K);</span><br><span class="line">        <span class="keyword">if</span> (right_k == <span class="number">0</span>) &#123;</span><br><span class="line">            res.push_back(root-&gt;val); <span class="keyword">return</span> right_k - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right_k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            downSearch(res, root-&gt;left, right_k<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span> right_k - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">downSearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;res, TreeNode* p, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span> || K &lt; <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (K == <span class="number">0</span>) &#123;</span><br><span class="line">            res.push_back(p-&gt;val); <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        downSearch(res, p-&gt;left, K<span class="number">-1</span>);</span><br><span class="line">        downSearch(res, p-&gt;right, K<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sum Root to Leaf Numbers</title>
      <link href="/2019/03/06/Sum-Root-to-Leaf-Numbers/"/>
      <url>/2019/03/06/Sum-Root-to-Leaf-Numbers/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第7天，为什么今天随机到了一道水题。。。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">129. Sum Root to Leaf Numbers</a></p><p>恩，这是一道打卡水题，明明是道<code>Easy</code>的题目，却混进了<code>Medium</code>中：</p><p>这道题有个比较容易想错的方法就是，用后序遍历做：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> sumNumbers(root-&gt;left) + sumNumbers(root-&gt;right) + <span class="number">20</span> * root-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法对满二叉树是没问题的，但是对于普通的二叉树就会有问题，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   1</span><br><span class="line"> &#x2F;  </span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>也就是说，在两边高度不一样时，是会出问题的，为了解决这个问题，我们要把思路换过来，把<code>root</code>到当前节点的值计算出来，并传给子节点去计算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sumNumbers(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        v = v*<span class="number">10</span> + root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; root-&gt;left == <span class="literal">nullptr</span>) <span class="keyword">return</span> v;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sumNumbers(root-&gt;left, v) + sumNumbers(root-&gt;right, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Longest Repeating Character Replacement</title>
      <link href="/2019/03/05/Longest-Repeating-Character-Replacement/"/>
      <url>/2019/03/05/Longest-Repeating-Character-Replacement/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第6天， 下雨了。。。。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/longest-repeating-character-replacement/" target="_blank" rel="noopener">Longest Repeating Character Replacement</a>。</p><p>emmmm，这道题一开始的解法虽然AC了，但是时间复杂度是<code>O(n^2)</code>，但是最佳解法却是<code>O(n)</code>，先看下我的解法：</p><p>思路比较简单，就是不断以某个字符为起始，以这个字符为目标，计算修改k次后能达到的长度，然而这样会有个问题，例如<code>ABBB</code>,如果<code>k</code>为1的话，我计算出来是<code>3</code>，但真实结果是<code>4</code>。</p><p>为了解决这个问题，我增加了一次判断，对前<code>k</code>个字符进行替换，替换成下一个字符，即以下一个字符为目标，计算修改<code>k</code>次后能达到的长度。</p><p>具体代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">characterReplacement</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j, a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line">            a = k;</span><br><span class="line">            <span class="keyword">for</span>(j = i+<span class="number">1</span>;j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c != s[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">else</span> a--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(j-i, res);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k &amp;&amp; i+<span class="number">1</span> &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i+<span class="number">1</span>];</span><br><span class="line">            a = k-i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(j = i + <span class="number">2</span>;j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c != s[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">else</span> a--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(j-i, res);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>OK，现在可以忽略掉上面的解法了，看看<code>O(n)</code>的解法是怎样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">characterReplacement</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ch</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, <span class="built_in">end</span> = <span class="number">0</span>, max_count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">end</span> &lt; len) &#123;</span><br><span class="line">            ch[s[<span class="built_in">end</span>] - <span class="string">'A'</span>]++;</span><br><span class="line">            <span class="comment">// update max_count</span></span><br><span class="line">            max_count = <span class="built_in">max</span>(max_count, ch[s[<span class="built_in">end</span>]-<span class="string">'A'</span>]);</span><br><span class="line">            <span class="built_in">end</span>++;</span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">end</span> - start &gt; max_count + k) &#123;</span><br><span class="line">                ch[s[start] - <span class="string">'A'</span>]--;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">end</span> - start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>很精妙的用滑窗解决了这个问题：</p><p>首先，它用一个数组记录滑窗内的出现字符的个数，因此每次迭代或操作都向前移动一个字符而已，所以我们可以很容易维护出一个<code>max_count</code>，即所有字符出现次数最大的那一个。</p><p>然后如果是一个正确的解的话，要满足一个约束<code>end - start - k &gt; max_count</code>,如果满足的话，可以增大滑窗去寻找更大的窗口，如果不行，那么我们就向前移动滑窗。</p><p>虽然在迭代结束后，我们不能保证当前滑窗就是满足约束的解，但是我们可以保证，最大的窗口大小一定和我们现在的滑窗大小是一样的，故可以得到解。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Minimum Falling Path Sum</title>
      <link href="/2019/03/04/Minimum-Falling-Path-Sum/"/>
      <url>/2019/03/04/Minimum-Falling-Path-Sum/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第5天，早起刷题的一天。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/minimum-falling-path-sum/" target="_blank" rel="noopener">Minimum Falling Path Sum</a></p><p>一道典型的动态规划题，动态规划的题目一般都可以分为多步走，一旦执行完一步，走下一步时可以利用之前几步的结果来快速的选择下一步要怎么走。</p><p>关键就是要找出怎么利用之前几步的结果。</p><p>如这里的，我们要知道走到最后一行的最短路径，那么如果我们已经知道了走到倒数第二行（即上一行）的最短路径，我们就可以很快的算出走到最后一行的最短路径，即：</p><p><code>dp[i][j] = min(dp[i-1][j-1], dp[i][j], dp[i][j+1]) + A[i][j]</code></p><p>然后很顺手的我们可以用两个数组来优化代码的空间复杂度，即把二维数组转成两个一维数组。</p><p>因此代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minFallingPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = A.<span class="built_in">size</span>(), w;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        w = A[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp0 = A[<span class="number">0</span>];</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp1</span><span class="params">(w, INT_MAX)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; h; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; w; j++) &#123;</span><br><span class="line">                dp1[j] = INT_MAX;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) dp1[j] = <span class="built_in">min</span>(dp0[j<span class="number">-1</span>], dp1[j]);</span><br><span class="line">                dp1[j] = <span class="built_in">min</span>(dp0[j], dp1[j]);</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt; w) dp1[j] = <span class="built_in">min</span>(dp0[j+<span class="number">1</span>], dp1[j]);</span><br><span class="line">                dp1[j] += A[i][j];</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            swap(dp1, dp0);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i: dp0) res = <span class="built_in">min</span>(res, i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spiral Matrix</title>
      <link href="/2019/03/03/Spiral-Matrix/"/>
      <url>/2019/03/03/Spiral-Matrix/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第四天，这又是一道之前没AC掉的题目。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/spiral-matrix/" target="_blank" rel="noopener">54. Spiral Matrix</a></p><p>题意比较好理解，写的时候注意一下下标变换即可，最好现在纸上把给出的测例手动跑一下。</p><p>个人觉得，最大的坑点在第二个测例中已经给出来了，如果遇到<code>[[1], [2]]</code>或<code>[[1, 2]]</code>这种长条的要怎么做。</p><p>其实我们把他当成特殊例子即可，当所给出的矩阵的行列长度不一样时，最后一定会遇到上面的情况，这样我们可以先把正常的搞定，然后在最后面处理这两种情况即可。</p><p>这道题的主要思路是，我们模拟螺旋式的走法移动下标，然后一圈一圈的去游走即可，这里的代码不难，想清楚下标变换即可，最后一圈需要处理，因为最后一圈可能是三种情况：</p><ul><li>只有一个元素</li><li>多个元素排成一列</li><li>多个元素排成一行</li></ul><p>对于上面的三种情况，如果用之前模拟螺旋的方法，很容易走多了几步，其实只要简单的用两重循环即可。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> istart = <span class="number">0</span>, iend = matrix.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (iend == <span class="number">-1</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> jstart = <span class="number">0</span>, jend = matrix[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// printf("%d %d %d %d\n", istart, iend, jstart, jend);</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(istart &lt; iend &amp;&amp; jstart &lt; jend) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = istart, j = jstart;</span><br><span class="line">            <span class="comment">// -&gt;</span></span><br><span class="line">            <span class="keyword">for</span>(;j &lt;= jend; j++)</span><br><span class="line">                res.push_back(matrix[i][j]);</span><br><span class="line">            j--; i++;</span><br><span class="line">            <span class="comment">// |</span></span><br><span class="line">            <span class="comment">// V</span></span><br><span class="line">            <span class="keyword">for</span>(;i &lt;= iend; i++)</span><br><span class="line">                res.push_back(matrix[i][j]);</span><br><span class="line">            i--; j--;;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// &lt;-</span></span><br><span class="line">            <span class="keyword">for</span>(;j &gt;= jstart; j--)</span><br><span class="line">                res.push_back(matrix[i][j]);</span><br><span class="line">            j++; i--;</span><br><span class="line">            <span class="comment">// ^</span></span><br><span class="line">            <span class="comment">// |</span></span><br><span class="line">            <span class="keyword">for</span>(;i &gt; istart; i--)</span><br><span class="line">                res.push_back(matrix[i][j]);</span><br><span class="line">            </span><br><span class="line">            istart++; iend--;</span><br><span class="line">            jstart++; jend--;</span><br><span class="line">            <span class="comment">// for(auto i: res) cout &lt;&lt; i &lt;&lt; " ";</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/// cout &lt;&lt; "----" &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = istart; i &lt;= iend;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = jstart; j &lt;= jend; j++)</span><br><span class="line">                res.push_back(matrix[i][j]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Simplify Path</title>
      <link href="/2019/03/02/Simplify-Path/"/>
      <url>/2019/03/02/Simplify-Path/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第三天（hhh，好像又很久没刷了）, 又AC掉了逻辑题，或者说又是一道用<code>if else</code>加状态机搞定的题。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/simplify-path/" target="_blank" rel="noopener">71. Simplify Path</a></p><p>以后还是不<code>copy</code>题目到这里来了，有点麻烦的感觉。。。</p><p>对于这种纯看逻辑的题目，可以先分析一下给出的测例，然后通过题目来分析要注意什么：</p><ol><li>“/home/“</li><li>“/../“</li><li>“/home//foo/“</li><li>“/a/./b/../../c/“</li><li>“/a/../../b/../c//.//“</li><li>“/a//b////c/d//././/..”</li></ol><p>从上面我们大概可以知道要注意的一些点有：</p><ul><li>首先疑似最开始的符号一定是’/‘？</li><li>通过<code>/</code>来分割单词，这意味着我们可以用<code>python</code>中的<code>split</code>或者先做一次遍历来分割单词，这样做会简化逻辑（但我没用这种方法）</li><li>要区分<code>.</code>和<code>..</code></li><li><code>.</code>表示当前目录，<code>..</code>表示上级目录</li><li>遇到多个<code>/</code>，就当成一个</li></ul><p>事实上在后面的测试中，我发现一个很坑的点，就是<code>...</code>和<code>..a</code>这种并不是一个特殊的字符串，可以作为路径名。</p><p>我们现在尝试写一个基于状态机的方法，首先定义一下遍历时需要的状态：</p><ol start="0"><li>前面是一个正常的字符<ul><li>遇到<code>/</code>,就插入到结果字符串中，并跳转到<code>1</code>。</li><li>遇到<code>.</code>，就跳转到<code>2</code>。</li><li>遇到一个正常的字符，插入到结果字符串中。</li></ul></li><li>前面是<code>/</code><ul><li>如果遇到一个<code>/</code>，就直接跳过</li><li>如果遇到一个<code>.</code>,跳转到<code>2</code></li><li>如果是一个正常字符，就插入到结果字符串中并跳转到<code>0</code></li></ul></li><li>前面是<code>.</code><ul><li>如果遇到一个<code>/</code>, 就跳转到<code>1</code></li><li>如果遇到一个<code>.</code>,就跳转到<code>3</code></li><li>如果遇到一个正常字符，就插入<code>.</code>和这个字符，并跳转到<code>0</code></li></ul></li><li>前面是<code>..</code><ul><li>如果遇到一个<code>/</code>,就开始回溯删除到前面一个<code>/</code></li><li>其余则插入一个<code>..</code>和这个字符，并跳转到<code>0</code></li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">simplifyPath</span><span class="params">(<span class="built_in">string</span> path)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// some flag to kepp state.</span></span><br><span class="line">        <span class="keyword">int</span> state = <span class="number">0</span>;  <span class="comment">// 0: last char is [char]</span></span><br><span class="line">                        <span class="comment">// 1: last char is '/'</span></span><br><span class="line">                        <span class="comment">// 2: last char is '.'</span></span><br><span class="line">                        <span class="comment">// 3: last char is ".."</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() != <span class="number">0</span> &amp;&amp; path[path.<span class="built_in">size</span>()<span class="number">-1</span>]!=<span class="string">'/'</span>) path.push_back(<span class="string">'/'</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = path.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = path[i];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (state == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'/'</span>) &#123; res.push_back(<span class="string">'/'</span>); state = <span class="number">1</span>; &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'.'</span>) state = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> res.push_back(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'/'</span>) &#123;&#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'.'</span>) &#123; state = <span class="number">2</span>; &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.push_back(c); state = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'/'</span>) state = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'.'</span>) &#123;</span><br><span class="line">                    <span class="comment">// '..'</span></span><br><span class="line">                    state = <span class="number">3</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.push_back(<span class="string">'.'</span>); res.push_back(c); state = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'/'</span>) &#123;</span><br><span class="line">                    <span class="comment">// go back</span></span><br><span class="line">                    res.pop_back(); <span class="comment">// pop '/'</span></span><br><span class="line">                    <span class="keyword">while</span>(res.<span class="built_in">size</span>() != <span class="number">0</span> &amp;&amp; *res.rbegin() != <span class="string">'/'</span>) &#123;</span><br><span class="line">                        res.pop_back(); <span class="comment">// pop anthing until '/'</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (res.<span class="built_in">size</span>() == <span class="number">0</span>) res.push_back(<span class="string">'/'</span>);</span><br><span class="line">                    state = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.push_back(<span class="string">'.'</span>); </span><br><span class="line">                    res.push_back(<span class="string">'.'</span>);</span><br><span class="line">                    res.push_back(c);</span><br><span class="line">                    state = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; state &lt;&lt; " " &lt;&lt; c &lt;&lt; " " &lt;&lt; res &lt;&lt;  endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((state == <span class="number">1</span> &amp;&amp; res.<span class="built_in">size</span>() != <span class="number">1</span>)) res.pop_back();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>update at 2020-03-23</p></blockquote><p>状态转移图：</p><p><img src="https://g.gravizo.com/svg?%20digraph%20G%20%7B%20State0%20%5Bshape%20=%20circle%5D%20State1%20%5Bshape%20=%20circle%5D%20State2%20%5Bshape%20=%20circle%5D%20State3%20%5Bshape%20=%20circle%5D%20State0%20-%3E%20State1%20%5Blabel%20=%20%22slash%22%5D;%20State0%20-%3E%20State0%20%5Blabel%20=%20%22char%22%5D;%20State0%20-%3E%20State2%20%5Blabel%20=%20%22point%22%5D;%20State1%20-%3E%20State0%20%5Blabel%20=%20%22char%22%5D;%20State1%20-%3E%20State1%20%5Blabel%20=%20%22slash%22%5D;%20State1%20-%3E%20State2%20%5Blabel%20=%20%22point%22%5D;%20State2%20-%3E%20State3%20%5Blabel%20=%20%22point%22%5D;%20State2%20-%3E%20State0%20%5Blabel%20=%20%22char%22%5D;%20State2%20-%3E%20State1%20%5Blabel%20=%20%22slash%22%5D;%20State3%20-%3E%20State0%20%5Blabel%20=%20%22char%20and%20point%22%5D;%20State3%20-%3E%20State1%20%5Blabel%20=%20%22slash%22%5D;%20%7D" alt="FSM"></p><p>这道题其实用栈会更简单一点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">simplifyPath</span><span class="params">(<span class="built_in">string</span> path)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; st;</span><br><span class="line">    <span class="keyword">int</span> beg = <span class="number">0</span>;</span><br><span class="line">    path.push_back(<span class="string">'/'</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, sz = path.<span class="built_in">size</span>(); i &lt; sz; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (path[i] == <span class="string">'/'</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> s = path.substr(beg, i-beg);</span><br><span class="line">            beg = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="string">"."</span> || s.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">".."</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (st.<span class="built_in">size</span>() != <span class="number">0</span>) st.pop_back(); <span class="comment">// make sure '/../' is ok</span></span><br><span class="line">            &#125; <span class="keyword">else</span> st.push_back(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;s: st) &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; s &lt;&lt; endl;</span></span><br><span class="line">        res.push_back(<span class="string">'/'</span>);</span><br><span class="line">        res += s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="built_in">size</span>() == <span class="number">0</span>) res.push_back(<span class="string">'/'</span>); </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>stringstream</code>和<code>getline</code>来进行字符串分割：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">simplifyPath</span><span class="params">(<span class="built_in">string</span> path)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> buf;</span><br><span class="line">    <span class="function"><span class="built_in">istringstream</span> <span class="title">ss</span><span class="params">(path)</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; st;</span><br><span class="line">    <span class="keyword">while</span>(getline(ss, buf, <span class="string">'/'</span>)) &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (buf == <span class="string">"."</span> || buf.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buf == <span class="string">".."</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (st.<span class="built_in">size</span>() != <span class="number">0</span>) st.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> st.push_back(buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;s: st) &#123;</span><br><span class="line">        res.push_back(<span class="string">'/'</span>);</span><br><span class="line">        res += s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="built_in">size</span>() == <span class="number">0</span>) res.push_back(<span class="string">'/'</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Stack </tag>
            
            <tag> String </tag>
            
            <tag> FSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZigZag Conversion</title>
      <link href="/2019/02/15/ZigZag-Conversion/"/>
      <url>/2019/02/15/ZigZag-Conversion/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第二天。今天AC掉了一道之前没AC掉的题目。。。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/zigzag-conversion/" target="_blank" rel="noopener">6. ZigZag Conversion</a></p><p>题目描述：</p><p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure><p>And then read line by line: “PAHNAPLSIIGYIR”</p><p>Write the code that will take a string and make this conversion given a number of rows:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span></span>;</span><br></pre></td></tr></table></figure><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;PAYPALISHIRING&quot;, numRows &#x3D; 3</span><br><span class="line">Output: &quot;PAHNAPLSIIGYIR&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;PAYPALISHIRING&quot;, numRows &#x3D; 4</span><br><span class="line">Output: &quot;PINALSIGYAHRPI&quot;</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure><p>恩，又是一道“编程题“， 并不涉及到什么算法，静下心来仔细想想还是能做出来的。做这道题的思路就是<strong>一点一点跑例子</strong>，找出其中的规律就好了。</p><p>我们先以输入为<code>s = &quot;PAYPALISHIRING&quot;, numRows = 3</code>为例子，这是题目给出的例子，正确答案已经有了。</p><p>先把Z字型画出来（不难发现，题目在最开始其实已经给出了答案）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure><p>观察上面的例子我们可以发现：</p><ul><li>第一行中的元素在原来的字符串中下标相差4个。</li><li>第二行中的元素在原来字符串中下标相差2个。</li></ul><p>ok，看起来好像找到了一些规律，继续跑一个例子验证一下，这次的输入是<code>s = &quot;PAYPALISHIRING&quot;, numRows = 3</code>，把Z字型画出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure><p>可以看到第一行的元素在原来字符串中的下标相差6个，但是第二行却出现了一些不一样的情况：</p><ul><li><code>A</code>与<code>L</code>相差4个，<code>L</code>与<code>S</code>却相差2个</li><li><code>S</code>与<code>I</code>相差4个，<code>I</code>与<code>G</code>却相差2个</li></ul><p>看起来<code>offset</code>是有规律的，而且好像需要分成两种情况，继续看看第3行：</p><ul><li><code>Y</code>与<code>A</code>相差2个，<code>A</code>与<code>H</code>相差4个</li><li><code>H</code>与<code>R</code>相差4个，如果还有元素的话，下一个元素与<code>R</code>之间显然相差2个。</li></ul><p>从上面的例子来看显然是要分成两种情况的，某一行中下标之间的<code>offset</code>是不断在两个数字间不断变换的。</p><p>我们尝试用两个数组来保存这些<code>offset</code>，我们把这两个数组定义为<code>skipDown</code>和<code>skipUp</code>。其中<code>skipDown</code>表示下标在z字型中经过了一个向下的剪头，如第二个例子中，第一行的<code>P</code>移动到<code>I</code>时，<code>P</code>经过了<code>AYPAl</code>组成的向下的剪头。<code>skipUp</code>同理可推。</p><p>如果我们继续跑例子的话，应该是比较容易找出规律的：</p><ul><li>第<code>i</code>行的<code>skipDown</code>为<code>2*(i-1)</code>，而第一行和最后一行的<code>skipDown</code>都应该为<code>2*(numRows)</code>。</li><li><code>skipDown</code>与<code>skipUp</code>是逆序的关系。</li></ul><p>综上，我们可以写出下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numRows &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">skipDown</span><span class="params">(numRows)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">skipUp</span><span class="params">(numRows)</span></span>;</span><br><span class="line">    </span><br><span class="line">    skipDown[<span class="number">0</span>] = <span class="number">2</span>*(numRows<span class="number">-1</span>);</span><br><span class="line">    skipUp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; numRows; i++) &#123;</span><br><span class="line">        skipDown[i] = skipDown[i<span class="number">-1</span>] - <span class="number">2</span>;</span><br><span class="line">        skipUp[i] = skipUp[i<span class="number">-1</span>] + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    skipDown[numRows<span class="number">-1</span>] = skipDown[<span class="number">0</span>];</span><br><span class="line">    skipUp[<span class="number">0</span>] = skipUp[numRows<span class="number">-1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">res</span><span class="params">(s.size(), <span class="string">' '</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; numRows; i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt; s.size();index++) &#123;</span><br><span class="line">            res[index] = s[j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (flag) &#123; j += skipDown[i]; &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; j += skipUp[i]; &#125;</span><br><span class="line">            </span><br><span class="line">            flag = !flag;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这肯定不是最优的代码，比如其实我们可以不用两个数组，甚至不用数组来保存的<code>offset</code>，但是这样写会比较容易理解，代码会比较简单点。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String-to-Integer(atoi)</title>
      <link href="/2019/02/14/String-to-Integer-atoi/"/>
      <url>/2019/02/14/String-to-Integer-atoi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>hhh, 开始一天一道LeetCode吧, 恩, 忘记了之前算到第几天了, 那么从头开始吧, 今天是第一天.</p></blockquote><p>今天的题目是(8. String to Integer (atoi))[<a href="https://leetcode.com/problems/string-to-integer-atoi/]" target="_blank" rel="noopener">https://leetcode.com/problems/string-to-integer-atoi/]</a></p><p>题目描述:</p><p>Implement atoi which converts a string to an integer.</p><p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p><p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p><p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p><p>If no valid conversion could be performed, a zero value is returned.</p><p>Note:</p><ul><li>Only the space character ‘ ‘ is considered as whitespace character.</li><li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. If the numerical value is out of the range of representable values, INT_MAX (2^31 − 1) or INT_MIN (−2^31) is returned.</li></ul><p>Example 1:</p><blockquote><p>Input: “42”<br>Output: 42</p></blockquote><p>Example 2:</p><blockquote><p>Input: “   -42”<br>Output: -42<br>Explanation: The first non-whitespace character is ‘-‘, which is the minus sign. Then take as many numerical digits as possible, which gets 42.</p></blockquote><p>Example 3:</p><blockquote><p>Input: “4193 with words”<br>Output: 4193<br>Explanation: Conversion stops at digit ‘3’ as the next character is not a numerical digit.</p></blockquote><p>Example 4:</p><blockquote><p>Input: “words and 987”<br>Output: 0<br>Explanation: The first non-whitespace character is ‘w’, which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed.</p></blockquote><p>Example 5:</p><blockquote><p>Input: “-91283472332”<br>Output: -2147483648<br>Explanation: The number “-91283472332” is out of the range of a 32-bit signed integer. Thefore INT_MIN (−231) is returned.</p></blockquote><p>怎么说呢， 这是一道编程題， 而不是算法题， 事实上没用到什么算法， 把逻辑理清楚， 然后注意一下坑就好了。</p><p>我们现在来理一理<code>atoi()</code>的逻辑：</p><ul><li>我们要跳过字符串开头的所有空格。</li><li>第一个非空格字符，只能是<code>+</code>, <code>-</code>以及<code>0</code>到<code>9</code>的所以数字。</li><li>如果第一个非空格字符是<code>-</code>， 我们就要返回一个负数。</li><li>解析字符串中的数字， 直到遇到第一个非数字就结束（或者遍历晚字符串）</li><li>然后如果在解析数字的时候发现， 如果溢出了， 就直接返回<code>INT_MAX</code>或<code>INT_MIN</code>(看前面是否有符号)</li></ul><p>感觉整个逻辑还是比较好写的， 就只有一个麻烦点：<code>怎么判断是否溢出了？</code></p><p>有两个方法：</p><ul><li><p>方法一：</p><p>  因为<code>atoi()</code>只解析32位的有符号整数， 所以我们可以直接用64位的整数来计算结果，这样就可以直接判断是否超出32位的范围了，也就是用<code>long long</code>, 但是这样要计算64位的乘法和加法，会比较耗时。</p></li><li><p>方法二：</p><p>  直接用32位的整数来计算结果， 在解释这个方法前，我们先看下是如何解析数字的, 解析数字主要就是把单个字符转成数字， 然后通过以下等式来迭代计算结果<code>res = res * 10 + i;</code>。可以看到这里有一个乘10的计算，所以我们可以在计算这个等式之前， 用<code>INT_MAX/10</code>来判断是否溢出。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// clear space</span></span><br><span class="line">    <span class="keyword">int</span> beg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(beg &lt; str.size()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = str[beg];</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">' '</span>) beg++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'-'</span> || c == <span class="string">'+'</span>||(c &lt;= <span class="string">'9'</span> &amp;&amp; c &gt;= <span class="string">'0'</span>)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> max_num = INT_MAX;</span><br><span class="line">    <span class="comment">// if we have '+' or '-'</span></span><br><span class="line">    <span class="keyword">if</span> (str[beg] == <span class="string">'+'</span>) &#123;</span><br><span class="line">        beg++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[beg] == <span class="string">'-'</span>) &#123;</span><br><span class="line">        beg++;</span><br><span class="line">        sign = <span class="number">-1</span>; max_num = INT_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> c = INT_MAX/<span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(;beg &lt; str.size() &amp;&amp; str[beg] &gt;= <span class="string">'0'</span> &amp;&amp; str[beg] &lt;= <span class="string">'9'</span>; beg++) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = str[beg]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span> (res &gt; c || (res == c &amp;&amp; i &gt; <span class="number">7</span>)) <span class="keyword">return</span> max_num;</span><br><span class="line">        res = res * <span class="number">10</span> + i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sign*res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次Hexo迁移</title>
      <link href="/2019/02/14/%E8%AE%B0%E4%B8%80%E6%AC%A1Hexo%E8%BF%81%E7%A7%BB/"/>
      <url>/2019/02/14/%E8%AE%B0%E4%B8%80%E6%AC%A1Hexo%E8%BF%81%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>很久没有写过Blog了, 而且也把系统换成了Manjaro, 所以又要再配置一次Hexo的环境等等, 为了下次迁移的时候, 能更快的搞定, 所以记录一下这次迁移的过程.</p></blockquote><h2 id="获取源文件"><a href="#获取源文件" class="headerlink" title="获取源文件"></a>获取源文件</h2><p>Hexo如果需要迁移的话, 只需要保留以下几个文件即可:</p><ul><li>_config.yml</li><li>theme/</li><li>source/</li><li>scaffold/</li><li>package.json</li><li>.gitignore</li></ul><p>因为之前已经迁移过一次了, 所以我的源文件都已经保存在github上了, 在<a href="https://github.com/wuxiaobai24/wuxiaobai24.github.io" target="_blank" rel="noopener">wuxiaobai24.github.io</a>起了一个<code>save</code>分支来保存文件.</p><p>所以获取源文件, 我只需要:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git@github.com:wuxiaobai24/wuxiaobai24.github.io.git</span></span><br></pre></td></tr></table></figure><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>这一步网上大多教程都写的很清楚了, 这里简略提一下, 主要是以下几个步骤:</p><ol><li>安装npm</li><li>用npm安装hexo</li><li>hexo init blog</li><li>把上面提到的源文件全部拷贝到blog文件夹中</li></ol><p><strong>注意:这里的blog文件最好放在wuxiaobai24.github.io目录下</strong>, 这样利用backups.sh可以很快的把源文件拷贝到blog文件夹中, 但是<strong>记得把backups.sh里面最后三行关于git的删去或注释掉</strong></p><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><ol><li><p>首先先把主题安装下来先, 之前因为忘记了这个, 导致<code>hexo generate</code>失败</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git@github.com:litten/hexo-theme-yilia.git themes/yilia</span></span><br></pre></td></tr></table></figure></li><li><p>npm install</p></li><li><p>检测是否成功</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo g</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo s</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="构建快速的写作环境"><a href="#构建快速的写作环境" class="headerlink" title="构建快速的写作环境"></a>构建快速的写作环境</h2><ol><li>将blog移到任何你想要放的位置, 然后把之前的<code>wuxiaobai24.github.io</code>文件夹删去</li><li>在blog目录下, <code>git clone git@github.com:wuxiaobai24/wuxiaobai24.github.io.git</code></li><li>在vscode中安装<code>vscode-hexo</code>插件</li></ol><p>主要的工作流为:</p><ol><li>vscode中<code>&gt; hexo new</code>生成新的文章</li><li>写文章, 并<code>&gt; hexo generate</code></li><li>vscode中<code>&gt; hexo deplot</code>部署</li><li>最后在命令行下切换到<code>blog/wuxiaobai24.github.io</code>中, 执行<code>backups.sh</code>备份源文件.</li></ol><p>PS: 个人建议把主题的config.yml也备份一下.</p>]]></content>
      
      
      <categories>
          
          <category> 杂事一堆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Palindromic-SubStrings</title>
      <link href="/2018/03/05/Palindromic-SubStrings/"/>
      <url>/2018/03/05/Palindromic-SubStrings/</url>
      
        <content type="html"><![CDATA[<p>今天的题目是<a href="https://leetcode.com/problems/palindromic-substrings/description/" target="_blank" rel="noopener">Palindromic Substrings</a>:</p><p>Given a string, your task is to count how many palindromic substrings in this string.</p><p>The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.</p><p>Example 1:<br>Input: “abc”<br>Output: 3<br>Explanation: Three palindromic strings: “a”, “b”, “c”.<br>Example 2:<br>Input: “aaa”<br>Output: 6<br>Explanation: Six palindromic strings: “a”, “a”, “a”, “aa”, “aa”, “aaa”.<br>Note:<br>The input string length won’t exceed 1000.</p><p>主要思路：</p><p>很敏感的想到了动态规划，比如说我们现在想要知道<code>aabaa</code>是不是回文，如果我们已经求出来<code>aba</code>是回文，那么我就可以之间判断第一个字符和最后一个字符是否相等即可，还有一点就是如果要判断的字符串的长度为1或0，显然就可以之间返回为是字符串啦。</p><p>所以我们可以写出动规方程：</p><p>dp[first][last] = (dp[first+1][last-1] || last-first-2 &lt;= 0) &amp;&amp; s[first] == s[last];</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(<span class="built_in">size</span>,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(<span class="built_in">size</span>,<span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="built_in">size</span><span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt; <span class="built_in">size</span>;j++) &#123;</span><br><span class="line">                dp[i][j] = s[i] == s[j] &amp;&amp; (j-i<span class="number">-2</span> &lt;= <span class="number">0</span> || dp[i+<span class="number">1</span>][j<span class="number">-1</span>]);</span><br><span class="line">                res += dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Queue Reconstruction by Height</title>
      <link href="/2018/03/04/Queue-Reconstruction-by-Height/"/>
      <url>/2018/03/04/Queue-Reconstruction-by-Height/</url>
      
        <content type="html"><![CDATA[<p>题目是<a href="https://leetcode.com/problems/queue-reconstruction-by-height/description/" target="_blank" rel="noopener">Queue Reconstruction by Height</a>:</p><p>题目描述：</p><p>Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue.</p><p>Note:<br>The number of people is less than 1,100.</p><p>Example</p><p>Input:<br>[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</p><p>Output:<br>[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</p><p>求解思路：</p><p>很好玩的题目，一开始是没有思路怎么做的，先解释一下题目先</p><p>首先它的输入是一个格式为<code>(h,k)</code>的二元组的列表，<code>h</code>表示<code>person</code>的高度，然后<code>k</code>是在队伍中站在它前面且高度大于等于他的人的个数。</p><p>我们要根据这些信息来重建这个队列（输入是乱的），是它符合上面的格式。</p><p>首先想到的就是先排序，不排序，肯定要一直扫描所有的person才能得到我们的想要的信息。</p><p>然后就按<code>h</code>的顺序来排序，当<code>h</code>相等时就按<code>k</code>排序。</p><p>按照上面的样例进行排序就得到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">4</span>,<span class="number">4</span>], [<span class="number">5</span>, <span class="number">0</span>], [<span class="number">5</span>, <span class="number">1</span>], [<span class="number">6</span>, <span class="number">1</span>], [<span class="number">7</span>, <span class="number">0</span>], [<span class="number">7</span>, <span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p>我们先考虑第一个位置放什么，从头开始扫描：<br><code>[4,4]</code>显然不是，<code>[5, 0]</code>，因为<code>k</code>为0，所以显然就是它了，我们并不需要扫描到后面去，因为它是高度最小的且<code>k</code>为<code>0</code>的<code>person</code>,所以我们可以直接把它放到第一个位置上去，这样的话，现在我们考虑可以第二个位置了，有了放第一个的方法，我们就可以递归的去做，现在是找<code>[[4,4],[5,1],[6,1],[7,0],[7,1]</code>第一个放的位置，直接扫过去就可以得到<code>[7,0]</code>的位置，看起来好像是对的方法，但是我们很容易就发现，下一个我们就没法找出来了，因为没有<code>k</code>为<code>0</code>的<code>person</code>了，所以我们要不断的更新去做，比如<code>[5, 0]</code>移动到第一个位置需要经过<code>[4,4]</code>，那么这时<code>[4,4]</code>前面就站着一个<code>[5,0]</code>而且比他高，所以在后面的扫描中，它的<code>k</code>应该就是<code>3</code>了，<code>[7,0]</code>向前移动的时候同理，<code>[4,4], [5, 1], [6, 1]</code>的<code>k</code>都需要减一。</p><p>因为我们是不能直接修改<code>people</code>的<code>k</code>的，所以我们需要一个数组来保存。</p><p>还有一点就是上面没有考虑到高度相同的情况，比如<code>[7,0],[7,1]</code>，第二个人前面其实已经站着一个高度大于等于它的人了，其实它的<code>k</code>其实应该是<code>0</code>,而不是<code>1</code>，所以我们需要继续调整，因为可能会出现<code>[7,0],[7,1],[7,2]</code>的情况，所以在从前往后生成新的数组保存<code>k</code>值的时候，我们还需要向前扫描看前面有多少个高度相同的人才能计算出实际的<code>k</code>值，这样的时间复杂度是<code>O(n^2)</code>，所以我们不保存<code>k</code>值，我们保存<code>k</code>前面有多少个高度大于等于它的人，这样的生成辅助数据的时间复杂度就是<code>O(n)</code>了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;pair&lt;int, int&gt;&gt; reconstructQueue(vector&lt;pair&lt;int, int&gt;&gt;&amp; people) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> size = people.size();</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span> || size == <span class="number">1</span>) <span class="keyword">return</span> people;</span><br><span class="line"></span><br><span class="line">        sort(people.begin(), people.end(), [](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;p1,<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;p2) &#123;</span><br><span class="line">            <span class="keyword">return</span> p1.first &lt; p2.first || (p1.first == p2.first &amp;&amp; p1.second &lt; p2.second);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">m</span><span class="params">(size, <span class="number">0</span>)</span></span>;</span><br><span class="line">        m[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; size;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (people[i].first == people[i<span class="number">-1</span>].first) &#123;</span><br><span class="line">                m[i] = m[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> m[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// like insert sort.</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; size;i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = people[i];</span><br><span class="line">            <span class="keyword">int</span> t = m[i], j;</span><br><span class="line">            <span class="keyword">for</span>(j = i<span class="number">-1</span>;j &gt;= <span class="number">0</span> &amp;&amp; (p.second - t) &lt; (people[j].second - m[j]) ;j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (people[j].first &lt;= p.first) m[j]++;</span><br><span class="line">                people[j+<span class="number">1</span>] = people[j];</span><br><span class="line">                m[j+<span class="number">1</span>] = m[j];</span><br><span class="line">            &#125;</span><br><span class="line">            people[j+<span class="number">1</span>] = p;</span><br><span class="line">            m[j+<span class="number">1</span>] = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> people;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Count Complete Tree Nodes</title>
      <link href="/2018/03/03/Count-Complete-Tree-Nodes/"/>
      <url>/2018/03/03/Count-Complete-Tree-Nodes/</url>
      
        <content type="html"><![CDATA[<p>题目是<a href="https://leetcode.com/problems/count-complete-tree-nodes/description/" target="_blank" rel="noopener">Count Complete Tree Nodes</a>:</p><p>题目描述：</p><p>Given a complete binary tree, count the number of nodes.</p><p>Definition of a complete binary tree from Wikipedia:<br>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</p><p>求解思路：</p><p>一开始想的是想法是，我们把最后一层的个数计算出来就简单很多了，所以我们可以先计算树的高度，然后用二分查找算出层数，虽然能过，但是很慢很慢（为什么我算出来的时间复杂度是<code>O(lgn*lgn)</code>啊。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">        <span class="keyword">while</span>(p) &#123;</span><br><span class="line">            p = p-&gt;left; height++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; height &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = <span class="built_in">pow</span>(<span class="number">2</span>, height - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> count = high;</span><br><span class="line">        <span class="keyword">int</span> h, mid, t, m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">1</span> &lt;&lt; (height - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">/* cout &lt;&lt; low &lt;&lt;" "</span></span><br><span class="line"><span class="comment">                &lt;&lt; mid &lt;&lt; " "</span></span><br><span class="line"><span class="comment">                &lt;&lt; high &lt;&lt; endl; */</span></span><br><span class="line"></span><br><span class="line">            p = root; h = height; t = mid;</span><br><span class="line">            m = mask;</span><br><span class="line">            <span class="keyword">while</span>(p) &#123;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; "#" &lt;&lt; p-&gt;val &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">if</span> (t &amp; m) p = p-&gt;right;</span><br><span class="line">                <span class="keyword">else</span> p = p-&gt;left;</span><br><span class="line">                h--;</span><br><span class="line">                m = m&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; h &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (h == <span class="number">0</span>) low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; low &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count + low - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后就想着不要那么复杂，我们先看左子树是不是满二叉树，如果不是，我们就可以通过左子树的高度来求右子树的节点个数了，但是这样方法在<code>c++</code>上是跑不过去的，但是在<code>python</code>中很快，很奇怪的是同样的测例，<code>c++</code>的版本要<code>400ms</code>左右，但是<code>python</code>的版本只要<code>40ms</code>左右，而且这个做法在<code>python</code>中还是比较快的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countNodes(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if root is None:</span><br><span class="line">            return 0</span><br><span class="line">        h, count, iffull &#x3D; self.countNodesHelper(root)</span><br><span class="line">        return count</span><br><span class="line"></span><br><span class="line">    def countNodesHelper(self, root):</span><br><span class="line">        if root is None:</span><br><span class="line">            return 0, 0, True</span><br><span class="line">        left_h, left_count, left_full &#x3D; self.countNodesHelper(root.left)</span><br><span class="line">        if not left_full:</span><br><span class="line">            # print(&#39;not full&#39;)</span><br><span class="line">            return left_h + 1, left_count + 2**(left_h - 1), False</span><br><span class="line"></span><br><span class="line">        right_h, right_count, right_full &#x3D; self.countNodesHelper(root.right)</span><br><span class="line">        # print(left_count + right_count + 1)</span><br><span class="line">        return left_h+1, left_count + right_count + 1, left_full and right_full and left_h &#x3D;&#x3D; right_h</span><br></pre></td></tr></table></figure><p>最后看一下<code>dicuss</code>中的解法，想法和我第二个解法有点类似，但是更简洁，应该也更快：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> hl=<span class="number">0</span>, hr=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    TreeNode *l=root, *r=root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l) &#123;hl++;l=l-&gt;left;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(r) &#123;hr++;r=r-&gt;right;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hl==hr) <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>,hl)<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+countNodes(root-&gt;left)+countNodes(root-&gt;right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Add Two Numbers II</title>
      <link href="/2018/03/02/Add-Two-Numbers-II/"/>
      <url>/2018/03/02/Add-Two-Numbers-II/</url>
      
        <content type="html"><![CDATA[<p>题目是<a href="https://leetcode.com/problems/add-two-numbers-ii/description/" target="_blank" rel="noopener">Add Two Numbers II</a>:</p><p>题目描述：</p><p>You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p>Follow up:<br>What if you cannot modify the input lists? In other words, reversing the lists is not allowed.</p><p>Example:</p><p>Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 8 -&gt; 0 -&gt; 7</p><p>求解思路：</p><p>这道题最简练的方法就是用栈了做了，然后还可以先计算出两个链表的长度，再生成链表。</p><p>思路都比较简单，emmm，一开始以为做成递归的会比较简单，后来发现不仅时间复杂度还是代码的复杂度都挺高的，做成迭代的会好很多。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1, s2;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>, v1, v2, v;</span><br><span class="line">        ListNode *cur;</span><br><span class="line">        ListNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l1 || l2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1) &#123; s1.push(l1-&gt;val); l1 = l1-&gt;next; &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2) &#123; s2.push(l2-&gt;val); l2 = l2-&gt;next; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">        <span class="keyword">while</span>(!s1.empty() || !s2.empty() || carry) &#123;</span><br><span class="line">            v1 = v2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!s1.empty()) &#123; v1 = s1.top(); s1.pop(); &#125;</span><br><span class="line">            <span class="keyword">if</span> (!s2.empty()) &#123; v2 = s2.top(); s2.pop(); &#125;</span><br><span class="line">            </span><br><span class="line">            v = v1 + v2 + carry;</span><br><span class="line">            cur  = <span class="keyword">new</span> ListNode(v % <span class="number">10</span>);</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            carry = v /<span class="number">10</span>;</span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>给出一个<code>dicuss</code>中的方法，很巧妙，用的是翻转链表（题目说不能修改原来的链表，所以这里是翻转output):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1 = <span class="number">0</span>, n2 = <span class="number">0</span>, carry = <span class="number">0</span>;</span><br><span class="line">    ListNode *curr1 = l1, *curr2 = l2, *res = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>( curr1 )&#123; curr1=curr1-&gt;next; n1++; &#125;</span><br><span class="line">    <span class="keyword">while</span>( curr2 )&#123; curr2=curr2-&gt;next; n2++; &#125; </span><br><span class="line">    curr1 = l1; curr2 = l2;</span><br><span class="line">    <span class="keyword">while</span>( n1 &gt; <span class="number">0</span> &amp;&amp; n2 &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>( n1 &gt;= n2 )&#123; sum += curr1-&gt;val; curr1=curr1-&gt;next; n1--;&#125;</span><br><span class="line">        <span class="keyword">if</span>( n2 &gt; n1 )&#123; sum += curr2-&gt;val; curr2=curr2-&gt;next; n2--;&#125;</span><br><span class="line">        res = addToFront( sum, res );</span><br><span class="line">    &#125;</span><br><span class="line">    curr1 = res; res = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>( curr1 )&#123;</span><br><span class="line">        curr1-&gt;val += carry; carry = curr1-&gt;val/<span class="number">10</span>;</span><br><span class="line">        res = addToFront( curr1-&gt;val%<span class="number">10</span>, res );</span><br><span class="line">        curr2 = curr1; </span><br><span class="line">        curr1 = curr1-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> curr2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( carry ) res = addToFront( <span class="number">1</span>, res );</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">addToFront</span><span class="params">( <span class="keyword">int</span> val, ListNode* head )</span></span>&#123;</span><br><span class="line">    ListNode* temp = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">    temp-&gt;next = head;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Coin Change 2</title>
      <link href="/2018/03/01/Coin-Change-2/"/>
      <url>/2018/03/01/Coin-Change-2/</url>
      
        <content type="html"><![CDATA[<p>题目是<a href="https://leetcode.com/problems/coin-change-2/description/" target="_blank" rel="noopener">Coin Change 2</a>:</p><p>题目描述：</p><p>You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.</p><p>Note:<br>You can assume that</p><p> 0 &lt;= amount &lt;= 5000<br> 1 &lt;= coin &lt;= 5000<br> the number of coins is less than 500<br> the answer is guaranteed to fit into signed 32-bit integer</p><p>Example 1:</p><p>Input: amount = 5, coins = [1, 2, 5]<br>Output: 4<br>Explanation: there are four ways to make up the amount:<br>5=5<br>5=2+2+1<br>5=2+1+1+1<br>5=1+1+1+1+1</p><p>Example 2:</p><p>Input: amount = 3, coins = [2]<br>Output: 0<br>Explanation: the amount of 3 cannot be made up just with coins of 2.</p><p>Example 3:</p><p>Input: amount = 10, coins = [10]<br>Output: 1</p><p>求解思路：</p><p>又是一道动态规划的题目，最近不知道为什么，老是把问题想的太过于复杂，比如<code>change1</code>中的解法，就是不好的方法，时间复杂度是<code>O(amount*amount*size)</code>.</p><p>然后看了一下<code>dicuss</code>才知道还有时间复杂度更小的解法（其实就是最内层的循环是没必要的），然后是对空间复杂度进行了一下优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">change1</span><span class="params">(<span class="keyword">int</span> amount, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = coins.size();</span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(size + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(amount + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">       </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= size;i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= amount;j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> t = j;t &gt;= <span class="number">0</span>;t-=coins[i<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j] += dp[i<span class="number">-1</span>][t];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[size][amount];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">change2</span><span class="params">(<span class="keyword">int</span> amount, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = coins.size();</span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(size + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(amount + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">       </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= size;i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= amount;j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (coins[i<span class="number">-1</span>] &lt;= j)</span><br><span class="line">                    dp[i][j] += dp[i][j-coins[i<span class="number">-1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[size][amount];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = coins.size();</span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]  = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;coin:coins)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= amount;j++)</span><br><span class="line">                <span class="keyword">if</span> (coin &lt;= j)</span><br><span class="line">                    dp[j] += dp[j-coin];</span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Copy List with Random Pointer</title>
      <link href="/2018/02/28/Copy-List-with-Random-Pointer/"/>
      <url>/2018/02/28/Copy-List-with-Random-Pointer/</url>
      
        <content type="html"><![CDATA[<p>题目是<a href="https://leetcode.com/problems/copy-list-with-random-pointer/description/" target="_blank" rel="noopener">Copy List with Random Pointer</a>:</p><p>题目描述：</p><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p><p>Return a deep copy of the list.</p><p>求解思路：</p><p>很直观的方法，用来<code>O(n)</code>的空间来保存地址，没想到过了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="comment"> * struct RandomListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     RandomListNode *next, *random;</span></span><br><span class="line"><span class="comment"> *     RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;RandomListNode *, RandomListNode *&gt; m;</span><br><span class="line">        </span><br><span class="line">        RandomListNode *p = head;</span><br><span class="line">        <span class="function">RandomListNode <span class="title">copy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        RandomListNode *q = &amp;copy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(p) &#123;</span><br><span class="line">            </span><br><span class="line">            q-&gt;next = <span class="keyword">new</span> RandomListNode(p-&gt;label);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//auto it = m.find(p);</span></span><br><span class="line">            <span class="comment">//if (it != m.end()) it-&gt;second = q-&gt;next;</span></span><br><span class="line">            </span><br><span class="line">            m[p] = q-&gt;next;</span><br><span class="line">            </span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        m[<span class="literal">nullptr</span>] = <span class="literal">nullptr</span>;</span><br><span class="line">        p = head;</span><br><span class="line">        q = copy.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(p) &#123;</span><br><span class="line">            </span><br><span class="line">            q-&gt;random = m[p-&gt;random];</span><br><span class="line">            </span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> copy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>share一个<code>dicuss</code>中看到的方法：</p><p><img src="https://raw.githubusercontent.com/hot13399/leetcode-graphic-answer/master/138.%20Copy%20List%20with%20Random%20Pointer.jpg" alt=""></p><p>图片失效的话，直接去<a href="https://leetcode.com/problems/copy-list-with-random-pointer/discuss/43491/A-solution-with-constant-space-complexity-O(1)-and-linear-time-complexity-O(N)" target="_blank" rel="noopener">leetcode</a>中看原贴。</p>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Delete and Earn</title>
      <link href="/2018/02/27/Delete-and-Earn/"/>
      <url>/2018/02/27/Delete-and-Earn/</url>
      
        <content type="html"><![CDATA[<p>题目是<a href="https://leetcode.com/problems/delete-and-earn/description/" target="_blank" rel="noopener">Delete and Earn</a>:</p><p>题目描述：</p><p>Given an array nums of integers, you can perform operations on the array.</p><p>In each operation, you pick any nums[i] and delete it to earn nums[i] points.  After, you must delete every element equal to nums[i] - 1 or nums[i] + 1.</p><p>You start with 0 points.  Return the maximum number of points you can earn by applying such operations.</p><p>Example 1:</p><p>Input: nums = [3, 4, 2]<br>Output: 6<br>Explanation:<br>Delete 4 to earn 4 points, consequently 3 is also deleted.<br>Then, delete 2 to earn 2 points. 6 total points are earned.</p><p>Example 2:</p><p>Input: nums = [2, 2, 3, 3, 3, 4]<br>Output: 9<br>Explanation:<br>Delete 3 to earn 3 points, deleting both 2’s and the 4.<br>Then, delete 3 again to earn 3 points, and 3 again to earn 3 points.<br>9 total points are earned.</p><p>Note:<br>The length of nums is at most 20000.<br>Each element nums[i] is an integer in the range [1, 10000].</p><p>求解思路：</p><p>一道动态规划的题目，动态规划的题目做多了之后感觉都有套路了，这道题算是比较简单的套路吧。</p><p>先对输入进行一下收集（其实只做排序也应该可以，但是感觉会比较复杂一点），然后对于一个数来说他有两种可能，一种是<code>delete</code>，一种是不<code>delete</code>，然后根据不同的状态来计算即可。</p><p>感觉可以用四个int来进行空间上的优化，但我没试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteAndEarn</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:nums) m[i]++;</span><br><span class="line">        </span><br><span class="line">        vector&lt;pair&lt;int, int&gt; &gt; helper(m.begin(), m.end());</span><br><span class="line">        </span><br><span class="line">        sort(helper.begin(), helper.end(), [](pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;p1,pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;p2) &#123;</span><br><span class="line">            <span class="keyword">return</span> p1.first &lt; p2.first;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//for(int i = 0;i &lt; helper.size(); i++) &#123;</span></span><br><span class="line">        <span class="comment">//    cout &lt;&lt; helper[i].first &lt;&lt; helper[i].second &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(helper.size()+<span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">//delete</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nd</span><span class="params">(helper.size()+<span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">// no delete</span></span><br><span class="line">        d[<span class="number">1</span>] = helper[<span class="number">0</span>].first;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; helper.size()+<span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="comment">// set d</span></span><br><span class="line">            <span class="comment">/* if (helper[i-1].first-1 == helper[i-2].first) &#123;</span></span><br><span class="line"><span class="comment">                d[i] = helper[i-1].first * helper[i-1].second + max(d[i-2], nd[i-2]);</span></span><br><span class="line"><span class="comment">            &#125; else </span></span><br><span class="line"><span class="comment">                d[i] = helper[i-1].first * helper[i-1].second + max(d[i-1], nd[i-1]);</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            d[i] = helper[i<span class="number">-1</span>].first * helper[i<span class="number">-1</span>].second +</span><br><span class="line">                ( (helper[i<span class="number">-1</span>].first<span class="number">-1</span> == helper[i<span class="number">-2</span>].first)?max(d[i<span class="number">-2</span>], nd[i<span class="number">-2</span>]):max(d[i<span class="number">-1</span>], nd[i<span class="number">-1</span>]) );</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// set nd</span></span><br><span class="line">            nd[i] = max(d[i<span class="number">-1</span>], nd[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max(d[helper.size()], nd[helper.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Combination Sum II</title>
      <link href="/2018/02/26/Combination-Sum-II/"/>
      <url>/2018/02/26/Combination-Sum-II/</url>
      
        <content type="html"><![CDATA[<p>第107天。</p><p>虽然前几天都有刷题，但是没写blog。</p><p>题目是<a href="https://leetcode.com/problems/combination-sum-ii/description/" target="_blank" rel="noopener">Combination Sum II</a>:</p><p>题目描述：</p><p>Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.</p><p>Each number in C may only be used once in the combination.</p><p>Note:</p><p>All numbers (including target) will be positive integers.<br>The solution set must not contain duplicate combinations.</p><p>For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,<br>A solution set is: </p><p>[<br>  [1, 7],<br>  [1, 2, 5],<br>  [2, 6],<br>  [1, 1, 6]<br>]</p><p>求解思路：</p><p>显然是用回溯法来做了（也就是穷举），都成套路了，有一个难点就是这里要求不能重复，可能可以用<code>set</code>来做，这里采取的方法是先排序再回溯的方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(candidates.begin(), candidates.end(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a &gt; b;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        combinationSum2(candidates, <span class="number">0</span>, target, temp);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">combinationSum2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> beg, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// get a solution</span></span><br><span class="line">            ret.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = beg; i &lt; candidates.size() ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candidates[i] &gt; target) <span class="keyword">continue</span>;</span><br><span class="line">            temp.push_back(candidates[i]);</span><br><span class="line">            combinationSum2(candidates, i + <span class="number">1</span>, target - candidates[i], temp);</span><br><span class="line">            <span class="keyword">while</span>(i + <span class="number">1</span> &lt; candidates.size() &amp;&amp; candidates[i] == candidates[i+<span class="number">1</span>]) i++;</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Delete Operation for Two Strings</title>
      <link href="/2018/02/21/delete-operation-for-two-strings/"/>
      <url>/2018/02/21/delete-operation-for-two-strings/</url>
      
        <content type="html"><![CDATA[<p>第106天。</p><p>今天的题目是<a href="https://leetcode.com/problems/delete-operation-for-two-strings/description/" target="_blank" rel="noopener">Delete Operation for Two Strings</a>:</p><p>题目描述：</p><p>Given two words word1 and word2, find the minimum number of steps required to make word1 and word2 the same, where in each step you can delete one character in either string.</p><p>Example 1:</p><p>Input: “sea”, “eat”<br>Output: 2<br>Explanation: You need one step to make “sea” to “ea” and another step to make “eat” to “ea”.</p><p>Note:</p><p>The length of given words won’t exceed 500.<br>Characters in given words can only be lower-case letters.</p><p>求解思路：</p><p>这道题和数据结构的最后一道附加题有点像，好像是附加题的操作是改变，而这里的是删除，然后当时的解法在这道题上<code>AC</code>尴尬，果然当时最后一题还是写错了吗，我就说为什么没拿到<code>A+</code>嘛。</p><p>思路比较简单（毕竟是考试的时候都能想出来的方法），只要知道最长公共子串就好了。拿题目给出的例子来说<code>sea</code>和<code>eat</code>的<code>LCS</code>是<code>ea</code>这样只要删掉<code>s</code>和<code>t</code>即可达到相同，有趣的是<code>LSC</code>是算法课讲动态规划时讲的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = LCS(word1, word2);</span><br><span class="line">        <span class="keyword">return</span> word1.size() + word2.size()  - l - l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LCS</span><span class="params">(<span class="built_in">string</span> &amp;s1, <span class="built_in">string</span> &amp;s2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(s1.size() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(s2.size() + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; dp.size();i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; dp[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s1[i<span class="number">-1</span>] == s2[j<span class="number">-1</span>]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[s1.size()][s2.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Partition-List</title>
      <link href="/2018/02/20/Partition-List/"/>
      <url>/2018/02/20/Partition-List/</url>
      
        <content type="html"><![CDATA[<p>第105天。</p><p>今天的题目是<a href="https://leetcode.com/problems/partition-list/description/" target="_blank" rel="noopener">Patrition List</a>:</p><blockquote><p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</p></blockquote><blockquote><p>You should preserve the original relative order of the nodes in each of the two partitions.</p></blockquote><blockquote><p>For example,<br>Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,<br>return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5.</p></blockquote><p>一开始想复杂了，所以写的有点丑陋，主要的思想是，把一个链表划分成两个链表，一个大于，一个小于，然后在将他们拼接成一个链表即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">ListNode *less, *less_tail;</span><br><span class="line">ListNode *greater, *greater_tail;</span><br><span class="line"><span class="function">ListNode* <span class="title">partition1</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    less = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">    greater = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    less_tail = less; greater_tail = greater;</span><br><span class="line">    </span><br><span class="line">    helper(head, x);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//show(less);</span></span><br><span class="line">    <span class="comment">//show(greater);</span></span><br><span class="line">    </span><br><span class="line">    less_tail-&gt;next = greater-&gt;next;</span><br><span class="line">    greater_tail-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    less_tail = less-&gt;next;</span><br><span class="line">    <span class="comment">//less-&gt;next = greater-&gt;next = nullptr;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> less;</span><br><span class="line">    <span class="keyword">delete</span> greater;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> less_tail;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(ListNode *head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (head-&gt;val &lt; x) &#123;</span><br><span class="line">        less_tail-&gt;next = head; less_tail = less_tail-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        greater_tail-&gt;next = head; greater_tail = greater_tail-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    helper(head-&gt;next, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后简洁的解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">partition</span><span class="params">(ListNode *head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ListNode left(-1), right(-1);</span><br><span class="line">    </span><br><span class="line">    ListNode *l = &amp;left, *r = &amp;right;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(head) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val &lt; x) &#123;</span><br><span class="line">            l-&gt;next = head; l = l-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r-&gt;next = head; r = r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    l-&gt;next = right.next;</span><br><span class="line">    r-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> left.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Verify-Preorder-Serialization-of-a-Binary-Tree</title>
      <link href="/2018/02/19/Verify-Preorder-Serialization-of-a-Binary-Tree/"/>
      <url>/2018/02/19/Verify-Preorder-Serialization-of-a-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<p>第104天。</p><p>今天的题目是<a href="https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/description/" target="_blank" rel="noopener">331. Verify Preorder Serialization of a Binary Tree</a>:</p><blockquote><p>One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node’s value. If it is a null node, we record using a sentinel value such as #.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _9_</span><br><span class="line">    &#x2F;   \</span><br><span class="line">   3     2</span><br><span class="line">  &#x2F; \   &#x2F; \</span><br><span class="line"> 4   1  #  6</span><br><span class="line">&#x2F; \ &#x2F; \   &#x2F; \</span><br><span class="line"># # # #   # #</span><br></pre></td></tr></table></figure><blockquote><p>For example, the above binary tree can be serialized to the string “9,3,4,#,#,1,#,#,2,#,6,#,#”, where # represents a null node.</p><p>Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree.</p><p>Each comma separated value in the string must be either an integer or a character ‘#’ representing null pointer.</p><p>You may assume that the input format is always valid, for example it could never contain two consecutive commas such as “1,,3”.</p><p>Example 1:<br>“9,3,4,#,#,1,#,#,2,#,6,#,#”<br>Return true</p><p>Example 2:<br>“1,#”<br>Return false</p><p>Example 3:<br>“9,#,#,1”<br>Return false</p></blockquote><p>虽然题目很长，但是理解起来并不难，就是给你一串字符串表示一棵二叉树，用<code>,</code>分隔节点的值，用<code>#</code>表示空指针，然后问你这个字符串能不能还原出来一棵二叉树（在不建树的情况下）,其实和建树很像，都是递归的去做：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidSerialization</span><span class="params">(<span class="built_in">string</span> preorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> beg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> isValidSerialization(preorder,beg) &amp;&amp; !next(preorder, beg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidSerialization</span><span class="params">(<span class="built_in">string</span> preorder, <span class="keyword">int</span> &amp;beg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beg &gt;= preorder.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (preorder[beg] == <span class="string">'#'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> next(preorder, beg) &amp;&amp; isValidSerialization(preorder, beg) &amp;&amp;</span><br><span class="line">        next(preorder, beg) &amp;&amp; isValidSerialization(preorder, beg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">next</span><span class="params">(<span class="built_in">string</span> &amp;preorder, <span class="keyword">int</span> &amp;beg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(beg &lt; preorder.<span class="built_in">size</span>() &amp;&amp; preorder[beg] != <span class="string">','</span>) beg++;</span><br><span class="line">    beg++;</span><br><span class="line">    <span class="keyword">return</span> beg &lt; preorder.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是<code>dicuss</code>中的迭代版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidSerialization</span><span class="params">(<span class="built_in">string</span> preorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preorder.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    preorder+=<span class="string">','</span>;</span><br><span class="line">    <span class="keyword">int</span> sz=preorder.<span class="built_in">size</span>(),idx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> capacity=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (idx=<span class="number">0</span>;idx&lt;sz;idx++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder[idx]!=<span class="string">','</span>) <span class="keyword">continue</span>;</span><br><span class="line">        capacity--;</span><br><span class="line">        <span class="keyword">if</span> (capacity&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (preorder[idx<span class="number">-1</span>]!=<span class="string">'#'</span>) capacity+=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> capacity==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Update at 2020-04-02</p></blockquote><p>补充一个自己的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidSerialization</span><span class="params">(<span class="built_in">string</span> preorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, c, <span class="built_in">size</span>; </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>, c = <span class="number">1</span>, <span class="built_in">size</span> = preorder.<span class="built_in">size</span>(); i &lt; <span class="built_in">size</span> &amp;&amp; c; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder[i] == <span class="string">'#'</span>) c--;</span><br><span class="line">        <span class="keyword">else</span> c++; <span class="comment">// c--; c+=2;</span></span><br><span class="line">        <span class="comment">// move next node</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; <span class="built_in">size</span> &amp;&amp; preorder[i]!=<span class="string">','</span>) i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c == <span class="number">0</span> &amp;&amp; i &gt;= <span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Coin-Change</title>
      <link href="/2018/02/19/Coin-Change/"/>
      <url>/2018/02/19/Coin-Change/</url>
      
        <content type="html"><![CDATA[<p>第104天。</p><p>熬夜写的一道题。。。</p><p>今天的题目是<a href="https://leetcode.com/problems/coin-change/description/" target="_blank" rel="noopener">Coin Change</a>:</p><blockquote><p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p><p>Example 1:<br>coins = [1, 2, 5], amount = 11<br>return 3 (11 = 5 + 5 + 1)</p><p>Example 2:<br>coins = [2], amount = 3<br>return -1.</p><p>Note:<br>You may assume that you have an infinite number of each kind of coin.</p></blockquote><p>想到动态规划后就简单了,但是容易超时，超时的解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount+<span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:coins)</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= amount) dp[i] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= amount;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j] != INT_MAX &amp;&amp; dp[i-j] != INT_MAX) </span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[j] + dp[i-j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[amount] == INT_MAX?<span class="number">-1</span>:dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的复杂度是<code>O(amount^2)</code>，当<code>amount</code>比较大的时候就跑不动了，修改成<code>O(n*amount)</code>后就能<code>AC</code>掉了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount+<span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">    </span><br><span class="line">    sort(coins.<span class="built_in">begin</span>(), coins.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:coins)</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= amount) dp[i] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= amount;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; coins.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coins[j] &gt; i || dp[i - coins[j]] == INT_MAX)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[amount] == INT_MAX?<span class="number">-1</span>:dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dicuss</code>中的解法类似，但是比较简洁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Max = amount + <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, Max)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] &gt; amount ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unique-Binary-Search-Trees-II</title>
      <link href="/2018/02/17/Unique-Binary-Search-Trees-II/"/>
      <url>/2018/02/17/Unique-Binary-Search-Trees-II/</url>
      
        <content type="html"><![CDATA[<p>第103天。</p><p>今天的题目是<a href="https://leetcode.com/problems/unique-binary-search-trees-ii/description/" target="_blank" rel="noopener">95. Unique Binary Search Trees II</a>:</p><blockquote><p>Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1…n.</p></blockquote><blockquote><p>For example,<br>Given n = 3, your program should return all 5 unique BST’s shown below.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>         <span class="number">3</span>     <span class="number">3</span>      <span class="number">2</span>      <span class="number">1</span></span><br><span class="line"> \       /     /      / \      \</span><br><span class="line">  <span class="number">3</span>     <span class="number">2</span>     <span class="number">1</span>      <span class="number">1</span>   <span class="number">3</span>      <span class="number">2</span></span><br><span class="line"> /     /       \                 \</span><br><span class="line"><span class="number">2</span>     <span class="number">1</span>         <span class="number">2</span>                 <span class="number">3</span></span><br></pre></td></tr></table></figure><p>比较有趣的一道题目，主要是怎么穷举出所以的可能，一开始我是想着将问题从<code>n</code>减少到<code>n-1</code>这样来做，后来发现好像这样很难弄的样子，后来突然想到我们可以利用<code>BST</code>的性质，即对于当前节点来说，左子树的节点的值一定比当前节点的小，右子树的节点的值一定比当前节点的大，那么我们可以这样来做：</p><p>比如如果<code>n = 3</code>，那么这棵树就由<code>[1,2,3]</code>组成，那么先确定根节点的值，确定根节点后就可以确定左子树中可能出现的值，和右子树中可能出现的值，这样我们就能将问题简化并递归求解下去了：</p><p>看代码吧，其实这次代码比较简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> generateTrees(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;TreeNode *&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> beg, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode *&gt; ret;</span><br><span class="line">    <span class="keyword">if</span> (beg &gt; <span class="built_in">end</span>) <span class="keyword">return</span> ret;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = beg;i &lt;= <span class="built_in">end</span>;i++) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode *&gt; left = generateTrees(beg, i<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode *&gt; right = generateTrees(i+<span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (left.<span class="built_in">size</span>() == <span class="number">0</span>) left.push_back(<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">if</span> (right.<span class="built_in">size</span>() == <span class="number">0</span>) right.push_back(<span class="literal">nullptr</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> l:left)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> r:right) &#123;</span><br><span class="line">                <span class="keyword">auto</span> p = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                p-&gt;left = l;</span><br><span class="line">                p-&gt;right = r;</span><br><span class="line">                ret.push_back(p);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Set-Matrix-Zeroes</title>
      <link href="/2018/02/16/Set-Matrix-Zeroes/"/>
      <url>/2018/02/16/Set-Matrix-Zeroes/</url>
      
        <content type="html"><![CDATA[<p>第102天。</p><p>今天的题目是<a href="https://leetcode.com/problems/set-matrix-zeroes/description/" target="_blank" rel="noopener">Set Matrix Zeroes</a>:</p><blockquote><p>Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.</p></blockquote><p>虽然题目看起来很简单，但是还是有一些坑点的，因为你一检测到一个<code>0</code>就马上把它所在的行和列置零，这样会影响到后面检测零的操作（因为无法区分是否被修改过），所以一般都是先记录下<code>0</code>的位置或者需要置零的行和列，然后在进行置零。</p><p>这题的时间复杂度基本都是<code>O(m*n)</code>,所以这里比较关注空间复杂度：</p><p>这里给出一个<code>O(m+n)</code>的解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setZeroes1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//O(m + n)</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">row</span><span class="params">(matrix.<span class="built_in">size</span>(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">col</span><span class="params">(matrix[<span class="number">0</span>].<span class="built_in">size</span>(), <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录哪几行和哪几列需要置零</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; matrix.<span class="built_in">size</span>();i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>(); j++)</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) row[i] = col[j] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行置0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; matrix.<span class="built_in">size</span>();i++)</span><br><span class="line">        <span class="keyword">if</span> (row[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>(); j++) matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>();i++)</span><br><span class="line">        <span class="keyword">if</span> (col[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; matrix.<span class="built_in">size</span>(); j++) matrix[j][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后因为一行中只要有一个为<code>0</code>就可以直接对整行置零（还是先把整行扫描完的，不然某列本应该置零的却没有记录下来），所以我们可以在扫描一行的时候用一个flag来记录是否要置零，一旦扫完此行就马上置零，这样空间复杂度就减少成<code>O(n)</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setZeroes2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//O(n)</span></span><br><span class="line">    <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">bool</span> setzero;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">col</span><span class="params">(matrix[<span class="number">0</span>].<span class="built_in">size</span>(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; matrix.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        setzero = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>();j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123; </span><br><span class="line">                setzero = <span class="literal">true</span>;</span><br><span class="line">                col[j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;setzero &amp;&amp; j &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>();j++) &#123;</span><br><span class="line">            matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (col[i] == <span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; matrix.<span class="built_in">size</span>(); j++)</span><br><span class="line">            matrix[j][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后题目上提到可以用<code>O(1)</code>的空间复杂度来实现，然后就是需要重用空间啦，这里重用第一行来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重用第一行来去掉额外的空间</span></span><br><span class="line">    <span class="keyword">bool</span> setzero = <span class="literal">false</span>, raw0 = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">        <span class="keyword">if</span> (matrix[<span class="number">0</span>][i] == <span class="number">0</span>) &#123; raw0 = <span class="literal">true</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; m;i++) &#123;</span><br><span class="line">        setzero = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                setzero = <span class="literal">true</span>;</span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;setzero &amp;&amp; j &lt; n;j++) matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][i] == <span class="number">0</span>) matrix[j][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (raw0) matrix[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Path-Sum-II</title>
      <link href="/2018/02/15/Path-Sum-II/"/>
      <url>/2018/02/15/Path-Sum-II/</url>
      
        <content type="html"><![CDATA[<p>第101天，新年快乐啊。</p><p>今天的题目是<a href="https://leetcode.com/problems/path-sum-ii/description/" target="_blank" rel="noopener">Path Sum-II</a>:</p><blockquote><p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p></blockquote><blockquote><p>For example:<br>Given the below binary tree and sum = 22,</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      <span class="number">5</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">4</span>   <span class="number">8</span></span><br><span class="line">   /   / \</span><br><span class="line">  <span class="number">11</span>  <span class="number">13</span>  <span class="number">4</span></span><br><span class="line"> /  \    / \</span><br><span class="line"><span class="number">7</span>    <span class="number">2</span>  <span class="number">5</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>return</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   [<span class="number">5</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">2</span>],</span><br><span class="line">   [<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>比较简单，只贴代码咯：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum1</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    pathSum(root, sum, temp);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pathSum</span><span class="params">(TreeNode *root, <span class="keyword">int</span> sum, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;temp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; root-&gt;val &lt;&lt; endl;</span></span><br><span class="line">    temp.push_back(root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; sum == root-&gt;val) &#123;</span><br><span class="line">        ret.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    pathSum(root-&gt;left, sum - root-&gt;val, temp);</span><br><span class="line">    pathSum(root-&gt;right, sum - root-&gt;val, temp);</span><br><span class="line">    temp.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flatten-Nested-List-Iterator</title>
      <link href="/2018/02/14/Flatten-Nested-List-Iterator/"/>
      <url>/2018/02/14/Flatten-Nested-List-Iterator/</url>
      
        <content type="html"><![CDATA[<p>第100天。</p><p>今天的题目是<a href="https://leetcode.com/problems/flatten-nested-list-iterator/description/" target="_blank" rel="noopener">flatten-Nested-List-Iterator</a>:</p><blockquote><p>Given a nested list of integers, implement an iterator to flatten it.</p><p>Each element is either an integer, or a list – whose elements may also be integers or other lists.</p><p>Example 1:<br>Given the list [[1,1],2,[1,1]],</p><p>By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].</p><p>Example 2:<br>Given the list [1,[4,[6]]],</p><p>By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].</p></blockquote><p>挺有趣的题目，主要是要实现一个嵌套列表的迭代器，大概是三个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NestedIterator(<span class="built_in">vector</span>&lt;NestedInteger&gt; &amp;nestedList) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后他也提供了<code>NestedInteger</code>的接口和一些说明，算是对题目的补充：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     // Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     bool isInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     int getInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     const vector&lt;NestedInteger&gt; &amp;getList() const;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NestedIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NestedIterator i(nestedList);</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) cout &lt;&lt; i.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>从补充中我们可以看到，在调用<code>next</code>前一定会先调用<code>hasNext</code>,有了这个前提我们写起来会方便一点。</p><p>我的解法是，<code>NestedIterator</code>只保存构造函数中传入的<code>nestedList</code>的两个迭代器，之所以是两个，是因为要保存<code>end</code>迭代器，然后要实现嵌套，我们还要一个<code>NestedIterator</code>的指针，利用这个指针来对下一级列表的元素进行迭代：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NestedIterator(<span class="built_in">vector</span>&lt;NestedInteger&gt; &amp;nestedList) &#123;</span><br><span class="line">        _it = nestedList.<span class="built_in">begin</span>(); _end_it = nestedList.<span class="built_in">end</span>();</span><br><span class="line">        _tmp_it = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_it-&gt;isInteger()) &#123; <span class="keyword">int</span> ret = _it-&gt;getInteger(); ++_it; <span class="keyword">return</span> ret; &#125;</span><br><span class="line">        <span class="keyword">return</span> _tmp_it-&gt;next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_it == _end_it) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (_it-&gt;isInteger()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (_tmp_it == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            _tmp_it = <span class="keyword">new</span> NestedIterator(_it-&gt;getList());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_tmp_it-&gt;hasNext()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">delete</span> _tmp_it; _tmp_it = <span class="literal">nullptr</span>; ++_it;</span><br><span class="line">        <span class="keyword">return</span> hasNext();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;NestedInteger&gt;::iterator _it, _end_it;</span><br><span class="line">    NestedIterator *_tmp_it;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后这里的实现虽然比较简单，简洁，但是在遇到一些特殊情况的时候会对性能造成极大的影响,比如说<code>[[[[[1,2,3]]]]]</code>,虽然只有三个元素，但是因为有5层的嵌套，我们要有5个迭代器，每次调用<code>next</code>和<code>hasNext</code>都需要递归调用5次才能返回，这样效率就有点低了.</p><p><code>dicuss</code>中的解法会比较好一点，类别<code>DFS</code>来做，先用<code>stack</code>保存所有的元素，在调用<code>hasNext</code>的时候，如果栈顶是列表就将其展开并压栈（倒序），然后在递归调用<code>hasNext</code>，直到栈顶为数字时,然后调用<code>next</code>就直接返回栈顶即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NestedIterator(<span class="built_in">vector</span>&lt;NestedInteger&gt; &amp;nestedList) &#123;</span><br><span class="line">        begins.push(nestedList.<span class="built_in">begin</span>());</span><br><span class="line">        ends.push(nestedList.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        hasNext();</span><br><span class="line">        <span class="keyword">return</span> (begins.top()++)-&gt;getInteger();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (begins.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (begins.top() == ends.top()) &#123;</span><br><span class="line">                begins.pop();</span><br><span class="line">                ends.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">auto</span> x = begins.top();</span><br><span class="line">                <span class="keyword">if</span> (x-&gt;isInteger())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                begins.top()++;</span><br><span class="line">                begins.push(x-&gt;getList().<span class="built_in">begin</span>());</span><br><span class="line">                ends.push(x-&gt;getList().<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="built_in">vector</span>&lt;NestedInteger&gt;::iterator&gt; begins, ends;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k近邻算法</title>
      <link href="/2018/02/13/k%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/"/>
      <url>/2018/02/13/k%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>刚看了有关<code>kNN</code>的东西，总结一下：</p><p>kNN算法（k-近邻算法）是一种可用于分类和回归的非参数统计方法。</p><ul><li>分类算法：最近的k个邻居进行投票得到类别</li><li>回归算法：最近的k个邻居的平均数</li></ul><p>这里只讨论分类算法。</p><p>先给个直观的理解，比如现在我们要判断一个人是男生还是女生，我们只考虑身高、体重这两个特征。显然如何两个人的身高体重越相近，那么他们的性别就越相近。kNN就是基于这个直观的想法来做的，如果我们要判断<code>x</code>是什么类别，我们就在<code>train data</code>中找出与<code>x</code>最相邻的<code>k</code>个数据，然后通过投票机制来觉得最后的分类。</p><p>这里我们就需要定义距离了：</p><p>简单的就用欧几里得距离（即<code>L2</code>距离）<br>$\sqrt((x_1 - y_1)^2 + … + (x_2 - y_2)^2)$</p><p>给出demo代码（参考机器学习实战）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classify0</span><span class="params">(inX, dataSet, labels, k)</span>:</span></span><br><span class="line">    dataSetSize = dataSet.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 欧式距离计算</span></span><br><span class="line">    diffMat = np.tile(inX, (dataSetSize,<span class="number">1</span>)) - dataSet</span><br><span class="line">    sqDiffMat = diffMat**<span class="number">2</span></span><br><span class="line">    sqDistance = sqDiffMat.sum(axis=<span class="number">1</span>)</span><br><span class="line">    distances = sqDistance**<span class="number">0.5</span></span><br><span class="line">    <span class="comment">#找出前k个距离最小的sample</span></span><br><span class="line">    sortedDistIndicies = distances.argsort() <span class="comment"># 这里返回的是indicies</span></span><br><span class="line">    classCount = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">        voteIlabel = labels[sortedDistIndicies[i]]</span><br><span class="line">        classCount[voteIlabel] = classCount.get(voteIlabel, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    sortedClassCount = sorted(classCount.items(), </span><br><span class="line">                              key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Decode-Ways</title>
      <link href="/2018/02/13/Decode-Ways/"/>
      <url>/2018/02/13/Decode-Ways/</url>
      
        <content type="html"><![CDATA[<p>第99天。</p><p>今天的题目是<a href="https://leetcode.com/problems/decode-ways/description/" target="_blank" rel="noopener">Decode Ways</a>:</p><blockquote><p>A message containing letters from A-Z is being encoded to numbers using the following mapping:</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">'A' -&gt; 1</span><br><span class="line">'B' -&gt; 2</span><br><span class="line">...</span><br><span class="line">'Z' -&gt; 26</span><br></pre></td></tr></table></figure><blockquote><p>Given an encoded message containing digits, determine the total number of ways to decode it.</p><p>For example,<br>Given encoded message “12”, it could be decoded as “AB” (1 2) or “L” (12).</p><p>The number of ways decoding “12” is 2.</p></blockquote><p>在店里面发呆的时候突然想到的解法，虽然当然当时没有想出完整解法，但是找到了思路（动态规划的题目就是这样，一旦意识到是动态规划后就简单多了）,这道题主要难在要意识到是动态规划比较难，毕竟是要倒着做动态规划的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    s.push_back(<span class="string">'\0'</span>);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[i+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(s[i]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'0'</span>: dp[i] = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'1'</span>: dp[i] = dp[i+<span class="number">1</span>] + dp[i+<span class="number">2</span>]; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'2'</span>:</span><br><span class="line">                <span class="keyword">if</span> (s[i+<span class="number">1</span>] &gt;= <span class="string">'0'</span> &amp;&amp; s[i+<span class="number">1</span>] &lt;= <span class="string">'6'</span>) &#123;</span><br><span class="line">                    dp[i] = dp[i+<span class="number">1</span>] + dp[i+<span class="number">2</span>]; <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                dp[i] = dp[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reverse-Linked-List-II</title>
      <link href="/2018/02/12/Reverse-Linked-List-II/"/>
      <url>/2018/02/12/Reverse-Linked-List-II/</url>
      
        <content type="html"><![CDATA[<p>第98天。</p><p>今天的题目是<a href="https://leetcode.com/problems/reverse-linked-list-ii/description/" target="_blank" rel="noopener">Reverse Linked List II</a>:</p><blockquote><p>Reverse a linked list from position m to n. Do it in-place and in one-pass.</p><p>For example:<br>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4,</p><p>return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL.</p><p>Note:<br>Given m, n satisfy the following condition:<br>1 ≤ m ≤ n ≤ length of list.</p></blockquote><p>之前做个一道翻转的题目了，所以这道题就比较简单了,想法和之前的一样，先从翻转整个链表开始考虑（也就是之前那道题目）</p><p>我们只需要把相邻节点间的箭头换个方向，比如说：</p><p><code>1-&gt;2</code>就调整为<code>1&lt;-2</code>,有了这个想法后就简单多了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">reverse</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ListNode *t = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个也是同理，只不过有些细节不一样罢了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">if</span> (m == n) <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode <span class="title">ret</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    ret.next = head;</span><br><span class="line">    </span><br><span class="line">    ListNode *pre = &amp;ret;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(;i &lt; m;i++) pre = pre-&gt;next;</span><br><span class="line">    </span><br><span class="line">    ListNode *cur = pre-&gt;next;</span><br><span class="line">    ListNode *next = cur-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(;i &lt; n;i++) &#123;</span><br><span class="line">        ListNode *t = next-&gt;next;</span><br><span class="line">        next-&gt;next = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">        next = t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pre-&gt;next-&gt;next = next;</span><br><span class="line">    pre-&gt;next = cur;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Binary-Tree-Zigzag-Level-Order-Traversal</title>
      <link href="/2018/02/11/Binary-Tree-Zigzag-Level-Order-Traversal/"/>
      <url>/2018/02/11/Binary-Tree-Zigzag-Level-Order-Traversal/</url>
      
        <content type="html"><![CDATA[<p>第97天。</p><p>今天的题目是<a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/" target="_blank" rel="noopener">Binary Tree Zigzag Level Order Traversal</a>:</p><blockquote><p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p><p>For example:<br>Given binary tree [3,9,20,null,null,15,7],</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><blockquote><p>return its zigzag level order traversal as:</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">20</span>,<span class="number">9</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>首先想到的是用层次遍历的方式来实现。</p><p>简单的层次遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelTra</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        root = q.front(); q.pop();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) q.push(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) q.push(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上面的方法是没法区分层数的，我们通过<code>nullptr</code>来表示换行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelTra</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    q.push(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        root = q.top(); q.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"new level"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span> (q.empty()) <span class="keyword">break</span>;</span><br><span class="line">            q.push(<span class="literal">nullptr</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) q.push(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) q.push(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">zigzagLevelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ret;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="comment">//level tra</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>; <span class="comment">//判断遍历方向</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    q.push(<span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        root = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)  &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (flag) ret.push_back(tmp);</span><br><span class="line">            <span class="keyword">else</span> ret.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(tmp.rbegin(), tmp.rend()));</span><br><span class="line">            </span><br><span class="line">            tmp.<span class="built_in">clear</span>();</span><br><span class="line">            flag = !flag;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (q.empty()) <span class="keyword">break</span>;</span><br><span class="line">            q.push(<span class="literal">nullptr</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        tmp.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) q.push(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) q.push(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是<code>dicuss</code>中的方法，简单的来说就是通过深度优先遍历来生成获取层次遍历的每层的数组（好像之前写过？），然后就会比前面用<code>queue</code>的方法快。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travel</span><span class="params">(TreeNode *root, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;ret, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (level &gt;= ret.<span class="built_in">size</span>()) ret.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    </span><br><span class="line">    ret[level].push_back(root-&gt;val);</span><br><span class="line">    </span><br><span class="line">    travel(root-&gt;left, ret, level + <span class="number">1</span>);</span><br><span class="line">    travel(root-&gt;right, ret, level + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">zigzagLevelOrder</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">    travel(root, ret, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ret.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span>) reverse(ret[i].<span class="built_in">begin</span>(), ret[i].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>Update as 2020-03-28</p></blockquote><p>最近在总结 Stack Tag 的算法，然后发现这道题可以用双栈来解，和前面队列的做法有点类似，某种意义上也是在模拟层次遍历，但是因为栈后进先出的特性，所以很直接的实现了逆序的操作，不需要额外做<code>reverse</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">zigzagLevelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; st_even, st_odd;</span><br><span class="line">    <span class="keyword">if</span> (root) st_even.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!st_even.empty() || !st_odd.empty()) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; &amp;st1 = level % <span class="number">2</span> == <span class="number">0</span> ? st_even : st_odd;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; &amp;st2 = level % <span class="number">2</span> == <span class="number">0</span> ? st_odd : st_even;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, <span class="built_in">size</span> = st1.<span class="built_in">size</span>(); i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">            root = st1.top(); st1.pop();</span><br><span class="line">            temp.push_back(root-&gt;val);</span><br><span class="line"></span><br><span class="line">            TreeNode *left = root-&gt;left, *right = root-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (level % <span class="number">2</span>) swap(left, right);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (left) st2.push(left);</span><br><span class="line">            <span class="keyword">if</span> (right) st2.push(right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; st1.size() &lt;&lt; " " &lt;&lt; st2.size() &lt;&lt; endl;</span></span><br><span class="line">        res.push_back(temp);</span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Tree </tag>
            
            <tag> Stack </tag>
            
            <tag> Queues </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>blog迁移</title>
      <link href="/2018/02/10/blog%E8%BF%81%E7%A7%BB/"/>
      <url>/2018/02/10/blog%E8%BF%81%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<p>今天把hexo从win搬到了Deepin下，准备长期驻扎Deepin了。然后有几篇文章的时间有点不对了。。whatever，不管了。</p><p>这篇blog只是一个测试：</p><p>$$ \sum_{i=1}^n a_i = 0 $$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂事一堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Search-a-2D-Matrix-II</title>
      <link href="/2018/01/27/Search-a-2D-Matrix-II/"/>
      <url>/2018/01/27/Search-a-2D-Matrix-II/</url>
      
        <content type="html"><![CDATA[<p>第96天。</p><p>今天的题目是<a href="https://leetcode.com/problems/search-a-2d-matrix-ii/description/" target="_blank" rel="noopener">Search a 2D Matrix II</a>:</p><blockquote><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p><p>Integers in each row are sorted in ascending from left to right.<br>Integers in each column are sorted in ascending from top to bottom.<br>For example,</p><p>Consider the following matrix:</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,   <span class="number">4</span>,  <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>],</span><br><span class="line">  [<span class="number">2</span>,   <span class="number">5</span>,  <span class="number">8</span>, <span class="number">12</span>, <span class="number">19</span>],</span><br><span class="line">  [<span class="number">3</span>,   <span class="number">6</span>,  <span class="number">9</span>, <span class="number">16</span>, <span class="number">22</span>],</span><br><span class="line">  [<span class="number">10</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">17</span>, <span class="number">24</span>],</span><br><span class="line">  [<span class="number">18</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">26</span>, <span class="number">30</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>Given target = 5, return true.</p><p>Given target = 20, return false.</p></blockquote><p>以前好像看过这道题，但是应该嫌麻烦没做，今天做了一下，感觉好像也不是很难的样子，二分查找的升级版（在2维情况下）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> searchMatrix(matrix,<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,m<span class="number">-1</span>,target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;matrix, <span class="keyword">int</span> xlow, <span class="keyword">int</span> xhigh, <span class="keyword">int</span> ylow, <span class="keyword">int</span> yhigh, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; xlow &lt;&lt; " " &lt;&lt; xhigh &lt;&lt; endl</span></span><br><span class="line">    <span class="comment">//   &lt;&lt; ylow &lt;&lt; " " &lt;&lt; yhigh &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xlow &gt; xhigh || ylow &gt; yhigh) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> xmid = (xlow + xhigh)/<span class="number">2</span>, ymid = (ylow + yhigh)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (matrix[xmid][ymid] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (matrix[xmid][ymid] &lt; target) </span><br><span class="line">        <span class="keyword">return</span> searchMatrix(matrix,xmid + <span class="number">1</span>, xhigh, ylow, yhigh,target) ||</span><br><span class="line">                searchMatrix(matrix,xlow, xhigh, ymid + <span class="number">1</span>, yhigh, target);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> searchMatrix(matrix, xlow, xmid<span class="number">-1</span>, ylow, yhigh,target) ||</span><br><span class="line">                searchMatrix(matrix,xlow, xhigh, ylow, ymid<span class="number">-1</span>, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么<code>dicuss</code>的解法大多都是:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &lt; matrix.<span class="built_in">size</span>() &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[i][j] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(matrix[i][j] &lt; target)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Same-Tree</title>
      <link href="/2018/01/26/Same-Tree/"/>
      <url>/2018/01/26/Same-Tree/</url>
      
        <content type="html"><![CDATA[<p>第95天。</p><p>今天的题目比较水。</p><p>今天的题目是<a href="https://leetcode.com/problems/same-tree/description/" target="_blank" rel="noopener">Same Tree</a>:</p><blockquote><p>Given two binary trees, write a function to check if they are the same or not.</p></blockquote><blockquote><p>Two binary trees are considered the same if they are structurally identical and the nodes have the same value.</p></blockquote><p>太简单了，不做太多解释了:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p &amp;&amp; q) &#123;</span><br><span class="line">        <span class="keyword">return</span> q-&gt;val == p-&gt;val &amp;&amp; isSameTree(p-&gt;left,q-&gt;left) &amp;&amp; isSameTree(p-&gt;right,q-&gt;right);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nim-Game</title>
      <link href="/2018/01/25/Nim-Game/"/>
      <url>/2018/01/25/Nim-Game/</url>
      
        <content type="html"><![CDATA[<p>第94天。</p><p>今天的题目有点智障。。。</p><p>今天的题目是<a href="https://leetcode.com/problems/nim-game/description/" target="_blank" rel="noopener">Nim Game</a>:</p><blockquote><p>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.</p><p>Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.</p><p>For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.</p></blockquote><p>很自然的想到用<code>dp</code>去做，然而时间超限了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canWinNim1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">1</span>] = dp[<span class="number">2</span>] = dp[<span class="number">3</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        dp[i] = !(dp[i<span class="number">-1</span>] &amp;&amp; dp[i<span class="number">-2</span>] &amp;&amp; dp[i<span class="number">-3</span>]);</span><br><span class="line">   <span class="comment">//     if (dp[i] == false) cout &lt;&lt; i &lt;&lt; " ";</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把<code>false</code>的值输出来之后，发现，只要不是4的倍数就会赢。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Construct-the-Rectangle</title>
      <link href="/2018/01/24/Construct-the-Rectangle/"/>
      <url>/2018/01/24/Construct-the-Rectangle/</url>
      
        <content type="html"><![CDATA[<p>第93天。</p><p>今天的题目是<a href="https://leetcode.com/problems/construct-the-rectangle/discuss/" target="_blank" rel="noopener">Construct the Rectangle</a>:</p><blockquote><p>For a web developer, it is very important to know how to design a web page’s size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:</p></blockquote><blockquote><ol><li><p>The area of the rectangular web page you designed must equal to the given target area.</p></li><li><p>The width W should not be larger than the length L, which means L &gt;= W.</p></li><li><p>The difference between length L and width W should be as small as possible.<br>You need to output the length L and the width W of the web page you designed in sequence.<br>Example:<br>Input: 4<br>Output: [2, 2]<br>Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1].<br>But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.<br>Note:<br>The given area won’t exceed 10,000,000 and is a positive integer<br>The web page’s width and length you designed must be positive integers.</p></li></ol></blockquote><p>比较简单的题目，但是题目有点长，总结一下就是，你要求出<code>L</code>,<code>W</code>满足一下条件：</p><ol><li>L, W is int</li><li>L*W=Area</li><li>L &gt;= W &gt; 0</li><li>min |L-W|</li></ol><p>既然要使得<code>|L-W|</code>最小，那么显然，<code>L=W=sqrt(Area)</code>时，<code>L-W</code>是最小的，但是因为<code>L</code>和<code>W</code>限制成整数了,且<code>sqrt(Area)</code>不一定是整数，如果把它转换成<code>int</code>的话，<code>L*W</code>不一定等于<code>Area</code>了。所以我们必须调整<code>L</code>和<code>W</code>的值，简单的调整方法就是，如果<code>L*W &lt; Area</code>,我们就加大<code>L</code>之所以是加大<code>L</code>而不是加大<code>W</code>的原因是需要满足<code>L &gt;= W</code>，同理<code>L*W &gt; Area</code>时，我们就减小<code>W</code>。这样子我们始终会找到一个<code>L,W</code>满足上面的条件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">constructRectangle</span><span class="params">(<span class="keyword">int</span> area)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L, W;</span><br><span class="line">    <span class="keyword">int</span> sqrt_a = <span class="built_in">sqrt</span>(area);</span><br><span class="line">    W = L = sqrt_a;</span><br><span class="line">    <span class="keyword">int</span> a = W*L;</span><br><span class="line">    <span class="keyword">while</span>(a != area) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; area) L++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; area) W--;</span><br><span class="line">        a = W*L;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;L, W&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后<code>dicuss</code>中的解法更巧妙一点，我们只求<code>W</code>，然后<code>L = Area/W</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] constructRectangle(<span class="keyword">int</span> area) &#123;</span><br><span class="line">    <span class="keyword">int</span> w = (<span class="keyword">int</span>)Math.sqrt(area);</span><br><span class="line">    <span class="keyword">while</span> (area%w!=<span class="number">0</span>) w--;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;area/w, w&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rotate-Image</title>
      <link href="/2018/01/23/Rotate-Image/"/>
      <url>/2018/01/23/Rotate-Image/</url>
      
        <content type="html"><![CDATA[<p>第92天。</p><p>今天的题目是<a href="https://leetcode.com/problems/rotate-image/description/" target="_blank" rel="noopener">Rotate Image</a>:</p><blockquote><p>You are given an n x n 2D matrix representing an image.</p><p>Rotate the image by 90 degrees (clockwise).</p><p>Note:<br>You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.</p><p>Example 1:</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Given input matrix = </span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">  [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">rotate the input matrix <span class="keyword">in</span>-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>Example 2:</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Given input matrix =</span><br><span class="line">[</span><br><span class="line">  [ <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>,<span class="number">11</span>],</span><br><span class="line">  [ <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>,<span class="number">10</span>],</span><br><span class="line">  [<span class="number">13</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">16</span>]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">rotate the input matrix <span class="keyword">in</span>-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">15</span>,<span class="number">13</span>, <span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">14</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">12</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">  [<span class="number">16</span>, <span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>虽然是一道<code>Medium</code>的题目，但是还是比较简单的。</p><p>主要的思路是一圈一圈的进行旋转，不断缩减，直到不需要旋转的时候：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> beg = <span class="number">0</span>, <span class="built_in">end</span> = matrix.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span>(beg &lt; <span class="built_in">end</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = <span class="built_in">end</span> - beg;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="built_in">size</span>;i++) &#123;</span><br><span class="line">            temp = matrix[beg+i][beg];</span><br><span class="line">            matrix[beg+i][beg] = matrix[<span class="built_in">end</span>][beg+i];</span><br><span class="line">            matrix[<span class="built_in">end</span>][beg+i] = matrix[<span class="built_in">end</span>-i][<span class="built_in">end</span>];</span><br><span class="line">            matrix[<span class="built_in">end</span>-i][<span class="built_in">end</span>] = matrix[beg][<span class="built_in">end</span>-i];</span><br><span class="line">            matrix[beg][<span class="built_in">end</span>-i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        beg++; <span class="built_in">end</span>--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Repeated-Substring-Pattern</title>
      <link href="/2018/01/22/Repeated-Substring-Pattern/"/>
      <url>/2018/01/22/Repeated-Substring-Pattern/</url>
      
        <content type="html"><![CDATA[<p>第91天。</p><p>今天的题目是<a href="https://leetcode.com/problems/repeated-substring-pattern/description/" target="_blank" rel="noopener">Repeated Substring Pattern</a>:</p><blockquote><p>Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.<br>Example 1:<br>Input: “abab”</p><p>Output: True</p><p>Explanation: It’s the substring “ab” twice.<br>Example 2:<br>Input: “aba”</p><p>Output: False<br>Example 3:<br>Input: “abcabcabcabc”</p><p>Output: True</p><p>Explanation: It’s the substring “abc” four times. (And the substring “abcabc” twice.)</p></blockquote><p>一开始没看清，以为只有重复一次的情况，后来发现还可以重复多次，这样的话就不得不多扫描几遍了,有点希尔排序的解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern1</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; s.<span class="built_in">size</span>();i++)</span><br><span class="line">        <span class="keyword">if</span> (repeatedSubstringPattern(s,i)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="built_in">string</span> &amp;s,<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; p &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> % p) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; p;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+p;j &lt; <span class="built_in">size</span>;j += p) &#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; s[i] &lt;&lt; " " &lt;&lt; s[j] &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] != s[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是在<code>dicuss</code>中的利用<code>kmp</code>的解法，但我还是没看懂为什么可以这样做。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>, n = str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>( i &lt; str.<span class="built_in">size</span>() )&#123;</span><br><span class="line">        <span class="keyword">if</span>( str[i] == str[j] ) dp[++i]=++j;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( j == <span class="number">0</span> ) i++;</span><br><span class="line">        <span class="keyword">else</span> j = dp[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]&amp;&amp;dp[n]%(n-dp[n])==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linked-List-Random-Node</title>
      <link href="/2018/01/21/Linked-List-Random-Node/"/>
      <url>/2018/01/21/Linked-List-Random-Node/</url>
      
        <content type="html"><![CDATA[<p>第90天。</p><p>今天的题目是<a href="https://leetcode.com/problems/linked-list-random-node/description/" target="_blank" rel="noopener">Linked List Random Node</a>:</p><blockquote><p>Given a singly linked list, return a random node’s value from the linked list. Each node must have the same probability of being chosen.</p><p>Follow up:<br>What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space?</p><p>Example:</p><p>// Init a singly linked list [1,2,3].<br>ListNode head = new ListNode(1);<br>head.next = new ListNode(2);<br>head.next.next = new ListNode(3);<br>Solution solution = new Solution(head);</p><p>// getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.<br>solution.getRandom();</p></blockquote><p>写出了一个朴素的解法，两次扫描：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Solution(ListNode* p) &#123;</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    head = p;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        len++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; len &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns a random node's value. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = rand() % len;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ListNode *p = head;</span><br><span class="line">    <span class="keyword">while</span>(r-- &amp;&amp; p) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line">ListNode *head;</span><br></pre></td></tr></table></figure><p>然后是利用栈来做的一个解法，即一直递归调用直到链表结尾，这时我们已经遍历了一遍链表就可以知道其长度了，在这时生成随机数，然后在递归调用返回的时候通过这个随机数来选取节点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    temp_len = <span class="number">0</span>;</span><br><span class="line">    getRandom(head);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">getRandom</span><span class="params">(ListNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        rand_n = rand() % temp_len;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    temp_len++;</span><br><span class="line">    <span class="keyword">if</span>(getRandom(p-&gt;next)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (rand_n == <span class="number">0</span>) &#123;</span><br><span class="line">        res = p-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rand_n--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> temp_len;</span><br><span class="line"><span class="keyword">int</span> rand_n;</span><br><span class="line">ListNode *head;</span><br><span class="line"><span class="keyword">int</span> res;</span><br></pre></td></tr></table></figure><p>最后是<code>dicuss</code>中的水库抽样法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = head-&gt;val;</span><br><span class="line">    ListNode* node = head-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(node)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = rand()%i;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>)</span><br><span class="line">            res = node-&gt;val;</span><br><span class="line">        i++;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>证明可参考：<a href="http://blog.csdn.net/so_geili/article/details/52937212" target="_blank" rel="noopener">http://blog.csdn.net/so_geili/article/details/52937212</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Binary-Tree-Paths</title>
      <link href="/2018/01/20/Binary-Tree-Paths/"/>
      <url>/2018/01/20/Binary-Tree-Paths/</url>
      
        <content type="html"><![CDATA[<p>第89天。</p><p>今天的题目是<a href="https://leetcode.com/problems/binary-tree-paths/description/" target="_blank" rel="noopener">Binary-Tree-Paths</a>:</p><blockquote><p>Given a binary tree, return all root-to-leaf paths.</p><p>For example, given the following binary tree:</p></blockquote><p>   1<br> /   <br>2     3<br> <br>  5</p><blockquote><p>All root-to-leaf paths are:</p><p>[“1-&gt;2-&gt;5”, “1-&gt;3”]</p></blockquote><p>比较的简单的题目，直接用递归做就好了，因为<code>python</code>写起来比较简单，所以这里用<code>python</code>实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span><span class="params">(self, root)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type root: TreeNode</span></span><br><span class="line"><span class="string">    :rtype: List[str]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    self.ret = []</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> self.ret</span><br><span class="line">    s = []</span><br><span class="line">    self.binaryTreePathsRec(root,s)</span><br><span class="line">    <span class="keyword">return</span> self.ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binaryTreePathsRec</span><span class="params">(self,root,s)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    s.append(str(root.val))</span><br><span class="line">    <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self.ret.append(<span class="string">'-&gt;'</span>.join(s))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.binaryTreePathsRec(root.left,s)</span><br><span class="line">        self.binaryTreePathsRec(root.right,s)</span><br><span class="line">    s.pop()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Split-Linked-List-in-Parts</title>
      <link href="/2018/01/19/Split-Linked-List-in-Parts/"/>
      <url>/2018/01/19/Split-Linked-List-in-Parts/</url>
      
        <content type="html"><![CDATA[<p>第88天。</p><p>今天的题目是<a href="https://leetcode.com/problems/split-linked-list-in-parts/description/" target="_blank" rel="noopener">Split Linked List in Parts</a>:</p><blockquote><p>Given a (singly) linked list with head node root, write a function to split the linked list into k consecutive linked list “parts”.</p><p>The length of each part should be as equal as possible: no two parts should have a size differing by more than 1. This may lead to some parts being null.</p><p>The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.</p><p>Return a List of ListNode’s representing the linked list parts that are formed.</p><p>Examples 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 equal parts [ [1], [2], [3], [4], null ]<br>Example 1:<br>Input:<br>root = [1, 2, 3], k = 5<br>Output: [[1],[2],[3],[],[]]<br>Explanation:<br>The input and each element of the output are ListNodes, not arrays.<br>For example, the input root has root.val = 1, root.next.val = 2, \root.next.next.val = 3, and root.next.next.next = null.<br>The first element output[0] has output[0].val = 1, output[0].next = null.<br>The last element output[4] is null, but it’s string representation as a ListNode is [].<br>Example 2:<br>Input:<br>root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3<br>Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]<br>Explanation:<br>The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.<br>Note:</p><p>The length of root will be in the range [0, 1000].<br>Each value of a node in the input will be an integer in the range [0, 999].<br>k will be an integer in the range [1, 50].</p></blockquote><p>虽然不难，但是自己还是做了一个早上，现在的效率真的是低的可以。</p><p>首先要知道每个块要有多少个节点就必须先知道总共有多少个节点，所以第一遍扫描算节点数肯定是少不了的，然后就可以开始算每个块的个数了。</p><ul><li><code>k&gt;=n</code>时，显然前n块只需要放一个就好了，后面的不用管。</li><li><code>k&lt;n</code>时，可以分成两部分，前面的一部分比后面的一部分多放一个块，穷举几次可以知道，后面的部分每个快放<code>n/k</code>个节点，前面的部分有<code>n%k</code>个块。</li></ul><p>其实到这里就可以发现其实并不需要分情况,第二种已经包括了第一种了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;ListNode*&gt; <span class="title">splitListToParts</span><span class="params">(ListNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ListNode *p = root;p != <span class="literal">nullptr</span>;p=p-&gt;next) <span class="built_in">size</span>++;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;ListNode *&gt; <span class="title">ret</span><span class="params">(k,<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="built_in">size</span>/k;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="built_in">size</span>%k;</span><br><span class="line"></span><br><span class="line">    ListNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *p = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k &amp;&amp; p;i++) &#123;</span><br><span class="line">        ret[i] = p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; a + (b&gt;<span class="number">0</span>);j++) &#123;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        b--;</span><br><span class="line">        pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Min-Cost-Climbing-Stairs</title>
      <link href="/2018/01/18/Min-Cost-Climbing-Stairs/"/>
      <url>/2018/01/18/Min-Cost-Climbing-Stairs/</url>
      
        <content type="html"><![CDATA[<p>第87天。</p><p>今天的题目是<a href="https://leetcode.com/problems/min-cost-climbing-stairs/description/" target="_blank" rel="noopener">Min Cost Climbing Stairs</a>：</p><blockquote><p>On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).</p><p>Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.</p><p>Example 1:<br>Input: cost = [10, 15, 20]<br>Output: 15<br>Explanation: Cheapest is start on cost[1], pay that cost and go to the top.<br>Example 2:<br>Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]<br>Output: 6<br>Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].<br>Note:<br>cost will have a length in the range [2, 1000].<br>Every cost[i] will be an integer in the range [0, 999].</p></blockquote><p>比较简单的动态规划题，emmm，爬楼梯的升级：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">    cost.push_back(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n = cost.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n+<span class="number">2</span>;i++) &#123;</span><br><span class="line">        dp[i] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]) + cost[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以做一些简化:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cost.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        dp[i] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]) + cost[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(dp[n<span class="number">-1</span>],dp[n<span class="number">-2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>甚至，如果cost可以修改的话，我们还可以把<code>dp</code>也省下来:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cost.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;dp = cost;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        dp[i] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]) + cost[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(dp[n<span class="number">-1</span>],dp[n<span class="number">-2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rectangle-Area</title>
      <link href="/2018/01/17/Rectangle-Area/"/>
      <url>/2018/01/17/Rectangle-Area/</url>
      
        <content type="html"><![CDATA[<p>第86天。</p><p>今天的题目是<a href="https://leetcode.com/problems/rectangle-area/description/" target="_blank" rel="noopener">Rectangle Area</a>:</p><blockquote><p>Find the total area covered by two rectilinear rectangles in a 2D plane.</p><p>Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.<br><img src="https://leetcode.com/static/images/problemset/rectangle_area.png" alt=""><br>Assume that the total area is never beyond the maximum possible value of int.</p></blockquote><p>一开始以为是求两个矩形重合部分的面积，后来仔细看了一下才发现是求它们的覆盖面积，好在把重合部分面积求出来后，求他们覆盖面积也比较简单，只需要先求出两个矩形的面积和之后再减去重合部分的面积就可以得到覆盖面积了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">(<span class="keyword">int</span> A,<span class="keyword">int</span> B,<span class="keyword">int</span> C,<span class="keyword">int</span> D)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (C-A)*(D-B);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">intersect</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> C, <span class="keyword">int</span> D, <span class="keyword">int</span> E, <span class="keyword">int</span> F, <span class="keyword">int</span> G, <span class="keyword">int</span> H)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//求重合部分的面积</span></span><br><span class="line">    <span class="keyword">if</span> (!check(A, B, C, D, E, F, G, H)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">min</span>(C-E,G-A),<span class="built_in">min</span>(G-E,C-A)) * <span class="built_in">min</span>(<span class="built_in">min</span>(D-F,H-B),<span class="built_in">min</span>(D-B,H-F));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">computeArea</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> C, <span class="keyword">int</span> D, <span class="keyword">int</span> E, <span class="keyword">int</span> F, <span class="keyword">int</span> G, <span class="keyword">int</span> H)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a1 = area(A, B, C, D);</span><br><span class="line">    <span class="keyword">int</span> a2 = area(E, F, G, H);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; a1 &lt;&lt; " " &lt;&lt; a2 &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> a1- intersect(A, B, C, D, E, F, G, H) + a2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> C, <span class="keyword">int</span> D, <span class="keyword">int</span> E, <span class="keyword">int</span> F, <span class="keyword">int</span> G, <span class="keyword">int</span> H)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否重合</span></span><br><span class="line">    <span class="keyword">return</span> ( <span class="built_in">abs</span>(A+C-E-G) &lt;= (<span class="built_in">abs</span>(A-C) + <span class="built_in">abs</span>(G-E)) )&amp;&amp; (<span class="built_in">abs</span>(B+D-F-H) &lt;= (<span class="built_in">abs</span>(D-B) + <span class="built_in">abs</span>(H-F))); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是<code>dicuss</code>中比较简洁的解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">computeArea</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> C, <span class="keyword">int</span> D, <span class="keyword">int</span> E, <span class="keyword">int</span> F, <span class="keyword">int</span> G, <span class="keyword">int</span> H)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="built_in">max</span>(A,E), right = <span class="built_in">max</span>(<span class="built_in">min</span>(C,G), left);</span><br><span class="line">    <span class="keyword">int</span> bottom = <span class="built_in">max</span>(B,F), top = <span class="built_in">max</span>(<span class="built_in">min</span>(D,H), bottom);</span><br><span class="line">    <span class="keyword">return</span> (C-A)*(D-B) - (right-left)*(top-bottom) + (G-E)*(H-F);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Longest-Palindrome</title>
      <link href="/2018/01/16/Longest-Palindrome/"/>
      <url>/2018/01/16/Longest-Palindrome/</url>
      
        <content type="html"><![CDATA[<p>第85天。</p><p>今天的题目是<a href="https://leetcode.com/problems/longest-palindrome/description/" target="_blank" rel="noopener">Longest Palindrome</a>:</p><blockquote><p>Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.</p><p>This is case sensitive, for example “Aa” is not considered a palindrome here.</p><p>Note:<br>Assume the length of given string will not exceed 1,010.</p><p>Example:</p><p>Input:<br>“abccccdd”</p><p>Output:<br>7</p><p>Explanation:<br>One longest palindrome that can be built is “dccaccd”, whose length is 7.</p></blockquote><p>这里有一点比较好玩的就是，他问的是能用这里字母组成的最长回文，所以他给的字符串顺序是不重要的，我们可以先用<code>unordered_map</code>先统计各个字母的个数，然后利用这些个数来计算即可。</p><p>先考虑回文长度是偶数的情况，一个字母要出现在回文中，就必须保证偶数个字母一起出现，这样的话我们就可以这样来计算了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;p:wcount) ret += (p.second / <span class="number">2</span>);</span><br><span class="line">    ret *= <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>然后考虑奇数的情况，从它给的示例中我们很容易的发现，奇数的情况就是偶数的情况加一，当然也可能不加一，因为可以字母不够用。所以我们可以写出以下解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; wcount;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:s) wcount[c]++;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;p:wcount) ret += (p.second / <span class="number">2</span>);</span><br><span class="line">    ret *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (ret &lt; s.<span class="built_in">size</span>())?ret+<span class="number">1</span>:ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以更快一点，把除法和乘法去掉：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; wcount;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:s) wcount[c]++;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;p:wcount) ret += ((p.second % <span class="number">2</span>)?p.second<span class="number">-1</span>:p.second);</span><br><span class="line">    <span class="keyword">return</span> (ret &lt; s.<span class="built_in">size</span>())?ret+<span class="number">1</span>:ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dicuss</code>有一个解法比较有趣，他是通过数出现奇数次的字母来实现的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> odds = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c=<span class="string">'A'</span>; c&lt;=<span class="string">'z'</span>; c++)</span><br><span class="line">        odds += count(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), c) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">size</span>() - odds + (odds &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Remove-Duplicates-from-Sorted-Array</title>
      <link href="/2018/01/15/Remove-Duplicates-from-Sorted-Array/"/>
      <url>/2018/01/15/Remove-Duplicates-from-Sorted-Array/</url>
      
        <content type="html"><![CDATA[<p>第84天。</p><p>All right,最终还是在期末考的时候断了。</p><p>今天的题目是<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/" target="_blank" rel="noopener">Remove Duplicates from Sorted Array</a>:</p><blockquote><p>Given a sorted array, remove the duplicates in-place such that each element appear only once and return the new length.</p><p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p><p>Example:</p><p>Given nums = [1,1,2],</p><p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length.</p></blockquote><p>明明是道水题，但是还是做了挺久的，而且效率也不高：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="built_in">size</span> - <span class="number">1</span>;i &gt;= <span class="number">1</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            swap(nums[i],nums[--<span class="built_in">size</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">begin</span>() + <span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说他效率不高的原因就在于最后要做一次排序。</p><p>然后是<code>dicuss</code>中给出的<code>O(n)</code>的解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != nums[i<span class="number">-1</span>]) nums[<span class="built_in">end</span>++] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">end</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Judge-Route-Cicle</title>
      <link href="/2017/12/19/Judge-Route-Cicle/"/>
      <url>/2017/12/19/Judge-Route-Cicle/</url>
      
        <content type="html"><![CDATA[<p>第83天。</p><p>今天的题目是:<a href="https://leetcode.com/problems/judge-route-circle/description/" target="_blank" rel="noopener">Judge Route Circle</a>:</p><blockquote><p>Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place.</p><p>The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). The output should be true or false representing whether the robot makes a circle.</p><p>Example 1:<br>Input: “UD”<br>Output: true<br>Example 2:<br>Input: “LL”<br>Output: false</p></blockquote><p>比较无聊的一道题目,我们只需要维护一组下标来记录所在的位置即可，然后判断移动完后是否回到了最开始的位置即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judgeCircle</span><span class="params">(<span class="built_in">string</span> moves)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:moves) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'U'</span>: y++; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'D'</span>: y--; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'L'</span>: x--; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'R'</span>: x++; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Intersection-of-Two-Arrays</title>
      <link href="/2017/12/18/Intersection-of-Two-Arrays/"/>
      <url>/2017/12/18/Intersection-of-Two-Arrays/</url>
      
        <content type="html"><![CDATA[<p>第82天。</p><p>今天的题目是<a href="https://leetcode.com/problems/intersection-of-two-arrays/description/" target="_blank" rel="noopener">Intersection of Two Arrays</a>:</p><blockquote><p>Given two arrays, write a function to compute their intersection.</p><p>Example:<br>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].</p><p>Note:<br>Each element in the result must be unique.<br>The result can be in any order.</p></blockquote><p>可以用排序做，也可以用<code>hash</code>做：</p><p>排序的做法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    sort(nums1.<span class="built_in">begin</span>(),nums1.<span class="built_in">end</span>());</span><br><span class="line">    sort(nums2.<span class="built_in">begin</span>(),nums2.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">auto</span> beg1 = nums1.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">auto</span> beg2 = nums2.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    <span class="keyword">while</span>(beg1 &lt; nums1.<span class="built_in">end</span>() &amp;&amp; beg2 &lt; nums2.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*beg1 == *beg2) &#123;</span><br><span class="line">            <span class="keyword">int</span> t  = *beg1;</span><br><span class="line">            ret.push_back(t);</span><br><span class="line">            <span class="keyword">while</span>(beg1 &lt; nums1.<span class="built_in">end</span>() &amp;&amp; *beg1 == t) beg1++;</span><br><span class="line">            <span class="keyword">while</span>(beg2 &lt; nums2.<span class="built_in">end</span>() &amp;&amp; *beg2 == t) beg2++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*beg1 &lt; *beg2) beg1++;</span><br><span class="line">        <span class="keyword">else</span> beg2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hash</code>的做法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersection1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:nums1) m[i]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:nums2) </span><br><span class="line">        <span class="keyword">if</span> (m.<span class="built_in">find</span>(i) != m.<span class="built_in">end</span>() &amp;&amp; m[i]) &#123;</span><br><span class="line">            m[i] = <span class="number">0</span>;</span><br><span class="line">            ret.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dicuss</code>还有用<code>set</code>做的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>())</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; out;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : nums2)</span><br><span class="line">        <span class="keyword">if</span> (s.erase(x))</span><br><span class="line">            out.push_back(x);</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Remove-Element</title>
      <link href="/2017/12/17/Remove-Element/"/>
      <url>/2017/12/17/Remove-Element/</url>
      
        <content type="html"><![CDATA[<p>第81天。</p><p>今天的题目是<a href="https://leetcode.com/problems/remove-element/description/" target="_blank" rel="noopener">Remove Element</a>:</p><blockquote><p>Given an array and a value, remove all instances of that value in-place and return the new length.</p><p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p><p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p><p>Example:</p><p>Given nums = [3,2,2,3], val = 3,</p><p>Your function should return length = 2, with the first two elements of nums being 2.</p></blockquote><p>简单的我们可以遍历数组，然后找到和<code>val</code>相同的元素，然后删除，但是这样对于多个相同的元素效率不高，所以我们先不删除元素，而是把他移动到最后面去，知道遍历完才删除。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; last;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == val) swap(nums[--last],nums[i--]);</span><br><span class="line">    &#125;</span><br><span class="line">    nums.erase(nums.<span class="built_in">begin</span>() + last,nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dicuss</code>中另一个方法也很精妙：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n, <span class="keyword">int</span> elem)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">begin</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(A[i]!=elem) A[<span class="built_in">begin</span>++]=A[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">begin</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reverse-String</title>
      <link href="/2017/12/16/Reverse-String/"/>
      <url>/2017/12/16/Reverse-String/</url>
      
        <content type="html"><![CDATA[<p>第80天。</p><p>今天的题目是<a href="https://leetcode.com/problems/reverse-string/description/" target="_blank" rel="noopener">Reverse String</a>:</p><blockquote><p>Write a function that takes a string as input and returns the string reversed.</p><p>Example:<br>Given s = “hello”, return “olleh”.</p></blockquote><p>水的不能再水的题目.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>,j = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">        swap(s[i++],s[j--]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用<code>python</code>话：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseString</span><span class="params">(self, s)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :rtype: str</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> s[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reverse-Words-in-a-String-III</title>
      <link href="/2017/12/15/Reverse-Words-in-a-String-III/"/>
      <url>/2017/12/15/Reverse-Words-in-a-String-III/</url>
      
        <content type="html"><![CDATA[<p>第79天。</p><p>今天的题目是<a href="https://leetcode.com/problems/reverse-words-in-a-string-iii/description/" target="_blank" rel="noopener">Reverse Words in a String III</a>:</p><blockquote><p>Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.</p><p>Example 1:<br>Input: “Let’s take LeetCode contest”<br>Output: “s’teL ekat edoCteeL tsetnoc”<br>Note: In the string, each word is separated by single space and there will not be &gt; any extra space in the string.</p></blockquote><p>用<code>python</code>的话就很简单了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span><span class="params">(self, s)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :rtype: str</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    words = s.split()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(words)):</span><br><span class="line">        words[i] = words[i][::<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">' '</span>.join(words)</span><br></pre></td></tr></table></figure><p>然后是<code>dicuss</code>中的<code>c</code>解法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> b, <span class="keyword">int</span> e, <span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(b &lt; e) &#123;</span><br><span class="line">        s[b] = s[b] ^ s[e];</span><br><span class="line">        s[e] = s[b] ^ s[e];</span><br><span class="line">        s[b] = s[b] ^ s[e];</span><br><span class="line">        b++;</span><br><span class="line">        e--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">reverseWords</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, s_len = <span class="built_in">strlen</span>(s), index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= s_len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>((s[i] == <span class="string">' '</span>) || (s[i] == <span class="string">'\0'</span>))&#123;</span><br><span class="line">            reverse(index, i - <span class="number">1</span>, s);</span><br><span class="line">            index = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Intersection-of-Two-Arrays-II</title>
      <link href="/2017/12/14/Intersection-of-Two-Arrays-II/"/>
      <url>/2017/12/14/Intersection-of-Two-Arrays-II/</url>
      
        <content type="html"><![CDATA[<p>第78天。</p><p>又是<code>hash</code>,为什么每次都随机到<code>hash</code>.</p><p>今天的题目是<a href="https://leetcode.com/problems/intersection-of-two-arrays-ii/description/" target="_blank" rel="noopener">Intersection of Two Arrays II</a>:</p><blockquote><p>Given two arrays, write a function to compute their intersection.</p><p>Example:<br>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].</p><p>Note:<br>Each element in the result should appear as many times as it shows in both arrays.<br>The result can be in any order.<br>Follow up:<br>What if the given array is already sorted? How would you optimize your algorithm?<br>What if nums1’s size is small compared to nums2’s size? Which algorithm is better?<br>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</p></blockquote><p>和昨天的解法有点想,先遍历一个数组，用<code>hash table</code>进行计数，然后再遍历第二个数组，然后实时的更新<code>hash table</code>就好了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersec1t</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:nums1) m[i]++;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            ret.push_back(i);</span><br><span class="line">            m[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有就是可以用<code>sort</code>来做：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    sort(nums1.<span class="built_in">begin</span>(),nums1.<span class="built_in">end</span>());</span><br><span class="line">    sort(nums2.<span class="built_in">begin</span>(),nums2.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> i1,i2;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    <span class="keyword">for</span>(i1=<span class="number">0</span>,i2=<span class="number">0</span>;i1 &lt; nums1.<span class="built_in">size</span>() &amp;&amp; i2 &lt; nums2.<span class="built_in">size</span>();) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i1] == nums2[i2]) &#123;</span><br><span class="line">            ret.push_back(nums1[i1]);</span><br><span class="line">            i1++; i2++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i1] &gt; nums2[i2]) i2++;</span><br><span class="line">        <span class="keyword">else</span> i1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Longest-Harmonious-Subsequence</title>
      <link href="/2017/12/13/Longest-Harmonious-Subsequence/"/>
      <url>/2017/12/13/Longest-Harmonious-Subsequence/</url>
      
        <content type="html"><![CDATA[<p>第77天。</p><p>今天的题目是<a href="https://leetcode.com/problems/longest-harmonious-subsequence/description/" target="_blank" rel="noopener">Longest Harmonious Subsequence</a>:</p><blockquote><p>We define a harmonious array is an array where the difference between its maximum value and its minimum value is exactly 1.</p><p>Now, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible subsequences.</p><p>Example 1:<br>Input: [1,3,2,2,5,2,3,7]<br>Output: 5<br>Explanation: The longest harmonious subsequence is [3,2,2,2,3].<br>Note: The length of the input array will not exceed 20,000.</p></blockquote><p>好像有是一个用<code>hash</code>做的题目：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findLHS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        m[nums[i]]++;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;p:m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m.count(p.first + <span class="number">1</span>) &gt; <span class="number">0</span>)</span><br><span class="line">            len = <span class="built_in">max</span>(len,p.second + m[p.first + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dicuss</code>中有用<code>sort</code>做的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findLHS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, start = <span class="number">0</span>, new_start = <span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[i] - nums[start] &gt; <span class="number">1</span>)</span><br><span class="line">            start = new_start;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != nums[i<span class="number">-1</span>])</span><br><span class="line">            new_start = i;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] - nums[start] == <span class="number">1</span>)</span><br><span class="line">            len = <span class="built_in">max</span>(len, i-start+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Length-of-Last-Word</title>
      <link href="/2017/12/12/Length-of-Last-Word/"/>
      <url>/2017/12/12/Length-of-Last-Word/</url>
      
        <content type="html"><![CDATA[<p>第76天。</p><p>快考试，可能要水一个月的<code>easy</code>题了。</p><p>今天的题目是<a href="https://leetcode.com/problems/length-of-last-word/description/" target="_blank" rel="noopener">Length of Last Word</a>:</p><blockquote><p>Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string.</p><p>If the last word does not exist, return 0.</p><p>Note: A word is defined as a character sequence consists of non-space characters only.</p><p>Example:</p><p>Input: “Hello World”<br>Output: 5</p></blockquote><p>一看完题目，我就想到了<code>python</code>的<code>split</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span><span class="params">(self, s)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    words = s.split();</span><br><span class="line">    <span class="keyword">if</span> len(words) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> len(words[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><p>然后是用<code>c++</code>用<code>find</code>去解的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> beg = s.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">auto</span> it = beg;</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> = s.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">// fix the bug like that "hello world "</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>;i &gt;= <span class="number">0</span> &amp;&amp; s[i] == <span class="string">' '</span>;i--)</span><br><span class="line">        <span class="built_in">end</span>--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((it = <span class="built_in">find</span>(beg,<span class="built_in">end</span>,<span class="string">' '</span>)) != <span class="built_in">end</span>) &#123;</span><br><span class="line">        beg = it + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">end</span> - beg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是从后面向前扫描的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> = s.rbegin();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">end</span> != s.rend() &amp;&amp; *<span class="built_in">end</span> == <span class="string">' '</span>) <span class="built_in">end</span>++;</span><br><span class="line">    <span class="keyword">auto</span> beg = <span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">while</span>(beg != s.rend() &amp;&amp; *beg != <span class="string">' '</span>) beg++;</span><br><span class="line">    <span class="keyword">return</span> beg - <span class="built_in">end</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是<code>dicuss</code>中的解法，和上面的从后向前扫描的方法类似，只不过它第二个循环里面顺带计算了<code>length</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>, tail = s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (tail &gt;= <span class="number">0</span> &amp;&amp; s[tail] == <span class="string">' '</span>) tail--;</span><br><span class="line">    <span class="keyword">while</span> (tail &gt;= <span class="number">0</span> &amp;&amp; s[tail] != <span class="string">' '</span>) &#123;</span><br><span class="line">        len++;</span><br><span class="line">        tail--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maximum-Swap</title>
      <link href="/2017/12/11/Maximum-Swap/"/>
      <url>/2017/12/11/Maximum-Swap/</url>
      
        <content type="html"><![CDATA[<p>第75天。</p><p>今天的题目是<a href="https://leetcode.com/problems/maximum-swap/description/" target="_blank" rel="noopener">Maximum Swap</a>:</p><blockquote><p>Given a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get.</p><p>Example 1:<br>Input: 2736<br>Output: 7236<br>Explanation: Swap the number 2 and the number 7.<br>Example 2:<br>Input: 9973<br>Output: 9973<br>Explanation: No swap.<br>Note:<br>The given number is in the range [0, 10^8]</p></blockquote><p>怎么说呢，写一个不优雅的解法还是挺简单的。</p><p>先把<code>num</code>分解成多个<code>digit</code>，然后尝试在找出最大的，如果最大的值和最高位不同，我们就交换，如果相同，我们就找出除去最高位的最大值，直到找不到能交换的，或者交换一次，我们就退出。</p><p>然后把<code>digit</code>按照对应的次序还原即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximumSwap</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(num != <span class="number">0</span>) &#123;</span><br><span class="line">        t.push_back(num % <span class="number">10</span>);</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = t.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> <span class="built_in">max</span> = max_element(t.<span class="built_in">begin</span>(),t.<span class="built_in">begin</span>() + k + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (*<span class="built_in">max</span> != t[k]) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = *<span class="built_in">max</span>;</span><br><span class="line">            *<span class="built_in">max</span> = t[k];</span><br><span class="line">            t[k] = a;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = t.rbegin();it != t.rend();it++) &#123;</span><br><span class="line">        num = <span class="number">10</span> * num + *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是<code>dicuss</code>中的解法,好像想法差不多。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximumSwap</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> numString = to_string(num);</span><br><span class="line">    <span class="keyword">int</span> n = numString.length();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dpPosition</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> curMaxPos = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numString[i] &gt; numString[curMaxPos]) &#123;</span><br><span class="line">            curMaxPos = i;</span><br><span class="line">        &#125;</span><br><span class="line">        dpPosition[i] = curMaxPos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(numString[dpPosition[i]] != numString[i]) &#123;</span><br><span class="line">            swap(numString[i], numString[dpPosition[i]]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stoi(numString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Contains-Duplicate-II</title>
      <link href="/2017/12/10/Contains-Duplicate-II/"/>
      <url>/2017/12/10/Contains-Duplicate-II/</url>
      
        <content type="html"><![CDATA[<p>第74天。</p><p>今天的题目是<a href="https://leetcode.com/problems/contains-duplicate-ii/description/" target="_blank" rel="noopener">Contains Duplicate II</a>:</p><blockquote><p>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.</p></blockquote><p>显然这道题目可以用两个循环去实现，但是这样会超时，效率不高。</p><p>这里是用<code>Hash Table</code>去做的,<code>key</code>存储<code>nums[i]</code>,<code>value</code>存储<code>i</code>,这样我们用<code>O(n)</code>的时间就可以完成了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m.<span class="built_in">find</span>(nums[i]) != m.<span class="built_in">end</span>() &amp;&amp; m[nums[i]] + k &gt;= i) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        m[nums[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dicuss</code>中的做法是用<code>unordered_set</code>去做的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= nums.<span class="built_in">size</span>()) k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; k) s.erase(nums[i - k - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">find</span>(nums[i]) != s.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        s.insert(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lexicographical-Number</title>
      <link href="/2017/12/09/Lexicographical-Number/"/>
      <url>/2017/12/09/Lexicographical-Number/</url>
      
        <content type="html"><![CDATA[<p>第73天。</p><p>今天的题目是<a href="https://leetcode.com/problems/lexicographical-numbers/discuss/" target="_blank" rel="noopener">Lexicographical Numbers</a>:</p><blockquote><p>Given an integer n, return 1 - n in lexicographical order.</p><p>For example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9].</p><p>Please optimize your algorithm to use less time and space. The input size may be as large as 5,000,000.</p></blockquote><p>emmm，<code>lexicographical</code>是字典序的意思。</p><p>首先，这种有规律的题目一般用递归来写会比较简单（但是可能会超时），我们先找出它的规律，在不到<code>n</code>的时候，没加入一个数字i,我们就要看<code>i*10 ~ i*10 + 9</code>是否小于<code>n</code>,如果小于我们就把它加入，然后在递归的进行判断。</p><p>有一点需要注意的就是，它是从<code>1</code>开始的，所以我们一开始就要尝试的把<code>1 ~ 9</code>加入，而不是<code>0 ~ 9</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">lexicalOrder</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    <span class="comment">//lexicalOrder(ret,n,1);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">10</span> &amp;&amp; i &lt;= n;i++) &#123;</span><br><span class="line">        ret.push_back(i);</span><br><span class="line">        lexicalOrder(ret,n,i*<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lexicalOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec,<span class="keyword">int</span> n,<span class="keyword">int</span> base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++,base++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (base &gt; n)&#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">        vec.push_back(base);</span><br><span class="line">        lexicalOrder(vec,n,<span class="number">10</span>*base);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是在<code>dicuss</code>中看到的迭代解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">lexicalOrder</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        res[i] = cur;</span><br><span class="line">        <span class="keyword">if</span> (cur * <span class="number">10</span> &lt;= n) &#123;</span><br><span class="line">            cur *= <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur &gt;= n) </span><br><span class="line">                cur /= <span class="number">10</span>;</span><br><span class="line">            cur += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (cur % <span class="number">10</span> == <span class="number">0</span>)</span><br><span class="line">                cur /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Find-Peak-Element</title>
      <link href="/2017/12/08/Find-Peak-Element/"/>
      <url>/2017/12/08/Find-Peak-Element/</url>
      
        <content type="html"><![CDATA[<p>第72天。</p><p>今天的题目是<a href="https://leetcode.com/problems/find-peak-element/description/" target="_blank" rel="noopener">Find Peak Element</a>:</p><blockquote><p>A peak element is an element that is greater than its neighbors.</p><p>Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.</p><p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p><p>You may imagine that num[-1] = num[n] = -∞.</p><p>For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.</p></blockquote><p>显然这道题写出一个<code>O(n)</code>的解法很简单。</p><p>这里的用二分法去求解，可以用<code>O(logn)</code>解出，<code>分</code>和<code>合</code>两个步骤都是<code>O(1)</code>的时间复杂度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findPeakElement(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeakElement1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> first,<span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first &gt; last) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (first + last)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( (mid+<span class="number">1</span> == nums.<span class="built_in">size</span>() || nums[mid] &gt; nums[mid + <span class="number">1</span>]) &amp;&amp;</span><br><span class="line">            (mid<span class="number">-1</span> &lt; <span class="number">0</span> || nums[mid] &gt; nums[mid<span class="number">-1</span>]) )</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">int</span> left = findPeakElement(nums,first,mid<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="number">-1</span>) <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">return</span> findPeakElement(nums,mid+<span class="number">1</span>,last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这不是最好的解法，这里其实是用二分查找去做的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Helper(num, <span class="number">0</span>, num.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Helper</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low == high)</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid1 = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> mid2 = mid1+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(num[mid1] &gt; num[mid2])</span><br><span class="line">            <span class="keyword">return</span> Helper(num, low, mid1);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Helper(num, mid2, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = num.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid1 = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> mid2 = mid1+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(num[mid1] &lt; num[mid2])</span><br><span class="line">            low = mid2;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            high = mid1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Find-Bottom-Left-Tree</title>
      <link href="/2017/12/07/Find-Bottom-Left-Tree/"/>
      <url>/2017/12/07/Find-Bottom-Left-Tree/</url>
      
        <content type="html"><![CDATA[<p>第71天。</p><p>今天的题目是<a href="https://leetcode.com/problems/find-bottom-left-tree-value/description/" target="_blank" rel="noopener">Find Bottom Left Tree Value</a>:</p><blockquote><p>Given a binary tree, find the leftmost value in the last row of the tree.</p><p>Example 1:<br>Input:</p></blockquote><pre><code>2</code></pre><p>   / <br>  1   3</p><blockquote><p>Output:<br>1<br>Example 2:<br>Input:</p></blockquote><pre><code>    1   / \  2   3 /   / \4   5   6   /  7</code></pre><blockquote><p>Output:<br>7<br>Note: You may assume the tree (i.e., the given root node) is not NULL.</p></blockquote><p>显然这可以用带高度的深度优先去做：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode *root,<span class="keyword">int</span> &amp;<span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">height</span> = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    <span class="keyword">int</span> lefth,righth;</span><br><span class="line">    lefth = righth = <span class="built_in">height</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = findBottomLeftValue(root-&gt;left,lefth);</span><br><span class="line">    <span class="keyword">int</span> right = findBottomLeftValue(root-&gt;right,righth);</span><br><span class="line">    <span class="keyword">if</span> (lefth &gt;= righth) &#123;</span><br><span class="line">        <span class="built_in">height</span> = lefth;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">height</span> = righth;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> findBottomLeftValue(root,h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来就不优雅，而且很繁琐的样子,下面是<code>dicuss</code>中用广度优先去做的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLeftMostNode</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        root = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>)</span><br><span class="line">            queue.add(root.right);</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>)</span><br><span class="line">            queue.add(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及<code>python</code>版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findLeftMostNode</span><span class="params">(self, root)</span>:</span></span><br><span class="line">    queue = [root]</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> queue:</span><br><span class="line">        queue += filter(<span class="literal">None</span>, (node.right, node.left))</span><br><span class="line">    <span class="keyword">return</span> node.val</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Count-Numbers-with-Unique-Digits</title>
      <link href="/2017/12/06/Count-Numbers-with-Unique-Digits/"/>
      <url>/2017/12/06/Count-Numbers-with-Unique-Digits/</url>
      
        <content type="html"><![CDATA[<p>第70天。</p><p>今天的题目是<a href="https://leetcode.com/problems/count-numbers-with-unique-digits/description/" target="_blank" rel="noopener">Count Numbers with Unique Digits</a>:</p><blockquote><p>Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x &lt; 10^n.</p><p>Example:<br>Given n = 2, return 91. (The answer should be the total numbers in the range of 0 ≤ x &lt; 100, excluding [11,22,33,44,55,66,77,88,99])</p></blockquote><p>先解释一下题目，所谓的<code>unique digits</code>就是这个数字中不包含相同的数字。</p><p>理解到这个的话，我们就从<code>n=2</code>开始考虑。</p><p>其实只需要一点排列组合的知识就可以发现如果它是个2位数,那么就会有<code>9*9</code>,第一个之所以是9，是因为，<code>0</code>不能出现在最高位，后面的那个是就是因为他不能和前面那个数字相同。如果是个3位数，那就是<code>9*9*8</code>,那个8是因为不能和前面两位出现的数字。</p><p>然后其实我们这里只得出来n位数的情况，但是它要的范围是<code>0 &lt; x &lt; 10^n</code>。这样的话，如果<code>n=3</code>,我们就需要求出1位数的个数、2位数的个数、3位数的个数，然后他们的和就是答案了。</p><p>我们可以写成动态规划的形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countNumbersWithUniqueDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n &amp;&amp; a &gt; <span class="number">0</span>;i++) &#123;</span><br><span class="line">        dp[i] = k + dp[i<span class="number">-1</span>];</span><br><span class="line">        k *= a;</span><br><span class="line">        a--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = dp[n];</span><br><span class="line">    <span class="keyword">delete</span> dp;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Trim-a-Binary-Search-Tree</title>
      <link href="/2017/12/05/Trim-a-Binary-Search-Tree/"/>
      <url>/2017/12/05/Trim-a-Binary-Search-Tree/</url>
      
        <content type="html"><![CDATA[<p>第69天。</p><p>今天的题目是<a href="https://leetcode.com/problems/trim-a-binary-search-tree/description/" target="_blank" rel="noopener">Trim a Binary Search Tree</a>:</p><blockquote><p>Given a binary search tree and the lowest and highest boundaries as L and R, trim the tree so that all its elements lies in [L, R] (R &gt;= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree.</p><p>Example 1:<br>Input:</p></blockquote><pre><code>1</code></pre><p>   / <br>  0   2</p><p>  L = 1<br>  R = 2</p><blockquote><p>Output:</p></blockquote><pre><code>1  \   2</code></pre><blockquote><p>Example 2:<br>Input:</p></blockquote><pre><code>3</code></pre><p>   / <br>  0   4<br>   <br>    2<br>   /<br>  1</p><p>  L = 1<br>  R = 3</p><blockquote><p>Output:</p></blockquote><pre><code> 3/</code></pre><p>   2<br>  /<br> 1</p><p>一开始没看到时二叉排序树，然后写的就有点复杂了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    root-&gt;left = trimBST(root-&gt;left,L,R);</span><br><span class="line">    root-&gt;right = trimBST(root-&gt;right,L,R);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt;= L &amp;&amp; root-&gt;val &lt;= R) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span> &amp;&amp; root-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = root-&gt;left;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;left) p = p-&gt;left;</span><br><span class="line">        p-&gt;left = root-&gt;right;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (root-&gt;left)?root-&gt;left:root-&gt;right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; L) <span class="keyword">return</span> trimBST(root-&gt;right,L,R);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt; R) <span class="keyword">return</span> trimBST(root-&gt;left,L,R);</span><br><span class="line">    root-&gt;left = trimBST(root-&gt;left,L,R);</span><br><span class="line">    root-&gt;right = trimBST(root-&gt;right,L,R);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Longest-Continuous-Increasing-Subsqeuence</title>
      <link href="/2017/12/04/Longest-Continuous-Increasing-Subsqeuence/"/>
      <url>/2017/12/04/Longest-Continuous-Increasing-Subsqeuence/</url>
      
        <content type="html"><![CDATA[<p>第68天。</p><p>今天的题目是<a href="https://leetcode.com/problems/longest-continuous-increasing-subsequence/description/" target="_blank" rel="noopener">Longest Continuous Increasing Subsequence</a>:</p><blockquote><p>Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarra y).</p><p>Example 1:<br>Input: [1,3,5,4,7]<br>Output: 3<br>Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3.<br>Even though [1,3,5,7] is also an increasing subsequence, it’s not a continuous one where 5 and 7 are separated by 4.<br>Example 2:<br>Input: [2,2,2,2,2]<br>Output: 1<br>Explanation: The longest continuous increasing subsequence is [2], its length is 1.<br>Note: Length of the array will not exceed 10,000.</p></blockquote><p>题目比较简单，只需要遍历一遍所有元素，然后每次都比较它和它前面一个元素的大小即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i + <span class="number">1</span> &lt; nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; nums[i+<span class="number">1</span>]) a++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ret = <span class="built_in">max</span>(a,ret);</span><br><span class="line">            a = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(a,ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Valid-Triangle-Number</title>
      <link href="/2017/12/03/Valid-Triangle-Number/"/>
      <url>/2017/12/03/Valid-Triangle-Number/</url>
      
        <content type="html"><![CDATA[<p>第67天。</p><p>今天的题目是<a href="https://leetcode.com/problems/valid-triangle-number/description/" target="_blank" rel="noopener">Valid Triangle Number</a>:</p><blockquote><p>Given an array consists of non-negative integers, your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.<br>Example 1:<br>Input: [2,2,3,4]<br>Output: 3<br>Explanation:<br>Valid combinations are:<br>2,3,4 (using the first 2)<br>2,3,4 (using the second 2)<br>2,2,3<br>Note:<br>The length of the given array won’t exceed 1000.<br>The integers in the given array are in the range of [0, 1000].</p></blockquote><p>莫名其妙的用一个<code>O(n^3)</code>的解法AC了:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">triangleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; nums.<span class="built_in">size</span>();j++) &#123;</span><br><span class="line">            <span class="comment">//nums[i] + num[j] &gt; a;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = j+<span class="number">1</span>;k &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[i] + nums[j] &gt; nums[k];k++)</span><br><span class="line">                ret++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是<code>dicuss</code>中的<code>O(n^2)</code>的解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">triangleNumber</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(A);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, n = A.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n-<span class="number">1</span>;i&gt;=<span class="number">2</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = i-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[l] + A[r] &gt; A[i]) &#123;</span><br><span class="line">                count += r-l;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Binary-Tree-Right-Side-View</title>
      <link href="/2017/12/02/Binary-Tree-Right-Side-View/"/>
      <url>/2017/12/02/Binary-Tree-Right-Side-View/</url>
      
        <content type="html"><![CDATA[<p>第66天。</p><p>今天的题目是<a href="https://leetcode.com/problems/binary-tree-right-side-view/discuss/" target="_blank" rel="noopener">Binary Tree Right Side View</a>:</p><blockquote><p>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p><p>For example:<br>Given the following binary tree,</p></blockquote><p>   1            &lt;—<br> /   <br>2     3         &lt;—<br> \     <br>  5     4       &lt;—</p><blockquote><p>You should return [1, 3, 4].</p></blockquote><p>挺有趣的题目。</p><p>简单的来讲，首先，我们肯定是要让右子树优先，然后还要保证在左子树比右子树高的情况下，它的节点也能被放到要返回的数组中。</p><p>要比较高度，我们就需要在遍历的时候带上一个<code>height</code>,然后我们从按右子树优先进行先序遍历，这样就可以保证上面两个条件满足了，那，现在就是要计算什么时候将节点加入数组了。</p><p>我们可以发现返回的数组的大小和树的高度是相同的，这样我们就可以通过当前节点的高度来决定是否要将值加入数组，又因为我们遍历的时候已经是右子树优先了，所以第一次遇到这个高度的节点的时候，我们就可以直接将其放入数组中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rightSideView1</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    helper(root,<span class="number">0</span>,ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode *root,<span class="keyword">int</span> <span class="built_in">height</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ret)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">height</span> == ret.<span class="built_in">size</span>()) ret.push_back(root-&gt;val);</span><br><span class="line">    helper(root-&gt;right,<span class="built_in">height</span> + <span class="number">1</span>,ret);</span><br><span class="line">    helper(root-&gt;left,<span class="built_in">height</span>+<span class="number">1</span>,ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是<code>dicuss</code>中用层次遍历做的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// reverse level traversal</span></span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (queue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            TreeNode cur = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) result.add(cur.val);</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swaps-Nodes-in-Pairs</title>
      <link href="/2017/12/01/Swaps-Nodes-in-Pairs/"/>
      <url>/2017/12/01/Swaps-Nodes-in-Pairs/</url>
      
        <content type="html"><![CDATA[<p>第65天。</p><p>今天的题目是<a href="https://leetcode.com/problems/swap-nodes-in-pairs/description/" target="_blank" rel="noopener">Swap Nodes in Pairs</a>:</p><blockquote><p>Given a linked list, swap every two adjacent nodes and return its head.</p><p>For example,<br>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p><p>Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.</p></blockquote><p>和之前做的链表翻转有点像，可以用指针的指针来做：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">swap</span><span class="params">(ListNode **head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*head == <span class="literal">nullptr</span> || ( *head)-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ListNode *p = *head;</span><br><span class="line">    ListNode *next = p-&gt;next;</span><br><span class="line">    p-&gt;next = next-&gt;next;</span><br><span class="line">    next-&gt;next = p;</span><br><span class="line">    *head = next;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode **p = &amp;head;</span><br><span class="line">    <span class="keyword">while</span>(swap(p))</span><br><span class="line">        p=&amp;((*p)-&gt;next-&gt;next);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> ListNode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Convert Sorted Array to Binary Search Tree</title>
      <link href="/2017/11/30/Convert-Sorted-Array-to-Binary-Search-Tree/"/>
      <url>/2017/11/30/Convert-Sorted-Array-to-Binary-Search-Tree/</url>
      
        <content type="html"><![CDATA[<p>第64天。</p><p>要死了，天天晚睡早起的，今天一定要早睡晚起（或者等下就睡睡先）</p><p>今天的题目是<a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/" target="_blank" rel="noopener">Convert Sorted Array to Binary Search Tree</a>:</p><blockquote><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p></blockquote><p>这道题其实一开始没有思路的，感觉很难搞的样子，但是今天数据结构课上讲二分查找时提到了二分查找树（好像是这个名字），然后就觉得好像它就是一个<code>height balanced BST</code>.</p><p>然后就仿照二分查找的递归算法解出了这道题，其实就是二分查找的逆过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sortedArrayToBST(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode *<span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">    TreeNode *root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">    root-&gt;left = sortedArrayToBST(nums,low,mid<span class="number">-1</span>);</span><br><span class="line">    root-&gt;right = sortedArrayToBST(nums,mid+<span class="number">1</span>,high);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Path-Sum</title>
      <link href="/2017/11/29/Path-Sum/"/>
      <url>/2017/11/29/Path-Sum/</url>
      
        <content type="html"><![CDATA[<p>第63天。</p><p>赶算法实验，再水一题。</p><p>今天的题目是<a href="https://leetcode.com/problems/path-sum/description/" target="_blank" rel="noopener">Path Sum</a>:</p><blockquote><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p><p>For example:<br>Given the below binary tree and sum = 22,</p></blockquote><pre><code>      5     / \    4   8   /   / \  11  13  4 /  \      \7    2      1</code></pre><blockquote><p>return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.</p></blockquote><p>比较简单，但是有一些坑点。</p><ul><li>它要求一定要到<code>left</code>.</li><li>然后空节点不能当成<code>0</code>.</li></ul><p>然后是代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> sum == root-&gt;val;</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left) <span class="keyword">return</span> hasPathSum(root-&gt;right,sum-root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;right) <span class="keyword">return</span> hasPathSum(root-&gt;left,sum - root-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root-&gt;left,sum - root-&gt;val) || hasPathSum(root-&gt;right,sum - root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实<code>dicuss</code>中的更精炼一点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode *root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == sum &amp;&amp; root-&gt;left ==  <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root-&gt;left, sum-root-&gt;val) || hasPathSum(root-&gt;right, sum-root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Plus-One</title>
      <link href="/2017/11/28/Plus-One/"/>
      <url>/2017/11/28/Plus-One/</url>
      
        <content type="html"><![CDATA[<p>第62天。</p><p>今天很不在状态啊，明明是课最少的一天，却把那么多事拖到了晚上。</p><p>今天的题目是<a href="https://leetcode.com/problems/plus-one/discuss/" target="_blank" rel="noopener">Plus One</a>:</p><blockquote><p>Given a non-negative integer represented as a non-empty array of digits, plus one to the integer.</p><p>You may assume the integer do not contain any leading zero, except the number 0 itself.</p><p>The digits are stored such that the most significant digit is at the head of the list.</p></blockquote><p>比较简单的一道的题目，就是给你一个数组来表示一个数字，而且又不没有负数什么的，只需要从后往前遍历一遍，对当前元素进行加一再模上10，如果变成了<code>0</code>,那么说明有进位，我们继续遍历，如果不是<code>0</code>,说明后面的元素都没有改变，直接返回即可。</p><p>然后需要考虑的就是<code>99</code>这种类型，因为他本来是用两个数字即可表示,但是加一后需要3个数字：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">plusOne</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = digits.rbegin();it != digits.rend();it++) &#123;</span><br><span class="line">        *it = (*it + <span class="number">1</span>) % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (*it != <span class="number">0</span>) <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*digits.<span class="built_in">begin</span>() == <span class="number">0</span>) digits.insert(digits.<span class="built_in">begin</span>(),<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> digits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Single Number III</title>
      <link href="/2017/11/27/Single-Number-III/"/>
      <url>/2017/11/27/Single-Number-III/</url>
      
        <content type="html"><![CDATA[<p>第61天。</p><p>今天的题目是<a href="https://leetcode.com/problems/single-number-iii/description/" target="_blank" rel="noopener">Single Number III</a>:</p><blockquote><p>Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.</p><p>For example:</p><p>Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].</p><p>Note:<br>The order of the result is not important. So in the above example, [5, 3] is also correct.<br>Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?</p></blockquote><p>在求解这个问题之前，我们先考虑一下简化后的问题，如果只有一个Single Number的话，我们要怎么求解。</p><p>如果熟悉异或运算的话，就很快的想出解决办法，这里用到了三个性质：</p><ul><li>0^a = a</li><li>a^a = 0</li><li>a^b^a = b</li></ul><p>假设现在序列有个数，分别为<code>n1,n2,n2...nk</code>,我们将它们异或起来：<br><code>t = n1^n2^n3^...^nk</code>,因为中间只有一个<code>single number</code>,所以t中只有一个数不能因为<code>a^a = 0</code>而消除掉。因此<code>t</code>就是这个序列中的<code>single number</code>.</p><p>这是只有一个<code>single number</code>的情况，如果我们用类似的方法去做这道题的话，我们会得到<code>t = a1^a2</code>,但是显然我们无法快速的将a1和a2分解出来，除非我们知道其中一个数。</p><p>那我们能不能把序列分成两部分来做，每部分都包含一个<code>single number</code>且其余的数都包含两个，我们可以从<code>bit</code>的角度来考虑，如果某个位（比如说最低位）为<code>1</code>,那我们就将它分到第一部分，否则我们就将它分到第二部分，这样的方法可以很好的区分除了<code>single number</code>之外的数（因为两个<code>single number</code>可能分到相同的部分）。现在的问题就是我们要怎么将两个<code>single number</code>分到不同部分。</p><p>现在我们已经有了<code>t = a1^a2</code>,异或的定义是不同的bit为<code>1</code>,相同的bit为<code>0</code>,所以说t中为<code>1</code>的bit位（总是可以找到）可以作为我们上面那个算法的区分点了。</p><p>然后现在就是找出<code>t</code>中一个为<code>1</code>的<code>bit</code>了，简单的可以遍历去做，比较只有32位，所以时间复杂度是<code>O(1)</code>的，但是我们有一个更快的方法：<br><code>t &amp; (t-1)</code>可以将第一个为<code>1</code>的bit位清0,然后我们再异或上原来的t,我们就可以得到对应的<code>mask</code>了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:nums) t ^= i;</span><br><span class="line">    <span class="keyword">int</span> lastBit = (t &amp; (t<span class="number">-1</span>)) ^ t;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:nums) <span class="keyword">if</span> (i&amp;lastBit) a^=i;</span><br><span class="line">    <span class="keyword">return</span> &#123;a,a^t&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Bit-Manipulation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The-Learning-Problem</title>
      <link href="/2017/11/26/The-Learning-Problem/"/>
      <url>/2017/11/26/The-Learning-Problem/</url>
      
        <content type="html"><![CDATA[<p>最近看完了<code>Machine-Learning-Foundations</code>的第一个单元，做一个下总结吧。</p><ul><li>humman learning<ul><li>acquiring skill with experience accumulated from observation<br>即 observation -&gt; learning -&gt; skill</li></ul></li><li>machine learning:<ul><li>auquiring skill with experience accumulated/computed from data</li></ul></li></ul><p>skill &lt;=&gt; improve some performance measure<br>so<br><code>Machine Learning</code>: improving some performance measure with experience computed from data.</p><p>The key essence of Machine Learning:</p><ol><li>exists some <code>underlying pattern</code> can be improved</li><li>but no programmable (easy) definition</li><li>somehow there is data about pattern.</li></ol><p>形式化机器学习：</p><ul><li>Input: $x \in X$</li><li>Output: $y \in Y$</li><li>target-func: $X-&gt;Y$</li></ul><p>the target-func &lt;=&gt; unknown pattern to be learned.</p><p>data &lt;=&gt; traning example &lt;=&gt; $D = { (x_1,y_1),(x_2,y_2),… }$</p><p>hypothesis &lt;=&gt; skill with hopefully good example.</p><p><img src="http://olrv1mriz.bkt.clouddn.com/blog/171126/0hG24B2BCJ.png?imageslim" alt="mark"></p><p>Machine Learning:</p><p>use data to compute hypothesis g that approximates target f.</p>]]></content>
      
      
      <categories>
          
          <category> Machine-Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine-Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂记-2017-11-26</title>
      <link href="/2017/11/26/%E6%9D%82%E8%AE%B0-2017-11-26/"/>
      <url>/2017/11/26/%E6%9D%82%E8%AE%B0-2017-11-26/</url>
      
        <content type="html"><![CDATA[<p>2017-11-26</p><p>悠闲的下午（其实只是不想写作业，不想背单词）我觉得写一篇blog来总结一下，毕竟已经过去了大半个学期。</p><p>这学期课很多，收获也很多。</p><p>从9月份的某一天开始，每天刷LeetCode,每天写Blog,每天背单词。</p><p>说实话，习惯的力量真的很强大，其实每天刷道题这种想法早在上学期就有了，但是没错做几天就放弃了，最可怕的是一放弃，再次拿起来的时候就是下一次开始了。</p><p>不知道是不是因为这次每天都会写<code>blog</code>来记录刷题的过程，所以一直有个激励，虽然说有时候会因为做题而花很多时间（而且我的课又多），有时候也会因为没有时间而不得不找一道水题来做，不过即使是水题，换成暑假的我估计也做不出来，而且像<code>dp</code>的问题，之前是怎么都想不出来的，现在也慢慢的有了思路。</p><p>这种解决问题能力的提升算得上是这学期最大的收获了吧！</p><p>还有一些其他的，比如说上了一门大四的课（虽然个人感觉难度并没有大三的某些课难），进入冯老师的实验室做<code>ML</code>,虽然我什么都不会，恩，一点一点的学吧。</p><p>说了那么多好的事情，总要反省一下：</p><ul><li>至今没有养成好好看书的好习惯（好像这学期忙到课本都没好好看了）</li><li>Machine Learning 还菜的要死，虽然现在师兄师姐们不嫌弃（不知道是不是真的不嫌弃），但是还是要好好赶上去啊</li><li>一直没能好好锻炼身体，希望身体不要虚下去（这种时候一生病就惨咯）</li></ul><p>恩，以后每天晚上都要去自习室学习<code>Machine Learning</code>的东西，每天都要把学到的东西总结一下。（等下就总结之前学的东西）</p><p>恍恍惚惚的好像大三又过去了一半，虽然已经决定读研了，但是感觉还是看不清未来的样子，也不知道之后会遇到什么，成为什么，whaterver,慢慢的走下去吧。</p>]]></content>
      
      
      <categories>
          
          <category> 杂事一堆 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>House-Robber-III</title>
      <link href="/2017/11/26/House-Robber-III/"/>
      <url>/2017/11/26/House-Robber-III/</url>
      
        <content type="html"><![CDATA[<p>第60天。</p><p>今天的题目是<a href="https://leetcode.com/problems/house-robber-iii/description/" target="_blank" rel="noopener">House Robber III</a>：</p><blockquote><p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night.</p><p>Determine the maximum amount of money the thief can rob tonight without alerting the police.</p><p>Example 1:</p></blockquote><pre><code> 3/ \</code></pre><p>   2   3<br>    \   <br>     3   1</p><blockquote><p>Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.<br>Example 2:</p></blockquote><pre><code> 3/ \</code></pre><p>   4   5<br>  / \   <br> 1   3   1</p><blockquote><p>Maximum amount of money the thief can rob = 4 + 5 = 9.</p></blockquote><p>之前有刷过<code>House robber</code>,上次是一道<code>dp</code>的题目，这次看起来有点像是<code>dp</code>的题目，但是其实不是。</p><p>我们考虑当前节点<code>root</code>,我们有两种选择：</p><ul><li>不偷<code>root</code>:这意味着我们对<code>root</code>的孩子没有限制（即可以偷也可以不偷）。</li><li>偷<code>root</code>：这意味着我们不能偷<code>root</code>的孩子。</li></ul><p>从上面的分析可以看出，对于一个节点，我们可能需要返回两个值，一个是偷了<code>root</code>所得到的<code>money</code>,一个是不偷<code>root</code>所得到的<code>money</code>.我们可以用一个结构体来表示:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> rob;</span><br><span class="line">    <span class="keyword">int</span> norob;</span><br><span class="line">&#125;Ret;</span><br></pre></td></tr></table></figure><p>假设我们现在得到了<code>root</code>左孩子和右孩子的<code>Ret</code>了，我们现在要构建<code>root</code>本身的<code>Ret</code>.显然<code>rob = left.norob + right.norob + root-&gt;val</code>.然后还有<code>norob</code>,这个很容易就写成<code>norob = left.rob + right.rob</code>,这样写就假定了<code>rob &gt; norob</code>的，在上面的分析中，我们是说我们对<code>root</code>的孩子没有限制，既然没有限制，就可以偷也可以不偷，所以<code>norob = max(left.rob,left.norob) + max(right.rob,right.norob)</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    Ret ret = robRec(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(ret.rob,ret.norob);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Ret <span class="title">robRec</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    Ret ret = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ret;</span><br><span class="line">    Ret left = robRec(root-&gt;left);</span><br><span class="line">    Ret right = robRec(root-&gt;right);</span><br><span class="line">    ret.rob = left.norob + right.norob + root-&gt;val;</span><br><span class="line">    ret.norob = <span class="built_in">max</span>(left.rob,left.norob) + <span class="built_in">max</span>(right.rob,right.norob);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dicuss</code>中的解法大都是这个思路，只是写法不同而已，有一个写法比较有趣：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.max(robInclude(root), robExclude(root));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">robInclude</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> robExclude(node.left) + robExclude(node.right) + node.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">robExclude</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> rob(node.left) + rob(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Merge Two Binary Trees</title>
      <link href="/2017/11/25/Merge-Two-Binary-Trees/"/>
      <url>/2017/11/25/Merge-Two-Binary-Trees/</url>
      
        <content type="html"><![CDATA[<p>第59天。</p><p>今天早上vpn挂了，然后好像学校IP有出现了点问题（貌似被人列入黑名单了）然后就一直出现<code>One more step</code>进行验证，最烦的是这个验证需要翻个墙，然后我就用手机开的wifi来写的题。</p><p>今天的题目是<a href="https://leetcode.com/problems/merge-two-binary-trees/description/" target="_blank" rel="noopener">Merge Two Binary Trees</a>:</p><blockquote><p>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.</p><p>You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.</p><p>Example 1:<br>Input: </p></blockquote><pre><code>Tree 1                     Tree 2      1                         2     / \                       / \    3   2                     1   3   /                           \   \  5                             4   7</code></pre><blockquote><p>Output:<br>Merged tree:</p></blockquote><pre><code>   3  / \ 4   5 / \   \5   4   7</code></pre><blockquote><p>Note: The merging process must start from the root nodes of both trees.</p></blockquote><p>挺简单的问题，对于两个<code>root</code>,大致可以分为4种情况：</p><ol><li>t1 = nullptr and t2 == nullptr: 直接返回nullptr</li><li>t1 == nullptr and t2 != nullptr:<ul><li>new 一个新的节点ret</li><li>ret-&gt;val = t2-&gt;val</li><li>ret-&gt;left = mergeTrees(t1,t2-&gt;left)</li><li>ret-&gt;right = mergeTree(t1,t2-&gt;right)</li></ul></li><li>t1 != nullptr and t2 == nullptr: 与上面类似</li><li>t1 != nullptr and t2 != nullptr:<ul><li>new 一个新的节点ret</li><li>ret-&gt;val = t1-&gt;val + t1-&gt;val</li><li>ret-&gt;left = mergeTrees(t1-&gt;left,t2-&gt;left)</li><li>ret-&gt;right = mergeTrees(t1-&gt;right,t2-&gt;right)</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t1 &amp;&amp; !t2) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode * ret = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">    ret-&gt;val = ((t2)?t2-&gt;val:<span class="number">0</span>) + ((t1)?t1-&gt;val:<span class="number">0</span>);</span><br><span class="line">    ret-&gt;left = mergeTrees((t1)?t1-&gt;left:t1</span><br><span class="line">                            ,(t2)?t2-&gt;left:t2);</span><br><span class="line">    ret-&gt;right = mergeTrees((t1)?t1-&gt;right:t1</span><br><span class="line">                            ,(t2)?t2-&gt;right:t2);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果可以不管使用t1和t2的空间的话，可以更简单一点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t1) <span class="keyword">return</span> t2;</span><br><span class="line">    <span class="keyword">if</span> (!t2) <span class="keyword">return</span> t1;</span><br><span class="line">    TreeNode *ret = <span class="keyword">new</span> TreeNode(t1-&gt;val + t2-&gt;val);</span><br><span class="line">    ret-&gt;left = mergeTrees(t1-&gt;left,t2-&gt;left);</span><br><span class="line">    ret-&gt;right = mergeTrees(t1-&gt;right,t2-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Diameter of Binary Tree</title>
      <link href="/2017/11/24/Diameter-of-Binary-Tree/"/>
      <url>/2017/11/24/Diameter-of-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<p>第58天。</p><p>今天的题目是<a href="https://leetcode.com/problems/diameter-of-binary-tree/description/" target="_blank" rel="noopener">Diameter of Binary Tree</a>:</p><blockquote><p>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.</p><p>Example:<br>Given a binary tree </p></blockquote><pre><code>    1   / \  2   3 / \4   5</code></pre><blockquote><p>Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].</p><p>Note: The length of path between two nodes is represented by the number of edges between them.</p></blockquote><p>很显然，题目已经给出提示了,这个path要么经过<code>root</code>要么不经过<code>root</code>.</p><p>如果经过<code>root</code>,那么就是左子树和右子树的高度之和加上2.<br>如果不经过<code>root</code>,就是左子树的<code>diameter</code>或者是右子树的<code>diameter</code>.</p><p>那么如何分辨是否经过<code>root</code>呢？</p><p>其实也很简单，反正就要求最大的嘛，我们就把两种情况都算一遍，然后求个<code>max</code>即可。大概可以写出一下递推式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leftH = heightOfHeight(root-&gt;left)</span><br><span class="line">rightH = heightOrHeight(root-&gt;right)</span><br><span class="line">d = diameterOfBinaryTree(root-&gt;left) + diameterOfBinaryTree(root-&gt;right)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(d,leftH+rightH+<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>然后我们发现求高度也是类似的需要递归的方式，所以我们可以将他们合并起来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> diameterOfBinaryTree(root,h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode *root,<span class="keyword">int</span> &amp;<span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">height</span> = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> leftH,rightH;</span><br><span class="line">    <span class="keyword">int</span> leftD = diameterOfBinaryTree(root-&gt;left,leftH);</span><br><span class="line">    <span class="keyword">int</span> rightD = diameterOfBinaryTree(root-&gt;right,rightH);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">height</span> = <span class="built_in">max</span>(leftH,rightH) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(leftH + rightH + <span class="number">2</span>,<span class="built_in">max</span>(leftD,rightD) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Counting Bits</title>
      <link href="/2017/11/23/Counting-Bits/"/>
      <url>/2017/11/23/Counting-Bits/</url>
      
        <content type="html"><![CDATA[<p>第57天。</p><p>今天的题目是<a href="https://leetcode.com/problems/counting-bits/description/" target="_blank" rel="noopener">Counting Bits</a>:</p><blockquote><p>Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array.</p><p>Example:<br>For num = 5 you should return [0,1,1,2,1,2].</p><p>Follow up:</p><p>It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?<br>Space complexity should be O(n).<br>Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.</p></blockquote><p>和昨天的题目有点联系。</p><p>我们知道要求一个数的二进制表示中<code>1</code>的个数大概需要<code>O(1)</code>的时间，但这里的<code>O(1)</code>其实是<code>O(sizeof(integer))</code>.这里的题目上要求直接用<code>O(n)</code>的算法，而不是<code>O(n*sizeof(int))</code>的算法，这说明我们不能用昨天的算法来对每个数进行求解，我们必须找到一个规律来快速的算出来。</p><p>尝试把0~16二进制表示中<code>1</code>的个数算出来：</p><blockquote><p>0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16<br>0 1 1 2 1 2 2 3 1 2 2  3  2  3  3  4  1</p></blockquote><p>可以观察到0-1的值和2-3的值刚好差1，4-7的值和0-4的值刚好差1，同样的8-16的值和0-7的值刚好差。</p><p>因此，我们可以写出一下递推式：</p><p><code>numCount[i] = numCount[i-k]</code> 其中<code>k</code>表示<code>i</code>只保留最高位的<code>1</code>时所代表的数。</p><p>比如说<code>i=20</code>时，20的二进制表示是<code>10100</code>,则<code>k</code>的二进制位<code>10000</code>,即<code>16</code>.</p><p>知道这个之后，我们就可以很容易的求解出来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(num+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= num;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == k&lt;&lt;<span class="number">1</span>) k&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        ret[i] = ret[i - k] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dicuss</code>中有一些更精妙的递推式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(num+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i)</span><br><span class="line">        ret[i] = ret[i&amp;(i<span class="number">-1</span>)] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hamming Distance</title>
      <link href="/2017/11/22/Hamming-Distance/"/>
      <url>/2017/11/22/Hamming-Distance/</url>
      
        <content type="html"><![CDATA[<p>第56天。</p><p>刷道水题<a href="https://leetcode.com/problems/hamming-distance/description/" target="_blank" rel="noopener">Hamming Distance</a>:</p><blockquote><p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.</p><p>Given two integers x and y, calculate the Hamming distance.</p><p>Note:<br>0 ≤ x, y &lt; 231.</p><p>Example:</p><p>Input: x = 1, y = 4</p><p>Output: 2</p><p>Explanation:<br>1   (0 0 0 1)<br>4   (0 1 0 0)<br>_     ↑   ↑<br>The above arrows point to positions where the corresponding bits are different.</p></blockquote><p>所谓的<code>humming distance</code>就是两个数在bit位上不同的个数，就<code>int</code>来说，最多就是全部不相同，也就是每个bit位都不一样，即<code>humming distance</code>.</p><p>我们可以利用异或来很快的求出来，异或可以让bit位不相同时置1，相同时置0.则两数异或后所得到的数中有bit位中1的个数就是<code>humming distance</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = x^y;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t!=<span class="number">0</span>) &#123;</span><br><span class="line">        ret += (t&amp;<span class="number">1</span>);</span><br><span class="line">        t &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Find the Duplicate Number</title>
      <link href="/2017/11/21/Find-the-Duplicate-Number/"/>
      <url>/2017/11/21/Find-the-Duplicate-Number/</url>
      
        <content type="html"><![CDATA[<p>第55天。</p><p>今天的题目是<a href="https://leetcode.com/problems/find-the-duplicate-number/description/" target="_blank" rel="noopener">Find the Duplicate Number</a>:</p><blockquote><p>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p><p>Note:<br>You must not modify the array (assume the array is read only).<br>You must use only constant, O(1) extra space.<br>Your runtime complexity should be less than O(n2).<br>There is only one duplicate number in the array, but it could be repeated more than once.</p></blockquote><p>一开始，没看到说要用<code>O(1)</code>的空间复杂度，就直接用计数的方法去写了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findDuplicate1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(nums.<span class="built_in">size</span>(),<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:nums) &#123;</span><br><span class="line">        count[i]++;</span><br><span class="line">        <span class="keyword">if</span> (count[i]&gt;<span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是后来想了很久，想着利用异或的方法去做，就是先将<code>nums</code>中的数字进行异或，然后在对<code>[1,n]</code>的数字进行异或，然后就直接是答案了，但是这种问题要限定在重复数字只重复一次的情况下，即需要保证<code>[1:n]</code>的数字都存在：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findDuplicate2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:nums) &#123;</span><br><span class="line">        t ^= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        t ^= i;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后。。。最后就实在想不出了，只好去看<code>dicuss</code>了：</p><p>他是用了一个<code>List Cycle</code>中找环点的方式，这里的链表中的<code>nxet</code>就是用nums的值来表示的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> slow = n;</span><br><span class="line">    <span class="keyword">int</span> fast = n;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        slow = nums[slow<span class="number">-1</span>];</span><br><span class="line">        fast = nums[nums[fast<span class="number">-1</span>]<span class="number">-1</span>];</span><br><span class="line">    &#125;<span class="keyword">while</span>(slow != fast);</span><br><span class="line">    slow = n;</span><br><span class="line">    <span class="keyword">while</span>(slow != fast) &#123;</span><br><span class="line">        slow = nums[slow - <span class="number">1</span>];</span><br><span class="line">        fast = nums[fast - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Perfect Squares</title>
      <link href="/2017/11/20/Perfect-Squares/"/>
      <url>/2017/11/20/Perfect-Squares/</url>
      
        <content type="html"><![CDATA[<p>第54天。</p><p>今天的题目是<a href="https://leetcode.com/problems/perfect-squares/description/" target="_blank" rel="noopener">Perfect-Squares</a>:</p><blockquote><p>Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, …) which sum to n.</p><p>For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.</p></blockquote><p>这道题一开始看到还挺懵的，首先，它是需要用<code>square number</code>来做加法的，那我是不是要先判断一个数是不是一个<code>square number</code>,简单的思路就是将所有不大于n的<code>square number</code>生成出来，直接比较即可，假设我们就是用这样的方法，那么现在我们可能就有了所有不大于n的<code>square number</code>的序列。</p><p>然后继续回到原来的问题，我好像是不需要求出这个表达式是由什么数组成的，而是只需要求出这个表达式由多少个<code>Square number</code>组成的就好了，这有点像动态规划的问题，我们用动态规划的思路去想这个问题：</p><p>我们要求<code>numSquares(n)</code>，我们可以先尝试的假定这个表达式中有一个<code>1</code>,那么就可以写成<code>numSquares(n) = numSquares(n-1)+1</code>,那如果我们假定这个表达式中有一个<code>4</code>,那么就可以写成是<code>numSquares(n) = numSquares(n-4)+1</code>,我们可以按照这样思路写出这样的递推式：</p><blockquote><p>numSquares(n) = Min{numSquares(n-k) + 1 | k is square number and k &lt;= n}</p></blockquote><p>这样的话，我们就可以写出这样的表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type n: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    dp = [sys.maxsize]*(n+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        j = <span class="number">1</span></span><br><span class="line">        t = j**<span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> t &lt;= i:</span><br><span class="line">            dp[i] = min(dp[i],dp[i-t]+<span class="number">1</span>)</span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">            t = j**<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>很不幸，这样的方法会在6000之后的数据中超时，然后想了一早上的方式去优化，后来用<code>c++</code>去实现了一遍，然后。。。就过来，花了那么久的时间竟然因为语言的问题而一直解决不了。。。算了，以后还是用<code>c++</code>写吧，反正有时候用<code>python</code>,写的也很乱，还不如<code>c++</code>简洁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,INT_MAX)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;(t = j*j) &lt;= i;j++)&#123;</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i],dp[i-t]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; dp[i] &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>House Robber</title>
      <link href="/2017/11/19/House-Robber/"/>
      <url>/2017/11/19/House-Robber/</url>
      
        <content type="html"><![CDATA[<p>第53天。</p><p>今天的题目是<a href="https://leetcode.com/problems/house-robber/description/" target="_blank" rel="noopener">House Robber</a>:</p><blockquote><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p><p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p></blockquote><p>题目很长，大概的意思是给你一组非负数，代表每个房间中有的金额，你可以去任意一个房间取钱，但是不能在两个相邻的房间取，求出能取出的最大金额。</p><p>一开始想的很简单，直接在单数号的房间取或者在双数号的房间取，这样的话，我就取了最多次，只要遍历求个和即可，然而这样会有一个问题，例如序列是这样的<code>[2,1,1,2]</code>,这样的话，应该是取第一个房间和最后一个房间才对。</p><p>突然觉得好像很难求出来才是，因为可能性太多了，而且也不好构造这种可能性，突然想到这会不会是一道<code>dp</code>的题目，然后用<code>dp</code>的思路去想。</p><p>如果有k个房间可以取钱，那么是不是对于第k个房间就只有两种可能，即取或不取：</p><ul><li>取，那么k-1我们就不能取了，我们只能取k-2个房间的钱，问题转换成求前k-2个房间能取多少</li><li>不取，那么问题变成了求前k-1个房间能不能取。</li></ul><p>我们可以得到以下递推式：</p><blockquote><p>rob(nums,k) = max(rob(num,k-1),rob(nums,k-2) + nums[k])</p></blockquote><p>这样我们就可以很轻松的写出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob1</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    dp = [<span class="number">0</span>]*(len(nums)+<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        dp[i+<span class="number">2</span>] = max(dp[i+<span class="number">1</span>],dp[i]+nums[i])</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>很显然我们可以将空间复杂度从<code>O(n)</code>降到<code>O(1)</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob2</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment">#dp = [0]*(len(nums)+2)</span></span><br><span class="line">    dp1,dp2,dp3 = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        dp3 = max(dp2,dp1+i)</span><br><span class="line">        dp1,dp2 = dp2,dp3</span><br><span class="line">    <span class="keyword">return</span> dp3</span><br></pre></td></tr></table></figure><p>我们还可以在减少一点，但是时间复杂度还是<code>O(1)</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment">#dp = [0]*(len(nums)+2)</span></span><br><span class="line">    dp1,dp2 = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        dp1,dp2 = dp2,max(dp2,dp1+i)</span><br><span class="line">    <span class="keyword">return</span> dp2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Course-Schedule</title>
      <link href="/2017/11/18/Course-Schedule/"/>
      <url>/2017/11/18/Course-Schedule/</url>
      
        <content type="html"><![CDATA[<p>第52天。</p><hr><p>昨晚去见了一下一起做东西的研究生师兄师姐们，感觉很<code>nice</code>,不嫌弃我什么都不会还教了我很多东西，恩，等下开始学机器学习的东西。</p><hr><p>今天的题目是<a href="https://leetcode.com/problems/course-schedule/description/" target="_blank" rel="noopener">Course Schedule</a>:</p><blockquote><p>There are a total of n courses you have to take, labeled from 0 to n - 1.</p><p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p><p>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p><p>For example:</p><p>2, [[1,0]]<br>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.</p><p>2, [[1,0],[0,1]]<br>There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.<br>Note:<br>The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.<br>You may assume that there are no duplicate edges in the input prerequisites.</p></blockquote><p>这个问题可以转化成——有向图是否有环路。</p><p>这里是使用<a href="https://zh.wikipedia.org/zh-hans/%E6%8B%93%E6%92%B2%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">拓扑排序</a>做的.<br>拓扑排序是只能在有向无环图中进行排序，如果它有环，那么它进会出错，我们对这个图进行一次拓扑排序就可以知道这个图是不是有环了。</p><p>一开始是使用维护一个入度的数组，然后通过不断删除入度为0点的方式来完成拓扑排序的，但是超时了，所以这里用<code>DFS</code>的方法来实现，而且这种方法还比之前的要简单。</p><p>原本的<code>DFS</code>需要一个<code>visited</code>，来表示某个节点是否被访问了，这里扩展一下<code>visited</code>，原本的<code>visited</code>只有两个状态：被访问了，未被访问。<br>这里加入一个新的状态<code>访问中</code>,这里用<code>-1</code>来表示。</p><p>之所以要加入这个状态，是因为我们需要判断这个图是否有环路。让我们看个例子。</p><p><img src="http://olrv1mriz.bkt.clouddn.com/blog/171118/m8Ege7CeCj.png?imageslim" alt="mark"></p><p>我们尝试着对这个图进行一次<code>DFS</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line">3-&gt;8-&gt;9-&gt;10</span><br><span class="line">5-&gt;11</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><p>从上面我们可以知道这个图，需要四次调用<code>DFS</code>的递归函数才能完成整个遍历，我们认为如果某个节点在某次递归中，那么它的状态就是<code>访问中</code>,也就是说在第二次调用<code>DFS</code>的递归函数时如果访问了<code>3,8</code>节点，准备访问<code>9</code>节点时，<code>3</code>,<code>8</code>就是被访问状态，一旦访问完所以节点（也就是访问完<code>10</code>,这是在这条链路中所以节点都被访问了，递归函数开始返回，然后我们可以依次把<code>10</code>,<code>9</code>,<code>8</code>,<code>3</code>的设为<code>已访问</code>的状态。</p><p>讲了那么多，如果定义<code>访问中</code>状态，好像还没有提到他的用处，还是刚才的例子，如果上图加上一个<code>9-&gt;3</code>的边，那么我们是不是在访问<code>9</code>时，发现他可以通向一个<code>访问中</code>的节点（即<code>3</code>节点)，这时说明他们之间必定有回路。</p><p>大概的思路就是这样吧，其实看代码会简单一点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self,v,visited,graph)</span>:</span></span><br><span class="line">    visited[v] = <span class="number">-1</span> <span class="comment">#设置为访问中</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> graph[v]:</span><br><span class="line">        <span class="keyword">if</span> visited[i] == <span class="number">-1</span>: <span class="comment">#访问中</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> visited[i] == <span class="number">0</span>: <span class="comment">#未访问</span></span><br><span class="line">            <span class="keyword">if</span> self.helper(i,visited,graph) == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    visited[v] = <span class="number">1</span> <span class="comment"># 递归函数开始返回了，设置为已访问的状态</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canFinish</span><span class="params">(self, numCourses, prerequisites)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type numCourses: int</span></span><br><span class="line"><span class="string">    :type prerequisites: List[List[int]]</span></span><br><span class="line"><span class="string">    :rtype: bool</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    visited = [<span class="number">0</span>]*numCourses <span class="comment">#初始时，所有节点都未访问</span></span><br><span class="line">    <span class="comment">#将边集转化成邻接表</span></span><br><span class="line">    graph = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(numCourses)] </span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> prerequisites:</span><br><span class="line">        graph[e[<span class="number">0</span>]].append(e[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">#DFS</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numCourses):</span><br><span class="line">        <span class="keyword">if</span> visited[i] == <span class="literal">False</span>:</span><br><span class="line">            <span class="keyword">if</span> self.helper(i,visited,graph) == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><code>dicuss</code>中的<code>BFS</code>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; graph = make_graph(numCourses, prerequisites);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; degrees = compute_indegree(graph);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; numCourses; j++)</span><br><span class="line">                <span class="keyword">if</span> (!degrees[j]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (j == numCourses) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            degrees[j] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> neigh : graph[j])</span><br><span class="line">                degrees[neigh]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">make_graph</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">graph</span><span class="params">(numCourses)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> pre : prerequisites)</span><br><span class="line">            graph[pre.second].insert(pre.first);</span><br><span class="line">        <span class="keyword">return</span> graph;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">compute_indegree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">degrees</span><span class="params">(graph.<span class="built_in">size</span>(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> neighbors : graph)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> neigh : neighbors)</span><br><span class="line">                degrees[neigh]++;</span><br><span class="line">        <span class="keyword">return</span> degrees;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>好像就是我一开始做的那种想法，但是为什么我的又没通过。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Implement Trie(Prefix Tree)</title>
      <link href="/2017/11/17/Implement-Trie-Prefix-Tree/"/>
      <url>/2017/11/17/Implement-Trie-Prefix-Tree/</url>
      
        <content type="html"><![CDATA[<p>第51天。</p><p>今天的题目是<a href="https://leetcode.com/problems/implement-trie-prefix-tree/description/" target="_blank" rel="noopener">Implement Trie (Prefix Tree)</a>:</p><blockquote><p>Implement a trie with insert, search, and startsWith methods.</p><p>Note:<br>You may assume that all inputs are consist of lowercase letters a-z.</p></blockquote><p><a href="https://zh.wikipedia.org/wiki/Trie" target="_blank" rel="noopener">Tire</a>也就是前缀树，也叫字典树。</p><p>它大概是是这样子的：</p><ul><li>除了root节点以外，每个节点都有一个字符。</li><li>从根节点到<strong>某个节点（可以不是叶子节点）</strong>的一条路径表示一个字符串。</li><li>对于某个节点其孩子节点的字符不唯一</li></ul><p><img src="http://olrv1mriz.bkt.clouddn.com/blog/171117/Dgeh3dCJeB.png?imageslim" alt="mark"></p><p>从上图可以看出每个节点都可以唯一对应一个字符串，即使每个节点只存放一个字符，但是<code>root</code>节点到这个节点的路径可以唯一确定一个字符串。</p><p>既然说它是前缀树，那肯定和前缀有关啦。两个节点所代表的字符串用公共前缀，那么<code>root</code>节点到他们的路径肯定有公共路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            Initialize the TireNode.</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            self.child = &#123;&#125;</span><br><span class="line">            self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.root = TrieNode()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, word)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Inserts a word into the trie.</span></span><br><span class="line"><span class="string">        :type word: str</span></span><br><span class="line"><span class="string">        :rtype: void</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        p = self.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            q = p.child.get(c,<span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">if</span> q <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                p.child[c] = TrieNode()</span><br><span class="line">                q = p.child[c]</span><br><span class="line">            p = q</span><br><span class="line">        p.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, word)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns if the word is in the trie.</span></span><br><span class="line"><span class="string">        :type word: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        p = self.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:   </span><br><span class="line">            q = p.child.get(c,<span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">if</span> q <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            p = q</span><br><span class="line">        <span class="keyword">return</span> p.count &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span><span class="params">(self, prefix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns if there is any word in the trie that starts with the given prefix.</span></span><br><span class="line"><span class="string">        :type prefix: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        p = self.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> prefix:</span><br><span class="line">            q = p.child.get(c,<span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">if</span> q <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            p = q</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = Trie()</span></span><br><span class="line"><span class="comment"># obj.insert(word)</span></span><br><span class="line"><span class="comment"># param_2 = obj.search(word)</span></span><br><span class="line"><span class="comment"># param_3 = obj.startsWith(prefix)</span></span><br></pre></td></tr></table></figure><p>因为<code>python</code>中有一些好用的数据结构，比如说<code>dict</code>，所以实现起来并不难。</p><p>贴一个<code>dicuss</code>中的<code>c++</code>解法吧，因为他这里限定了字符只是26个，所以写起来也挺方便的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode *next[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">bool</span> is_word;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize your data structure here.</span></span><br><span class="line">    TrieNode(<span class="keyword">bool</span> b = <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(next, <span class="number">0</span>, <span class="keyword">sizeof</span>(next));</span><br><span class="line">        is_word = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TrieNode *root;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Trie()</span><br><span class="line">    &#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inserts a word into the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TrieNode *p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p -&gt; next[s[i] - <span class="string">'a'</span>] == <span class="literal">NULL</span>)</span><br><span class="line">                p -&gt; next[s[i] - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            p = p -&gt; next[s[i] - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        p -&gt; is_word = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if the word is in the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TrieNode *p = <span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">return</span> p != <span class="literal">NULL</span> &amp;&amp; p -&gt; is_word;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if there is any word in the trie</span></span><br><span class="line">    <span class="comment">// that starts with the given prefix.</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(prefix) != <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TrieNode* <span class="title">find</span><span class="params">(<span class="built_in">string</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TrieNode *p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; key.<span class="built_in">size</span>() &amp;&amp; p != <span class="literal">NULL</span>; ++ i)</span><br><span class="line">            p = p -&gt; next[key[i] - <span class="string">'a'</span>];</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maximal-Square</title>
      <link href="/2017/11/16/Maximal-Square/"/>
      <url>/2017/11/16/Maximal-Square/</url>
      
        <content type="html"><![CDATA[<p>第50天。</p><p>恍恍惚惚，就50天了。</p><p>今天的题目是<a href="https://leetcode.com/problems/maximal-square/description/" target="_blank" rel="noopener">Maximal Square</a>:</p><blockquote><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.</p><p>For example, given the following matrix:</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>Return 4.</p></blockquote><p>让人很意外，这是一道动态规划的题目。</p><p>先说说我的非动态规划的解法：</p><p>大概的想法是，做一次遍历，每次遇到<code>1</code>,就向下拓展，如果扩展，扩展的方法是就是只需要看当前正方形的外围是否都是<code>1</code>，如果都是<code>1</code>,那么我们就可以继续向下扩展，这样就可以遍历出一个正方形，然后我们在对<code>matrix</code>进行遍历的时候还可以通过当前的最大面积来提早结束遍历：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expend</span><span class="params">(self,matrix,i,j,ret)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type matrix: List[List[str]]</span></span><br><span class="line"><span class="string">    :type i: int</span></span><br><span class="line"><span class="string">    :type j: int</span></span><br><span class="line"><span class="string">    :type ret: int</span></span><br><span class="line"><span class="string">    :rtype ret</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> i &gt;= len(matrix) <span class="keyword">or</span> j &gt;= len(matrix[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(ret+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> matrix[i][j - k] == <span class="string">'0'</span> <span class="keyword">or</span> matrix[i-k][j] == <span class="string">'0'</span>:</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> self.expend(matrix,i+<span class="number">1</span>,j+<span class="number">1</span>,ret+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximalSquare1</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type matrix: List[List[str]]</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    ret,i = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i + ret &lt; len(matrix):</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> j + ret &lt; len(matrix[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == <span class="string">'1'</span>:</span><br><span class="line">                ret = max(ret,self.expend(matrix,i+<span class="number">1</span>,j+<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ret*ret</span><br></pre></td></tr></table></figure><p>挺暴力的方法，不知道是不是因为可以提前结束，所以这个方法也直接AC了。</p><p>然后是<code>DP</code>的解法。</p><p>在解决这个问题之前，我们先考虑如果求出以<code>matrix[i][j]</code>为右下角的正方形最大面积。</p><p>如果<code>matrix[i][j] = &#39;0&#39;</code>,那么显然<code>size[i][j] = 0</code><br>如果<code>matrix[i][j] = &#39;1&#39;</code>,那么我们需要考虑其向上，向左，向左上的最大面积。</p><p>假设<code>size[i-1][j-1] = 2</code>,则我们至少可以知道：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,*]</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,*]</span><br><span class="line">    [*,*,-]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>如果<code>size[i][j-1] = 2</code>,我们至少知道：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    [*,*,*]</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,*]</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,-]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>如果<code>size[i-1][j] = 2</code>,我们至少知道：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    [*,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">    [*,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">    [*,*,-]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>从上面可以看出来，只有当<code>size[i-1][j-1] == 2 and size[i][j-1] == 2 and size[i-1][j-1] == 2</code>时，<code>size[i][j] == 3</code>,</p><p>则我们可以得出以下递推式：</p><p><code>size[i][j] = min(size[i-1][j-1],size[i][j-1],size[i-1][j])+1 if matrix[i][j] == &#39;1&#39;</code><br><code>size[i][j] = 0 if matrix[i][j] == &#39;0&#39;</code></p><p>然后我们还需要考虑一下边界条件，因为当<code>i=0</code>或<code>j=0</code>时，上面的递推式是没有考虑到的，我们再加上：</p><p><code>size[i][j] = (matrix[i][j] == &#39;1&#39;) where i == 0 or j == 0</code></p><p>然后我们就可以写出以下解法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span><span class="params">(self,matrix)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(matrix) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp1 = []</span><br><span class="line">    ret = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">        t = int(matrix[<span class="number">0</span>][i] == <span class="string">'1'</span>)</span><br><span class="line">        dp1.append(t)</span><br><span class="line">        ret = max(ret,t)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(matrix)):</span><br><span class="line">        dp2 = [ <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])) ]</span><br><span class="line">        dp2[<span class="number">0</span>] = int(matrix[i][<span class="number">0</span>] == <span class="string">'1'</span>)</span><br><span class="line">        ret = max(dp2[<span class="number">0</span>],ret)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,len(matrix[<span class="number">0</span>])):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == <span class="string">'1'</span>:</span><br><span class="line">                dp2[j] = min(min(dp1[j<span class="number">-1</span>],dp1[j]),dp2[j<span class="number">-1</span>]) + <span class="number">1</span></span><br><span class="line">            ret = max(ret,dp2[j])</span><br><span class="line">        dp1 = dp2</span><br><span class="line">    <span class="keyword">return</span> ret*ret</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Best Time to Buy and Sell Stock</title>
      <link href="/2017/11/15/Best-Time-to-Buy-and-Sell-Stock/"/>
      <url>/2017/11/15/Best-Time-to-Buy-and-Sell-Stock/</url>
      
        <content type="html"><![CDATA[<p>第49天。</p><p>今天的题目是<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock</a>:</p><blockquote><p>Say you have an array for which the ith element is the price of a given stock on day i.</p><p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p><p>Example 1:<br>Input: [7, 1, 5, 3, 6, 4]<br>Output: 5</p><p>max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)<br>Example 2:<br>Input: [7, 6, 4, 3, 1]<br>Output: 0</p><p>In this case, no transaction is done, i.e. max profit = 0.</p></blockquote><p>之前好像做过一道类似的题目，但是那道题比这道题难多了，那道题是可以多次买入卖出的，而成每次交易是需要支付一定费用的，这道就简单多了，我们只需要记录当前最小元素，然后每次更新最小元素，然后记录当前元素与最小元素的差值即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type prices: List[int]</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    profit,minElem = <span class="number">0</span>,sys.maxsize</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">        <span class="keyword">if</span> p &lt; minElem:</span><br><span class="line">            minElem = p</span><br><span class="line">        t = p - minElem</span><br><span class="line">        <span class="keyword">if</span> t &gt; profit:</span><br><span class="line">            profit = t</span><br><span class="line">    <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure><p>然后是<code>c++</code>的解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxPro = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> minPrice = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        minPrice = <span class="built_in">min</span>(minPrice, prices[i]);</span><br><span class="line">        maxPro = <span class="built_in">max</span>(maxPro, prices[i] - minPrice);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxPro;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及在<code>dicuss</code>中看到的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxCur = <span class="number">0</span>, maxSoFar = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        maxCur = Math.max(<span class="number">0</span>, maxCur += prices[i] - prices[i-<span class="number">1</span>]);</span><br><span class="line">        maxSoFar = Math.max(maxCur, maxSoFar);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSoFar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Symmetric Tree</title>
      <link href="/2017/11/14/Symmetric-Tree/"/>
      <url>/2017/11/14/Symmetric-Tree/</url>
      
        <content type="html"><![CDATA[<p>第48天。</p><p>今天的题目是<a href="https://leetcode.com/problems/symmetric-tree/description/" target="_blank" rel="noopener">Symmetric Tree</a>:</p><blockquote><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p><p>For example, this binary tree [1,2,2,3,4,4,3] is symmetric:</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> / \ / \</span><br><span class="line"><span class="number">3</span>  <span class="number">4</span> <span class="number">4</span>  <span class="number">3</span></span><br></pre></td></tr></table></figure><blockquote><p>But the following [1,2,2,null,3,null,3] is not:</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> \   \</span><br><span class="line"> <span class="number">3</span>    <span class="number">3</span></span><br></pre></td></tr></table></figure><p>刚看的时候还有点懵，要怎么递归的去求解这种问题呢，要比较的两个节点隔得有点远啊。后来是上课时突然想到对称其实和根节点的左子树和右子树有关，我们把他当成两个树来求解就好了，递归时需要两个<code>TreeNode</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSymmetric1</span><span class="params">(self, root)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type root: TreeNode</span></span><br><span class="line"><span class="string">    :rtype: bool</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> self.isSymmetricRec(root.left,root.right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSymmetricRec</span><span class="params">(self,left,right)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type left: TreeNode</span></span><br><span class="line"><span class="string">    :type right: TreeNode</span></span><br><span class="line"><span class="string">    :rtype: bool</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> left.val == right.val \</span><br><span class="line">                <span class="keyword">and</span> self.isSymmetricRec(left.left,right.right) \</span><br><span class="line">                <span class="keyword">and</span> self.isSymmetricRec(left.right,right.left)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>然后是迭代解，这里是用层次遍历去做的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSymmetricBFS</span><span class="params">(self,root)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type root:TreeNode</span></span><br><span class="line"><span class="string">    :rtype: bool</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    leftqueue = Queue()</span><br><span class="line">    rightqueue = Queue()</span><br><span class="line"></span><br><span class="line">    leftqueue.put(root.left)</span><br><span class="line">    rightqueue.put(root.right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> leftqueue.empty():</span><br><span class="line">        left = leftqueue.get()</span><br><span class="line">        right = rightqueue.get()</span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> left.val != right.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            leftqueue.put(left.left)</span><br><span class="line">            leftqueue.put(left.right)</span><br><span class="line">            rightqueue.put(right.right)</span><br><span class="line">            rightqueue.put(right.left)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>然后是在<code>dicuss</code>中看到的<code>c++</code>解法，思路其实是一样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> helper(root-&gt;left, root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p &amp;&amp; !q) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!p || !q) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;val != q-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> helper(p-&gt;left,q-&gt;right) &amp;&amp; helper(p-&gt;right, q-&gt;left); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    TreeNode *left, *right;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q1, q2;</span><br><span class="line">    q1.push(root-&gt;left);</span><br><span class="line">    q2.push(root-&gt;right);</span><br><span class="line">    <span class="keyword">while</span> (!q1.empty() &amp;&amp; !q2.empty())&#123;</span><br><span class="line">        left = q1.front();</span><br><span class="line">        q1.pop();</span><br><span class="line">        right = q2.front();</span><br><span class="line">        q2.pop();</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == left &amp;&amp; <span class="literal">NULL</span> == right)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == left || <span class="literal">NULL</span> == right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (left-&gt;val != right-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        q1.push(left-&gt;left);</span><br><span class="line">        q1.push(left-&gt;right);</span><br><span class="line">        q2.push(right-&gt;right);</span><br><span class="line">        q2.push(right-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Balanced Binary Tree</title>
      <link href="/2017/11/13/Balanced-Binary-Tree/"/>
      <url>/2017/11/13/Balanced-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<p>第47天。</p><p>今天的题目是<a href="https://leetcode.com/problems/balanced-binary-tree/description/" target="_blank" rel="noopener">Balanced Binary Tree</a>:</p><blockquote><p>Given a binary tree, determine if it is height-balanced.</p><p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p></blockquote><p>题目意思是对这个树的每个结点来说它左子树和右子树的高度差都不大于1,我们可以把它转换成一个求高度的问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> isBalanced(root,h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode *root,<span class="keyword">int</span> &amp;<span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123; <span class="built_in">height</span> = <span class="number">0</span>; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> left,right;</span><br><span class="line">    <span class="keyword">if</span> (!isBalanced(root-&gt;left,left) || !isBalanced(root-&gt;right,right))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(left - right) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">height</span> = <span class="built_in">max</span>(left,right) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>准备把主力语言往<code>python</code>和<code>c</code>上靠，所以以后都会写多一个<code>python</code>的解法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res,height = self.isBalancedRec(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalancedRec</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool,int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">        leftRes,leftH = self.isBalancedRec(root.left)</span><br><span class="line">        rightRes,rightH = self.isBalancedRec(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> leftRes == <span class="literal">False</span> <span class="keyword">or</span> rightRes == <span class="literal">False</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>,max(leftH,rightH)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> abs(leftH-rightH) &lt;= <span class="number">1</span>,max(leftH,rightH)+<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Climbing Stairs</title>
      <link href="/2017/11/12/Climbing-Stairs/"/>
      <url>/2017/11/12/Climbing-Stairs/</url>
      
        <content type="html"><![CDATA[<p>第46天。</p><p>今天的题目是<a href="https://leetcode.com/problems/climbing-stairs/description/" target="_blank" rel="noopener">Climbing Stairs</a>:</p><blockquote><p>You are climbing a stair case. It takes n steps to reach to the top.</p><p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p><p>Note: Given n will be a positive integer.</p><p>Example 1:</p><p>Input: 2<br>Output:  2<br>Explanation:  There are two ways to climb to the top.</p><ol><li>1 step + 1 step</li><li>2 steps<br>Example 2:</li></ol><p>Input: 3<br>Output:  3<br>Explanation:  There are three ways to climb to the top.</p><ol><li>1 step + 1 step + 1 step</li><li>1 step + 2 steps</li><li>2 steps + 1 step</li></ol></blockquote><p>首先，要到达第n个台阶，我们需要先到n-1或n-2台阶，只要到达n-1和n-2台阶处，我们就能够通过一步到达第n个台阶，这时可以写出这样的递推式:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">climbStairs(n) = climbStairs(n<span class="number">-1</span>) + climbStairs(n<span class="number">-2</span>);</span><br><span class="line">climbStairs(<span class="number">0</span>) = climbStairs(<span class="number">1</span>) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>熟悉的话，可以一眼看出这是斐波那契数列.</p><p>这样的话，我们可以很容易写出:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> climbStairs(n<span class="number">-1</span>) + climbStairs(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样会出现超时的情况，我们可以用一个数组来记录整个斐波那契数列，然后返回适当的值即可:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(n+<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        vec[i] = vec[i<span class="number">-1</span>] + vec[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的时间复杂度和空间复杂度都是<code>O(n)</code>.</p><p>我们可以把空间复杂度降到<code>O(1)</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>,b = <span class="number">1</span>,t;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        t = a+b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linked-List-Cycle</title>
      <link href="/2017/11/12/Linked-List-Cycle-1/"/>
      <url>/2017/11/12/Linked-List-Cycle-1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Maximum Depth of Binary Tree</title>
      <link href="/2017/11/11/Maximun-Depth-of-Binary-Tree/"/>
      <url>/2017/11/11/Maximun-Depth-of-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<p>第46天。</p><p>今天出游，挑到水题<a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/discuss/" target="_blank" rel="noopener">Maximum Depth of Binary Tree</a>:</p><blockquote><p>Given a binary tree, find its maximum depth.</p><p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p></blockquote><p>说是水题，就不讲怎么做了，直接上代码吧:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxDepth(root,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode *root,<span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> depth;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(maxDepth(root-&gt;left,depth+<span class="number">1</span>),maxDepth(root-&gt;right,depth+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>恩，突然发现好像没必要写的那么长:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(maxDepth(root-&gt;left),maxDepth(root-&gt;right))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>恩，送上一个<code>dicuss</code>中BFS的解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        ++ res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, n = q.<span class="built_in">size</span>(); i &lt; n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *p = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(p -&gt; left != <span class="literal">NULL</span>)</span><br><span class="line">                q.push(p -&gt; left);</span><br><span class="line">            <span class="keyword">if</span>(p -&gt; right != <span class="literal">NULL</span>)</span><br><span class="line">                q.push(p -&gt; right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Majority Element</title>
      <link href="/2017/11/10/Majority-Element/"/>
      <url>/2017/11/10/Majority-Element/</url>
      
        <content type="html"><![CDATA[<p>第45天。</p><p>今天的题目是<a href="https://leetcode.com/problems/majority-element/discuss/" target="_blank" rel="noopener">Majority Element</a>:</p><blockquote><p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p><p>You may assume that the array is non-empty and the majority element always exist in the array.</p></blockquote><p>最简单的想法就是，遍历一遍序列，记录出现的次数，然后在遍历一遍刚才记录的次数，如果大于<code>k</code>就直接返回，这种时候一般会用到<code>hash table</code>，在<code>c++</code>中就是<code>unordered_map</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> k = <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:nums) <span class="built_in">map</span>[i]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p:<span class="built_in">map</span>) <span class="keyword">if</span> (p.second &gt; k) <span class="keyword">return</span> p.first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法的时间复杂度是<code>O(n)</code>,空间复杂度也是<code>O(n)</code>.</p><p>虽然很简单，但是这道题目在<code>dicuss</code>中也有很多有趣的解法:</p><ul><li>因为<code>Majority Element</code>在序列中存在<code>n/2</code>个，所以假如这个序列时有序的话，他一定会出现在中间:</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    nth_element(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + nums.<span class="built_in">size</span>() / <span class="number">2</span>, nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> nums[nums.<span class="built_in">size</span>() / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很<code>nice</code>的学到了一个新的函数。</p><ul><li>同样是因为出现了<code>k/2</code>次，所以我们如果随机选取一个元素的话，有一半的概率可以直接选到<code>Majority Element</code>:</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    srand(<span class="keyword">unsigned</span>(time(<span class="literal">NULL</span>)));</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> idx = rand() % n;</span><br><span class="line">        <span class="keyword">int</span> candidate = nums[idx];</span><br><span class="line">        <span class="keyword">int</span> counts = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == candidate)</span><br><span class="line">                counts++;</span><br><span class="line">        <span class="keyword">if</span> (counts &gt; n / <span class="number">2</span>) <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Moore Voting Algorithm</code>，这个方法的正确性我也不是很确定:</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> major, counts = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!counts) &#123;</span><br><span class="line">            major = nums[i];</span><br><span class="line">            counts = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> counts += (nums[i] == major) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> major;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Move-Zeroes</title>
      <link href="/2017/11/09/Move-Zeroes/"/>
      <url>/2017/11/09/Move-Zeroes/</url>
      
        <content type="html"><![CDATA[<p>第44天。</p><p>今天的题目是<a href="https://leetcode.com/problems/move-zeroes/description/" target="_blank" rel="noopener">Move Zeroes</a>:</p><blockquote><p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p><p>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].</p><p>Note:<br>You must do this in-place without making a copy of the array.<br>Minimize the total number of operations.</p></blockquote><p>这道题目要求我们原地的移动元素，而且还要保持序列本身的顺序。</p><p>我们可以利用一下计数排序的思想，反正最后都是<code>0</code>,我只要算出有几个<code>0</code>要放在最后，我就可以很方便的产生后缀啦，所以这里先遍历一遍序列记录<code>0</code>的个数，然后我们发现其实每个元素向前移动多少格是和它前面有多少个<code>0</code>有关的,so ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> zero = <span class="number">0</span>,<span class="built_in">size</span> = nums.<span class="built_in">size</span>(),i,j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="built_in">size</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) zero++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (zero != <span class="number">0</span>) nums[i-zero] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    j = <span class="built_in">size</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">size</span> -= zero;</span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="built_in">size</span>) nums[j--] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然写的不是很优雅的样子，但是这个思路是正确的，还有<code>dicuss</code>中的解法也是这个思路。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// move all the nonzero elements advance</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            nums[j++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">        nums[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Product of Array Except Self</title>
      <link href="/2017/11/08/Product-of-Array-Except-Self/"/>
      <url>/2017/11/08/Product-of-Array-Except-Self/</url>
      
        <content type="html"><![CDATA[<p>第43天。</p><p>今天的题目是<a href="https://leetcode.com/problems/product-of-array-except-self/description/" target="_blank" rel="noopener">Product of Array Except Self</a>:</p><blockquote><p>Given an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].</p><p>Solve it without division and in O(n).</p><p>For example, given [1,2,3,4], return [24,12,8,6].</p><p>Follow up:<br>Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.)</p></blockquote><p>这里说不能使用除法，我的想法就是自己实现一个除法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Div</span><span class="params">(<span class="keyword">unsigned</span>  a,<span class="keyword">unsigned</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a &gt;= b) &#123;</span><br><span class="line">        x = b;</span><br><span class="line">        y = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>( a &gt;= (x&lt;&lt;<span class="number">1</span>)) &#123;</span><br><span class="line">            x &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            y &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a -= x;</span><br><span class="line">        ans += y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">0</span> &amp;&amp; b &gt; <span class="number">0</span>) <span class="keyword">return</span> Div(a,b);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a &lt; <span class="number">0</span> &amp;&amp; b &lt; <span class="number">0</span>) <span class="keyword">return</span> Div(-a,-b);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a &lt; <span class="number">0</span>) <span class="keyword">return</span> -Div(-a,b);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> -Div(a,-b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后剩下的东西就是将<code>0</code>这个特例排除掉了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(nums.<span class="built_in">size</span>(),<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> product = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> zero_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:nums)</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) product*=i;</span><br><span class="line">        <span class="keyword">else</span> zero_count++;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; zero_count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zero_count &gt; <span class="number">1</span>) <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zero_count == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) ret[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> ret[i] = product;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ret.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">    <span class="comment">//    if (nums[i] == 0) ret[i] = product[i];</span></span><br><span class="line">        ret[i] = div((<span class="keyword">int</span>)product,nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是看了<code>dicuss</code>的做法，我感觉的理解是错的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        p = <span class="number">1</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        output = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">            output.append(p)</span><br><span class="line">            p = p * nums[i]</span><br><span class="line">        p = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            output[i] = output[i] * p</span><br><span class="line">            p = p * nums[i]</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><p>恩，今天写的有点急，因为我周五安全导论还要考试，然而我还一堆东西不会。。。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lowest Common Ancestor of a Binary Tree</title>
      <link href="/2017/11/07/Lowest-Common-Ancestor-of-a-Binary-Tree/"/>
      <url>/2017/11/07/Lowest-Common-Ancestor-of-a-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<p>第42天。</p><p>今天的题目是<a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/" target="_blank" rel="noopener">Lowest Common Ancestor of a Binary Tree</a>:</p><blockquote><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p><p>According to <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="noopener">the definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _______3______</span><br><span class="line">    /              \</span><br><span class="line"> ___5__          ___1__</span><br><span class="line">/      \        /      \</span><br><span class="line"><span class="number">6</span>      _2       <span class="number">0</span>       <span class="number">8</span></span><br><span class="line">      /  \</span><br><span class="line">      <span class="number">7</span>   <span class="number">4</span></span><br></pre></td></tr></table></figure><blockquote><p>For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</p></blockquote><p>额，怎么说呢。好久没有在上课前就AC掉了呢。</p><p>恩，题目的意思是，找最近的公共祖先。</p><p>考虑根节点，如果不考虑特殊的情况（比如说只用一个节点或干脆就没有节点），那么如果我们对其左子树和右子树递归的调用<code>lowestCommonAncestor</code>，那么其返回值就有以下几种情况:</p><ul><li><code>left</code>和<code>right</code>都非空，那么说明<code>root</code>节点就是<code>lowestCommonAncestor</code>，那我们就返回<code>root</code></li><li>只有<code>left</code>非空，那么说明<code>lowestCommonAncestor</code>在左子树中,那么我们就返回<code>left</code></li><li>只有<code>right</code>非空，与上面类似，我们就直接返回<code>right</code></li><li>两个都是空，说明<code>p</code>和<code>q</code>都不在这棵子树中，那其<code>lowestCommonAncestor</code>就是<code>nullptr</code>.</li></ul><p>然后我们再考虑一下特殊情况：</p><ul><li><code>root</code>是<code>nullptr</code>,那么就说明到了最底部了，直接返回<code>nullptr</code>即可</li><li><code>root</code>和<code>p</code>或<code>q</code>相等,说明我们找到了其一个祖先，则返回<code>p</code>或<code>q</code>.</li></ul><p>然后将上面的思路写出来就是:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    TreeNode *left = lowestCommonAncestor(root-&gt;left,p,q);</span><br><span class="line">    TreeNode *right = lowestCommonAncestor(root-&gt;right,p,q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (left) <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (right) <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实上面有一个问题没考虑到，要是只有<code>p</code>在这棵子树中，而<code>q</code>不在，那怎么办。</p><p>emmmm，但是上面的解法是过了测试的。</p><p>如果要考虑这个问题的话，上面就有一些假设就是错的了，因为在<code>lowestCommonAncestor</code>在某些情况返回非空只是说明，这棵子树中有一个节点是与<code>p</code>和<code>q</code>相同的。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Palindrome Linked List</title>
      <link href="/2017/11/06/Palindrome-Linked-List/"/>
      <url>/2017/11/06/Palindrome-Linked-List/</url>
      
        <content type="html"><![CDATA[<p>第42天。</p><p>今天的题目是<a href="https://leetcode.com/problems/palindrome-linked-list/description/" target="_blank" rel="noopener">Palindrome Linked List</a>:</p><blockquote><p>Given a singly linked list, determine if it is a palindrome.</p><p>Follow up:<br>Could you do it in O(n) time and O(1) space?</p></blockquote><p>如果不考虑<code>O(1)</code>的空间复杂度的话，可以直接用一个栈保存，然后在对比，不过我没有实现这个方法。我的解法是先用快慢指针求链表中点，然后在翻转后面的链表（只需要<code>O(n)</code>的时间复杂度和<code>O(1)</code>的空间复杂度），然后在对比。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    ListNode *fast = head;</span><br><span class="line">    ListNode *slow = head;</span><br><span class="line">    ListNode *pre = slow;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        pre = slow;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    fast = pre-&gt;next;</span><br><span class="line">    pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    fast = revertList(fast);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; head) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast-&gt;val != head-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode *<span class="title">revertList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *pre = head;</span><br><span class="line">    ListNode *cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">        ListNode *t = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = t;</span><br><span class="line">    &#125;</span><br><span class="line">    head = head-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是在<code>dicuss</code>中看到的解法，相当有趣的技巧：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ListNode* temp;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    temp = head;</span><br><span class="line">    <span class="keyword">return</span> check(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ListNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == p) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> isPal = check(p-&gt;next) &amp; (temp-&gt;val == p-&gt;val);</span><br><span class="line">    temp = temp-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> isPal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚开始看的时候感觉好像是错的，但是仔细想想，这个方法相当美妙，利用函数调用来做栈，首先是递归调用<code>check(p-&gt;next)</code>,这样的话会一直到最后一个节点才开始比较<code>temp-&gt;val == p-&gt;val</code>，又因为<code>temp = temp-&gt;next</code>始终没有执行到，所以现在<code>temp</code>指向第一个元素，而<code>p</code>指向最后一个元素，判断完后，会执行到<code>temp = temp-&gt;next</code>，然后<code>check</code>会返回，返回后<code>p</code>就指向了倒数第二个元素，就这样一直迭代下去。</p><p>不过这个方法的空间复杂度是<code>O(n)</code>.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Invert Binary Tree</title>
      <link href="/2017/11/05/Invert-Binary-Tree/"/>
      <url>/2017/11/05/Invert-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<p>第41天。</p><p>今天的题目是<a href="https://leetcode.com/problems/invert-binary-tree/discuss/" target="_blank" rel="noopener">Invert Binary Tree</a>:</p><blockquote><p>Invert a binary tree.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">2</span>     <span class="number">7</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br></pre></td></tr></table></figure><blockquote><p>to</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">7</span>     <span class="number">2</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.</p></blockquote><p>emmmm，挺出名的一道题目。</p><p>其实挺简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">invertTre1e</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">    TreeNode *left = invertTree(root-&gt;right);</span><br><span class="line">    TreeNode *right = invertTree(root-&gt;left);</span><br><span class="line">    root-&gt;left = left;</span><br><span class="line">    root-&gt;right = right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是迭代的方法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode *&gt; st;</span><br><span class="line">    st.push(root);</span><br><span class="line">    TreeNode *ret =root;</span><br><span class="line">    <span class="keyword">while</span>(!st.empty()) &#123;</span><br><span class="line">        root = st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;</span><br><span class="line">            st.push(root-&gt;left);</span><br><span class="line">            st.push(root-&gt;right);</span><br><span class="line">            TreeNode *t = root-&gt;left;</span><br><span class="line">            root-&gt;left = root-&gt;right;</span><br><span class="line">            root-&gt;right = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reverse Linked List</title>
      <link href="/2017/11/04/Reverse-Linked-List/"/>
      <url>/2017/11/04/Reverse-Linked-List/</url>
      
        <content type="html"><![CDATA[<p>第40天。</p><p>今天的题目是<a href="https://leetcode.com/problems/reverse-linked-list/discuss/" target="_blank" rel="noopener">Reverse Linked List</a>:</p><blockquote><p>Reverse a singly linked list.<br>Hint:<br>A linked list can be reversed either iteratively or recursively. Could you implement both?</p></blockquote><p>简单的想法就是直接用一个栈来完成这种后进先出的操作:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList1</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="function">ListNode <span class="title">ret</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    ListNode *p = &amp;ret;</span><br><span class="line">    <span class="built_in">stack</span>&lt;ListNode *&gt; st;</span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">nullptr</span>) &#123; st.push(head); head = head-&gt;next; &#125;</span><br><span class="line">    <span class="keyword">while</span>(!st.empty()) &#123;</span><br><span class="line">        p-&gt;next = st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> ret.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种方法效率不高，下面是迭代的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ListNode *t = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及递归的方法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *ret = reverseList(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kth Largest Element in an array</title>
      <link href="/2017/11/03/Kth-Largest-Element-in-an-array/"/>
      <url>/2017/11/03/Kth-Largest-Element-in-an-array/</url>
      
        <content type="html"><![CDATA[<p>第39天。</p><p>今天的题目是<a href="https://leetcode.com/problems/kth-largest-element-in-an-array/description/" target="_blank" rel="noopener">Kth Largest Element in an Array</a>:</p><blockquote><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><p>For example,<br>Given [3,2,1,5,6,4] and k = 2, return 5.</p><p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p></blockquote><p>简单的做法就是先对无序的数组进行倒序排序，然后返回<code>nums[k-1]</code>即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),[](<span class="keyword">int</span> a,<span class="keyword">int</span> b )&#123; <span class="keyword">return</span> a &gt; b; &#125;);</span><br><span class="line">    <span class="keyword">return</span> nums[k<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度是<code>O(nlog(n))</code>.然后是利用<code>partition</code>的方法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findKthLargest(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>() - <span class="number">1</span>,k<span class="number">-1</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> first,<span class="keyword">int</span> last,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = partition(nums,first,last);</span><br><span class="line">    <span class="keyword">if</span> (k &gt; p) <span class="keyword">return</span> findKthLargest(nums,p+<span class="number">1</span>,last,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; p) <span class="keyword">return</span> findKthLargest(nums,first,p<span class="number">-1</span>,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> nums[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> first,<span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first == last) <span class="keyword">return</span> first;</span><br><span class="line">    swap(nums[first],nums[(<span class="built_in">random</span>() % (last-first) + first)]);</span><br><span class="line">    <span class="keyword">int</span> k = nums[first];</span><br><span class="line">    <span class="keyword">while</span>(first &lt; last) &#123;</span><br><span class="line">        <span class="keyword">while</span>(first &lt; last &amp;&amp; nums[last] &lt;= k) last--;</span><br><span class="line">        nums[first] = nums[last];</span><br><span class="line">        <span class="keyword">while</span>(first &lt; last &amp;&amp; nums[first] &gt;= k) first++;</span><br><span class="line">        nums[last] = nums[first];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[first] = k;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然和上面快排的方法一样时间复杂度都是<code>O(nlogn)</code>.</p><p>然后是在<code>dicuss</code>中看到的用堆排的方法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> heap_size;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (idx &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (idx &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> largest = idx;</span><br><span class="line">    <span class="keyword">int</span> l = left(idx), r = right(idx);</span><br><span class="line">    <span class="keyword">if</span> (l &lt; heap_size &amp;&amp; nums[l] &gt; nums[largest]) largest = l;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; heap_size &amp;&amp; nums[r] &gt; nums[largest]) largest = r;</span><br><span class="line">    <span class="keyword">if</span> (largest != idx) &#123;</span><br><span class="line">        swap(nums[idx], nums[largest]);</span><br><span class="line">        max_heapify(nums, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_max_heap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    heap_size = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (heap_size &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        max_heapify(nums, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    build_max_heap(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        swap(nums[<span class="number">0</span>], nums[heap_size - <span class="number">1</span>]);</span><br><span class="line">        heap_size--;</span><br><span class="line">        max_heapify(nums, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[heap_size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有用<code>STL</code>中<code>priority_queue</code>的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="function">priority_queue&lt;<span class="keyword">int</span>&gt; <span class="title">pq</span><span class="params">(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++)</span><br><span class="line">        pq.pop(); </span><br><span class="line">    <span class="keyword">return</span> pq.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Intersection of Two Linked Lists</title>
      <link href="/2017/11/02/Intersection-of-Two-Linked-Lists/"/>
      <url>/2017/11/02/Intersection-of-Two-Linked-Lists/</url>
      
        <content type="html"><![CDATA[<p>第38天。</p><p>今天课贼多，突然发现贼多作业没写完。。。</p><p>今天的题目是<a href="https://leetcode.com/problems/intersection-of-two-linked-lists/description/" target="_blank" rel="noopener">Intersection of Two Linked Lists</a>:</p><blockquote><p>Write a program to find the node at which the intersection of two singly linked lists begins.</p><p>For example, the following two linked lists:</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A:          a1 → a2</span><br><span class="line">                   ↘</span><br><span class="line">                     c1 → c2 → c3</span><br><span class="line">                   ↗</span><br><span class="line">B:     b1 → b2 → b3</span><br></pre></td></tr></table></figure><blockquote><p>begin to intersect at node c1.</p><p>Notes:</p><p>If the two linked lists have no intersection at all, return null.<br>The linked lists must retain their original structure after the function returns.<br>You may assume there are no cycles anywhere in the entire linked structure.<br>Your code should preferably run in O(n) time and use only O(1) memory.</p></blockquote><p>最简单的方法就是先遍历一遍第一个链表所有的节点，然后记录下来，然后在遍历第二个链表节点的使用进行 查找即可，虽然很简单，但是时间复杂度很高和空间复杂度都挺高的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ListNode *&gt; vec;</span><br><span class="line">    <span class="keyword">while</span>(headA) &#123;</span><br><span class="line">        vec.push_back(headA);</span><br><span class="line">        headA = headA-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(headB) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),headB) != vec.<span class="built_in">end</span>()) <span class="keyword">return</span> headB;</span><br><span class="line">        headB = headB-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是另一种方法，观察下图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A:          a1 → a2</span><br><span class="line">                   ↘</span><br><span class="line">                     c1 → c2 → c3</span><br><span class="line">                   ↗</span><br><span class="line">B:     b1 → b2 → b3</span><br></pre></td></tr></table></figure><p>如果我们可以不断的把c3,c2,c1去掉，到最后，我们就会找到交点,这个方法只需要<code>O(1)</code>的空间复杂度以及<code>O(n*k)</code>的时间复杂度，k是两个链表共同拥有的节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//if (headA == nullptr || headB == nullptr) return nullptr;</span></span><br><span class="line">    ListNode *<span class="built_in">end</span> = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="built_in">end</span> || headB == <span class="built_in">end</span>) <span class="keyword">return</span> <span class="built_in">end</span>;</span><br><span class="line">        ListNode *pa = headA;</span><br><span class="line">        ListNode *pb = headB;</span><br><span class="line">        <span class="keyword">while</span>(pa-&gt;next != <span class="built_in">end</span>) pa = pa-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(pb-&gt;next != <span class="built_in">end</span>) pb = pb-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (pa != pb) <span class="keyword">return</span> <span class="built_in">end</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">end</span> = pa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是在<code>dicuss</code>中看到的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    ListNode *cur1 = headA, *cur2 = headB;</span><br><span class="line">    <span class="keyword">while</span>(cur1 != cur2)&#123;</span><br><span class="line">        cur1 = cur1?cur1-&gt;next:headB;</span><br><span class="line">        cur2 = cur2?cur2-&gt;next:headA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一眼看，没看懂，后来仔细看看才发现，<code>cur1</code>原本是<code>headA</code>开始的，但是在循环里面却被换成了<code>headB</code>,<code>cur2</code>同理。</p><p>所以他们其实会走同样多的距离并到达交点,如果没有交点，就同时到达<code>nullptr</code>。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Linked-List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Number of Islands</title>
      <link href="/2017/11/01/Number-of-Islands/"/>
      <url>/2017/11/01/Number-of-Islands/</url>
      
        <content type="html"><![CDATA[<p>第37天。</p><p>今天的题目<a href="https://leetcode.com/problems/number-of-islands/description/" target="_blank" rel="noopener">Number of Islands</a>比较简单，而且感觉好像做过的样子：</p><blockquote><p>Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p><p>Example 1:</p><p>11110<br>11010<br>11000<br>00000<br>Answer: 1</p><p>Example 2:</p><p>11000<br>11000<br>00100<br>00011<br>Answer: 3</p></blockquote><p>解法相当简单，只要遍历所有点，然后如何当前点是<code>1</code>,就将计数加一，然后进行扩展，所谓的扩展就是将当前点的值至为<code>0</code>,然后向上下左右进行查找，如果还是<code>1</code>就递归调用扩展。</p><p>```c++<br>    int numIslands(vector&lt;vector<char>&gt;&amp; grid) {<br>        if (grid.size() == 0 || grid[0].size() == 0) return 0;<br>        int count = 0;</p><pre><code>    for(int i = 0;i &lt; grid.size();i++) {        for(int j = 0;j &lt; grid[0].size();j++) {            if (grid[i][j] == &apos;1&apos;) {                cout &lt;&lt; &quot;(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)\n&quot;;                count++;                expend(grid,i,j);            }        }    }    return count;}void expend(vector&lt;vector&lt;char&gt; &gt; &amp;grid,int x,int y) {    if ( x &lt; 0 || y &lt; 0 ||        x &gt;= grid.size() || y &gt;= grid[0].size() ||       grid[x][y] == &apos;0&apos; ) return;    //cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;    grid[x][y] = &apos;0&apos;;    expend(grid,x-1,y);    expend(grid,x+1,y);    expend(grid,x,y-1);    expend(grid,x,y+1);}</code></pre><p>``</p><p>因为<code>dicuss</code>中的做法都是一样的，所以就不贴<code>dicuss</code>的代码了。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sort List</title>
      <link href="/2017/10/31/Sort-List/"/>
      <url>/2017/10/31/Sort-List/</url>
      
        <content type="html"><![CDATA[<p>第36天。</p><p>今天的题目好像是之前就做过的了，<a href="https://leetcode.com/problems/sort-list/description/" target="_blank" rel="noopener">Sort List</a>:</p><blockquote><p>Sort a linked list in O(n log n) time using constant space complexity.</p></blockquote><p>要<code>O(nlogn)</code>的算法，显然就是要用归并或快排啦，但是因为他是链表，所以只能是归并排序。</p><p>归并排序首先要解决的问题就是，如何分成两半，这里用的方法是快慢指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span> ) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    ListNode *slow = head;</span><br><span class="line">    ListNode *fast = head;</span><br><span class="line">    ListNode *pre = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        pre = slow;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    head = sortList(head);</span><br><span class="line">    slow = sortList(slow);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mergeList(head,slow);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode *<span class="title">mergeList</span><span class="params">(ListNode *p1,ListNode *p2)</span> </span>&#123;</span><br><span class="line">    <span class="function">ListNode <span class="title">ret</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    ListNode *p = &amp;ret;</span><br><span class="line">    <span class="keyword">while</span>(p1&amp;&amp;p2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;val &gt; p2-&gt;val) &#123; p-&gt;next = p2; p2 = p2-&gt;next; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;p-&gt;next = p1; p1 = p1-&gt;next; &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1) p-&gt;next = p1;</span><br><span class="line">    <span class="keyword">if</span> (p2) p-&gt;next = p2;</span><br><span class="line">    <span class="keyword">return</span> ret.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是之前做过的，而且好像还写过<code>Blog</code>,所以就不详细写了。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linked List Cycle</title>
      <link href="/2017/10/30/Linked-List-Cycle/"/>
      <url>/2017/10/30/Linked-List-Cycle/</url>
      
        <content type="html"><![CDATA[<p>第35天。</p><p>今天的题目是<a href="https://leetcode.com/problems/linked-list-cycle-ii/description/" target="_blank" rel="noopener">Linked List Cycle II</a>:</p><blockquote><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p><p>Note: Do not modify the linked list.</p><p>Follow up:<br>Can you solve it without using extra space?</p></blockquote><p>这道题是判断链表是否有环的升级版。</p><p>首先肯定需要<code>fast</code>和<code>slow</code>指针来先判断是否有环，如果没有，就直接返回<code>nullptr</code>即可。</p><p>然后就是怎么计算出环的入口了。</p><p>先来个暴力的方法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ListNode *&gt; lvec;</span><br><span class="line">    ListNode *fast = head;</span><br><span class="line">    ListNode *slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="comment">//lvec.push_back(slow);</span></span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            lvec.push_back(slow);</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">while</span>(slow != fast) &#123;</span><br><span class="line">                lvec.push_back(slow);</span><br><span class="line">                slow=slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> t:lvec) <span class="built_in">cout</span> &lt;&lt; t-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">find</span>(lvec.<span class="built_in">begin</span>(),lvec.<span class="built_in">end</span>(),head) == lvec.<span class="built_in">end</span>())</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然实际的方法不用那么麻烦：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ListNode *&gt; lvec;</span><br><span class="line">    ListNode *fast = head;</span><br><span class="line">    ListNode *slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">            slow = head;</span><br><span class="line">            <span class="keyword">while</span>(slow != fast) &#123;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fast;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>emmmm,一直很好奇为什么可以这样判断，就去搜了一下，发现了这个<a href="http://windsmoon.com/2017/10/09/%E5%88%A4%E6%96%AD%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%E5%8F%8A%E6%B1%82%E7%8E%AF%E5%85%A5%E5%8F%A3%E7%9A%84%E7%AE%97%E6%B3%95%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E/#more" target="_blank" rel="noopener">判断单向链表是否有环及求环入口的算法数学证明</a>.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Linked-List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Partition to K Equal Sum Subsets</title>
      <link href="/2017/10/29/Partition-to-K-Equal-Sum-Subsets/"/>
      <url>/2017/10/29/Partition-to-K-Equal-Sum-Subsets/</url>
      
        <content type="html"><![CDATA[<p>第35天。</p><p>又一次一个早上没做出来，难道要跪在DP上了吗？</p><p>今天的题目是<a href="https://leetcode.com/problems/partition-to-k-equal-sum-subsets/description/" target="_blank" rel="noopener">Partition to K Equal Sum Subsets</a>:</p><blockquote><p>Given an array of integers nums and a positive integer k, find whether it’s possible to divide this array into k non-empty subsets whose sums are all equal.</p><p>Example 1:<br>Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4<br>Output: True<br>Explanation: It’s possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.<br>Note:</p><p>1 &lt;= k &lt;= len(nums) &lt;= 16.<br>0 &lt; nums[i] &lt; 10000.</p></blockquote><p>虽然一开始思路是对的，但是就是没想出来做递归，先讲讲我想到的：</p><p>首先，他要我们分辨一组数字是否能被划分成K个相同的子集，我们可以对这个数组进行求和，如果和是K的倍数，那么这个倍数<code>a</code>就是每个子集的和，如果不是K的倍数，则肯定没法分成和相同的K个子集。</p><p>现在问题变成了，找出k个子集使得它的和为<code>a</code>.</p><p>然后，我就不会做了。</p><p>然后是在<code>dicuss</code>中看到的方法，前面的思路是完全一样的，所以这里只讲讲他是怎么做求出k个子集使得和为<code>a</code>的.</p><p>其实方法很简单，暴力搜而已。</p><p>我们用一个大小为k的<code>vector</code>来记录每个子集的和（或者还差多少），然后我们从后面向前搜索，每次尝试将一个元素放入第i个vector中，然后考虑下一个元素，emmm，其实不好讲出来，但是代码挺简单的。</p><p>btw,这里好像没有制表啊，然后我还一直想着要怎么制表。算了，明天还是按顺序直接刷吧。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( k &lt;= <span class="number">1</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//return canPartitionKSubsets(nums.begin(),k/2);</span></span><br><span class="line"></span><br><span class="line">    sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:nums) </span><br><span class="line">        sum +=i;</span><br><span class="line">    <span class="keyword">if</span> (sum % k != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> a = sum / k;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">kdq</span><span class="params">(k,a)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> possible(nums,kdq,nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">possible</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;kdq,<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:kdq) <span class="keyword">if</span> (i != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = nums[index];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;a:kdq) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt;= n) &#123;</span><br><span class="line">            a -= n;</span><br><span class="line">            <span class="keyword">if</span> (possible(nums,kdq,index<span class="number">-1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            a += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Best Time to Buy and Sell Stock with Transaction Fee</title>
      <link href="/2017/10/28/Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee/"/>
      <url>/2017/10/28/Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee/</url>
      
        <content type="html"><![CDATA[<p>第34天。</p><p>今天又没做出来，sad，同样是一道DP的题目：</p><blockquote><p>Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee.</p><p>You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)</p><p>Return the maximum profit you can make.<br>Example 1:<br>Input: prices = [1, 3, 2, 8, 4, 9], fee = 2<br>Output: 8<br>Explanation: The maximum profit can be achieved by:<br>Buying at prices[0] = 1<br>Selling at prices[3] = 8<br>Buying at prices[4] = 4<br>Selling at prices[5] = 9<br>The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.<br>Note:<br>0 &lt; prices.length &lt;= 50000.<br>0 &lt; prices[i] &lt; 50000.<br>0 &lt;= fee &lt; 50000.</p></blockquote><p>先理解一下题意先，大概是输入是一个表示股票价格的数组<code>prices</code>以及一个表示交易费用的<code>fee</code>,这个<code>fee</code>在每次交易的时候都需要支付。</p><p>然后很自然的我们会用一个<code>profit</code>的数组来记录，每天能达到的最大<code>profit</code>，然后我们也比较容易写出一个递推式：<br><code>profit[i] = max(profit[j],profit[j] + prices[i] - prices[j] -fee) for j in range(0,i)</code></p><p>然后就写出了一个<code>O(n^2)</code>的算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">profit</span><span class="params">(prices.<span class="built_in">size</span>(),<span class="number">0</span>)</span></span>;</span><br><span class="line">    profit[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; profit.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line">            profit[i] = <span class="built_in">max</span>(profit[i],profit[j]);</span><br><span class="line">            <span class="keyword">int</span> t = profit[j] + prices[i] - prices[j] - fee;</span><br><span class="line">            profit[i] = <span class="built_in">max</span>(profit[i],t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *profit.rbegin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就时间超限了。</p><p>想了一个早上也没能解决，很好又一次被<code>KMP</code>的<code>next</code>误导了，又是打算用加快内层循环的方式去做，但是还是会出现时间超限的问题。</p><p>哎，还是来看看<code>dicuss</code>中的解法吧：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s0 = <span class="number">0</span>,s1 = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p:prices) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = s0;</span><br><span class="line">        s0 = <span class="built_in">max</span>(s0,s1+p);      <span class="comment">//sell</span></span><br><span class="line">        s1 = <span class="built_in">max</span>(s1,t-p-fee);   <span class="comment">//buy</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面的解法之所以会出现超时，就是因为他的时间复杂度为<code>O(n^2)</code>,而<code>dicuss</code>中的解法却是<code>O(n)</code>的，这里的<code>s0</code>和第一个方法的<code>profit</code>是一样的，重要的s1.</p><p>我们知道一次交易可以分为<code>buy</code>和<code>sell</code>,他们消耗一次<code>fee</code>，那么我们可以将这个<code>fee</code>归入到<code>buy</code>的时候，如果当前操作是<code>buy</code>,那么必须保证我们当前没有股票，也就是说上一次操作是<code>sell</code>,这里的<code>s0</code>就是表示没有股票的状态，<code>s1</code>表示是有股票的状态。</p><p>对于<code>s0</code>,我们想要更新它，就只有将上一个<code>s1</code>卖出，然后取最大值<br>对于<code>s1</code>，我们要更新它，就只有将当前股票买入，然后取最大值。</p><p>所以就得到了上面的两条式子。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Word Break</title>
      <link href="/2017/10/27/Word-Break/"/>
      <url>/2017/10/27/Word-Break/</url>
      
        <content type="html"><![CDATA[<p>第33天。</p><p>做了超级久。。。还是没做出来，我真是菜啊，明明已经想到了要用动态规划来做了。</p><p>今天的题目是:<a href="https://leetcode.com/problems/word-break/description/" target="_blank" rel="noopener">Word Break</a>:</p><blockquote><p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.</p><p>For example, given<br>s = “leetcode”,<br>dict = [“leet”, “code”].</p><p>Return true because “leetcode” can be segmented as “leet code”.</p></blockquote><p>因为没做出来，所以只能讲别人的思路了。。。</p><p>首先这里是要用动态规划去做的，我们需要一个<code>vector&lt;bool&gt; db</code>来记录<code>s.substr(0,i+1)</code>的子串是否能用<code>wordDict</code>进行<code>break</code>,如果我们要求<code>db[i]</code>我们是否能利用<code>db[0:i]</code>的值呢，比如，如果<code>0&lt;= k &lt; i</code>，且<code>db[k]==true</code>,那么我们是不是只需要在<code>wordDict</code>中查找是否有<code>s.substr(i,k-i)</code>就可了呢：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(wordDict.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(s.<span class="built_in">size</span>() + <span class="number">1</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= s.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i<span class="number">-1</span>;j &gt;= <span class="number">0</span>;j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j]) &#123;</span><br><span class="line">                <span class="built_in">string</span> <span class="keyword">word</span> = s.substr(j,i-j);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">find</span>(wordDict.<span class="built_in">begin</span>(),wordDict.<span class="built_in">end</span>(),<span class="keyword">word</span>) != wordDict.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是别人的思路，所以也没法复现思考的过程了，总结一下没做出来的原因吧。<br>虽然说算法课上刚讲了<code>DP</code>,当时他讲的时候我还觉得挺简单的，还以为自己已经会了，因为之前已经做过好几次<code>DP</code>的题目了，现在想想上课我就记得他吐槽了<code>DP</code>的恋爱观，什么总是找局部最优解巴拉巴拉的。<br>哎，这种东西还是要自己体会才行，恩，决定了，这几天刷会<code>DP</code>的题目先。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flatten Binary Tree to Linked List</title>
      <link href="/2017/10/26/Flatten-Binary-Tree-to-Linked-List/"/>
      <url>/2017/10/26/Flatten-Binary-Tree-to-Linked-List/</url>
      
        <content type="html"><![CDATA[<p>第32天。</p><p>今天的题目是<a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/discuss/" target="_blank" rel="noopener">Flatten Binary Tree to Linked List</a>:</p><blockquote><p>Given a binary tree, flatten it to a linked list in-place.</p><p>For example,<br>Given</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure><blockquote><p>The flattened tree should look like:</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">2</span></span><br><span class="line">   \</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">4</span></span><br><span class="line">       \</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">         \</span><br><span class="line">          <span class="number">6</span></span><br></pre></td></tr></table></figure><p>通过观察结果，我们可以发现它的顺序其实是一个先序遍历,那么我们可以先对树做一个先序遍历并记录节点指针，然后我们只需要将所有节点连接起来即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flatten2</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode *&gt; st;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode *&gt; tvec;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(root)&#123;</span><br><span class="line">            st.push(root);</span><br><span class="line">            tvec.push_back(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (st.empty() ) <span class="keyword">break</span>;</span><br><span class="line">        root = st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; tvec.<span class="built_in">size</span>() - <span class="number">1</span>;i++) &#123;</span><br><span class="line">        tvec[i]-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        tvec[i]-&gt;right = tvec[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    tvec[i]-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">    tvec[i]-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑一下递归的去完成整个问题，我们可以先对左孩子和右孩子做一次<code>flatten</code>,然后再讲他们按照适当的顺序连接起来:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    flatten(root-&gt;left);</span><br><span class="line">    flatten(root-&gt;right);</span><br><span class="line">    <span class="keyword">auto</span> right = root-&gt;right;</span><br><span class="line">    <span class="keyword">auto</span> left = root-&gt;left;</span><br><span class="line">    <span class="keyword">if</span> (left)&#123;</span><br><span class="line">        root-&gt;right = left;</span><br><span class="line">        root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(left-&gt;right)</span><br><span class="line">            left = left-&gt;right;</span><br><span class="line">        left-&gt;right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的做法由于每次都需要对左孩子有一个一直往右的遍历，所以耗时还是挺大的，可以加入一个last指针，去表示最后一个被访问的节点的位置,为了保证正确性，我们必须先对右孩子进行<code>flatten</code>再对左孩子进行<code>flatten</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TreeNode *last;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    flatten(root-&gt;right);</span><br><span class="line">    flatten(root-&gt;left);</span><br><span class="line">    root-&gt;right = last;</span><br><span class="line">    root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">    last = root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是在<code>dicuss</code>中看到的迭代算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left &amp;&amp; root-&gt;right) &#123;</span><br><span class="line">            TreeNode* t = root-&gt;left;</span><br><span class="line">            <span class="keyword">while</span> (t-&gt;right)</span><br><span class="line">                t = t-&gt;right;</span><br><span class="line">            t-&gt;right = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            root-&gt;right = root-&gt;left;</span><br><span class="line">        root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>List</title>
      <link href="/2017/10/26/List/"/>
      <url>/2017/10/26/List/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Construct Binary Tree from Preorder and Inorder Traversal</title>
      <link href="/2017/10/25/Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/"/>
      <url>/2017/10/25/Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/</url>
      
        <content type="html"><![CDATA[<p>第32天。</p><p>其实早在很久之前了就想着坚持了一个月之后要发票圈纪念一下的，后来想想其实也没啥必要的，感觉每天早上起来开电脑看题目已经成了习惯了，习惯有啥好纪念的（其实到100天的时候应该还是挺有意义的）。</p><p>今天的题目是<a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/" target="_blank" rel="noopener">Construct Binary Tree from Preorder and Inorder Traversal</a>：</p><blockquote><p>Given preorder and inorder traversal of a tree, construct the binary tree.</p><p>Note:<br>You may assume that duplicates do not exist in the tree.</p></blockquote><p>一开始没看到<code>Note</code>，还觉得会有点麻烦，不过既然没有重复元素，写出一个递归解法就很简单了:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">buildTree1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bulidTreeIter(preorder.<span class="built_in">begin</span>(),preorder.<span class="built_in">end</span>(),inorder.<span class="built_in">begin</span>(),inorder.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode *<span class="title">bulidTreeIter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator pBeg,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator pEnd,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iBeg,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iEnd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pEnd == pBeg) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode *root = <span class="keyword">new</span> TreeNode(*pBeg);</span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">find</span>(iBeg,iEnd,*pBeg);</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = it - iBeg;</span><br><span class="line">    root-&gt;left = bulidTreeIter(pBeg+<span class="number">1</span>,pBeg + <span class="built_in">size</span> + <span class="number">1</span>,iBeg,it);</span><br><span class="line">    root-&gt;right = bulidTreeIter(pBeg+<span class="built_in">size</span>+<span class="number">1</span>,pEnd,it+<span class="number">1</span>,iEnd);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>恩，貌似是第一次一次<code>Submit</code>就直接过。</p><p>然后是在<code>dicuss</code>中看到的迭代算法，但是感觉很复杂的样子,而且效率也不一定比递归版的高。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;inorder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(preorder.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode *&gt; st;</span><br><span class="line">    TreeNode *t,*r,*root;</span><br><span class="line">    <span class="keyword">int</span> i,j,f;</span><br><span class="line"></span><br><span class="line">    f=i=j=<span class="number">0</span>;</span><br><span class="line">    s.push(preorder[i]);</span><br><span class="line"></span><br><span class="line">    root = <span class="keyword">new</span> TreeNode(preorder[i]);</span><br><span class="line">    st.push(root);</span><br><span class="line">    t = root;</span><br><span class="line">    i++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i&lt;preorder.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st.empty() &amp;&amp; st.top()-&gt;val==inorder[j])</span><br><span class="line">        &#123;</span><br><span class="line">            t = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            s.pop();</span><br><span class="line">            f = <span class="number">1</span>;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(preorder[i]);</span><br><span class="line">                t -&gt; left = <span class="keyword">new</span> TreeNode(preorder[i]);</span><br><span class="line">                t = t -&gt; left;</span><br><span class="line">                st.push(t);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                f = <span class="number">0</span>;</span><br><span class="line">                s.push(preorder[i]);</span><br><span class="line">                t -&gt; right = <span class="keyword">new</span> TreeNode(preorder[i]);</span><br><span class="line">                t = t -&gt; right;</span><br><span class="line">                st.push(t);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Binary Tree Level Order Traversal</title>
      <link href="/2017/10/24/Binary-Tree-Level-Order-Traversal/"/>
      <url>/2017/10/24/Binary-Tree-Level-Order-Traversal/</url>
      
        <content type="html"><![CDATA[<p>第31天。</p><p>今天的题目是之前好像就做过的了,<a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/" target="_blank" rel="noopener">Binary Tree Level Order Traversal</a>:</p><blockquote><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p><p>For example:<br>Given binary tree [3,9,20,null,null,15,7],</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><blockquote><p>return its level order traversal as:</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>emmm，简单来讲就是层次遍历.</p><p>一般来说，层次遍历都是用队列来实现:</p><ul><li>先让root入队，这时我们队列里面就有第一层的所有元素了</li><li>我们记录当前层次所拥有的元素的个数size，然后出队size个元素，对于每一个出队的元素，我们遍历它一次，然后将它的左右孩子入队。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ret;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((<span class="built_in">size</span> = q.<span class="built_in">size</span>())) &#123;</span><br><span class="line">        ret.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">size</span>--) &#123;</span><br><span class="line">            root = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            ret[last].push_back(root-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left) q.push(root-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right) q.push(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        last++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后因为这里是返回<code>vector&lt; vector&lt;int&gt; &gt;</code>，而不是直接输出，所以我们可以取个巧，写出一个递归算法出来:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ret;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    leverlOrder(root,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode* root,<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (level &gt;= ret.<span class="built_in">size</span>() ) &#123;</span><br><span class="line">        ret.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    ret[level].push_back(root-&gt;val);</span><br><span class="line">    levelOrder(root-&gt;left,level+<span class="number">1</span>);</span><br><span class="line">    levelOrder(root-&gt;right,level+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实是先序遍历，但是因为我们一直记录着层数，所以我们还是可以保证<code>vector&lt;vector&lt;int&gt; &gt;</code>的顺序是正确的。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Validate Binary Search Tree</title>
      <link href="/2017/10/23/Validate-Binary-Search-Tree/"/>
      <url>/2017/10/23/Validate-Binary-Search-Tree/</url>
      
        <content type="html"><![CDATA[<p>第30天。</p><p>恍恍惚惚就一个月了。</p><p>今天的题目是<a href="https://leetcode.com/problems/validate-binary-search-tree/description/" target="_blank" rel="noopener">Validate Binary Search Tree</a>:</p><blockquote><p>Given a binary tree, determine if it is a valid binary search tree (BST).</p><p>Assume a BST is defined as follows:</p><p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.<br>Example 1:</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">2</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure><blockquote><p>Binary tree [2,1,3], return true.<br>Example 2:</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure><blockquote><p>Binary tree [1,2,3], return false.</p></blockquote><p>昨天的题目也是和BST有关的，但是这里的定义和昨天有点不用，它这里要求左子树的所有节点都比根节点的值要小，右子树的所有的节点的值都比根节点的值大.</p><p>我们可以发现这样定义的BST的中序遍历一定是升序的，所以我们可以用先序遍历的方式来做:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> vmax = LLONG_MIN;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBST1</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">if</span> ( !isValidBST(root-&gt;left) ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">if</span> (root-&gt;val &lt;= vmax) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       vmax = root-&gt;val;</span><br><span class="line">       <span class="keyword">return</span> isValidBST(root-&gt;right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>既然使用中序遍历做的，那么我们就可以用非递归版的先序遍历来加快:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> vmax = LLONG_MIN;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode *&gt; st;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(root)&#123;</span><br><span class="line">            st.push(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st.empty()) <span class="keyword">break</span>;</span><br><span class="line">        root = st.top();</span><br><span class="line">        st.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (vmax &gt;= root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        vmax = root-&gt;val;</span><br><span class="line"></span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面都是用<code>long long</code>来记录最大值，这时因为如果用<code>INT_MIN</code>来做的话，<code>[INT_MIN,INT_MIN]</code>这样的测例就会出错，我是用<code>long long</code>来解决这个问题的，但是<code>dicuss</code>中有一些其他方法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    TreeNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> validate(root, prev);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validate</span><span class="params">(TreeNode* node, TreeNode* &amp;prev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!validate(node-&gt;left, prev)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="literal">NULL</span> &amp;&amp; prev-&gt;val &gt;= node-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    prev = node;</span><br><span class="line">    <span class="keyword">return</span> validate(node-&gt;right, prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root, TreeNode* minNode, TreeNode* maxNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(minNode &amp;&amp; root-&gt;val &lt;= minNode-&gt;val || maxNode &amp;&amp; root-&gt;val &gt;= maxNode-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root-&gt;left, minNode, root) &amp;&amp; isValidBST(root-&gt;right, root, maxNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unique Binary Search Tree</title>
      <link href="/2017/10/22/Unique-Binary-Search-Tree/"/>
      <url>/2017/10/22/Unique-Binary-Search-Tree/</url>
      
        <content type="html"><![CDATA[<p>第29天。</p><p>今天的题目是<a href="https://leetcode.com/problems/unique-binary-search-trees/description/" target="_blank" rel="noopener">Unique Binary Search Trees</a>:</p><blockquote><p>Given n, how many structurally unique BST’s (binary search trees) that store values 1…n?</p><p>For example,<br>Given n = 3, there are a total of 5 unique BST’s.</p><pre><code>1         3     3      2      1\       /     /      / \      \3     2     1      1   3      2/     /       \                 \2     1         2                 3</code></pre></blockquote><p>对于这种问题一般都可以用递归去做的，我们尝试的找一下递归式。</p><p><code>n=1</code> -&gt; <code>1</code><br><code>n=2</code> -&gt; <code>2</code><br><code>n=3</code> -&gt; <code>5</code></p><p>我们考虑<code>n=3</code>时的情况,这时这棵树种包含三个值<code>1,2,3</code>,这说明树根的可能是<code>1,2,3</code>中的一个值：</p><ul><li>当<code>root=1</code>时，<code>2,3</code>只能放在右子树。现在只考虑<code>2,3</code>两个值，由于<code>BST</code>的性质,右子树也必须是<code>BST</code>，则此时问题转换成求<code>numsTrees(2)</code>.</li><li>当<code>root=2</code>时，左边必定是<code>1</code>,右边必定是<code>3</code>.</li><li>当<code>root=3</code>时，左边必定是<code>1,2</code>，同样转换成<code>numsTrees(2)</code>.</li></ul><p>我们再考虑一下<code>n=5</code>时的情况：</p><ul><li><code>root=3</code>，左子树必定是是包含<code>1,2</code>的BST，右子树必定是包含<code>4,5</code>的BST，此时种类为<code>numsTree(5-3)*numsTrees(3-1)</code>。</li></ul><p>所以我们可以找到递推式：</p><ul><li><code>n &lt; 2</code> -&gt; <code>numsTrees(n) = 1</code></li><li><code>n &gt;= 2</code> -&gt; <code>numsTrees(n) = numsTrees(1)*numsTrees(n-1) + numsTrees(2)*numTree(n-2) + ... + numsTree(n-1)*numsTrees(1)</code>;</li></ul><p>所以我们写出一个递归的解决方案:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n-i;</span><br><span class="line">        ret += numTrees(left)*numTrees(right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这里会超时，很明显这里可以用动态规划来优化:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    ret[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    ret[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= i;j++)</span><br><span class="line">            ret[i] += ret[j<span class="number">-1</span>]*ret[i-j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dicuss</code>中基本都是和上面类似的解法，除了一个:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//cantalan树</span></span><br><span class="line">    <span class="comment">//C(2n,n)/(n+1)</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">        ans = ans*i/(i-n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans/(n+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>emmm,说实话，我没看懂，但是这个方法的确是最快的，只需要<code>O(n)</code>的时间，<code>O(1)</code>的空间。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Word Search</title>
      <link href="/2017/10/21/Word-Search/"/>
      <url>/2017/10/21/Word-Search/</url>
      
        <content type="html"><![CDATA[<p>第28天。</p><p>今天的题目是<a href="https://leetcode.com/problems/word-search/description/" target="_blank" rel="noopener">Word Search</a>：</p><blockquote><p>Given a 2D board and a word, find if the word exists in the grid.</p><p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p><p>For example,<br>Given board =</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'E'</span>],</span><br><span class="line">  [<span class="string">'S'</span>,<span class="string">'F'</span>,<span class="string">'C'</span>,<span class="string">'S'</span>],</span><br><span class="line">  [<span class="string">'A'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>word = “ABCCED”, -&gt; returns true,<br>word = “SEE”, -&gt; returns true,<br>word = “ABCB”, -&gt; returns false.</p></blockquote><p>这道题想起来不难，就是有点繁琐，有几个要点需要考虑：</p><ul><li>每个元素只能用一次</li><li>字符只要求是临接的，即可能有四个方向需要考虑。</li></ul><p>因为每个元素只能用一次，所以我们需要一个方式来记录这个位置是否被使用，简单的方法就是直接用一个二维数组来记录，然后我们需要考虑是否越过边界:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; &amp;board,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; &amp;used,<span class="built_in">string</span> &amp;<span class="keyword">word</span>,<span class="keyword">int</span> beg,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//找到了</span></span><br><span class="line">    <span class="keyword">if</span> (beg == <span class="keyword">word</span>.<span class="built_in">size</span>() ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//边界检测</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= board.<span class="built_in">size</span>() || j &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>() ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//检测是否被使用了</span></span><br><span class="line">    <span class="keyword">if</span> (used[i][j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//检测是否是想要的字符</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">word</span>[beg] != board[i][j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//假设这就是正确的路径</span></span><br><span class="line">    used[i][j] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//向四个方向查找</span></span><br><span class="line">    <span class="keyword">if</span>( search(board,used,<span class="keyword">word</span>,beg+<span class="number">1</span>,i<span class="number">-1</span>,j) || search(board,used,<span class="keyword">word</span>,beg+<span class="number">1</span>,i+<span class="number">1</span>,j)</span><br><span class="line">        || search(board,used,<span class="keyword">word</span>,beg+<span class="number">1</span>,i,j<span class="number">-1</span>) || search(board,used,<span class="keyword">word</span>,beg+<span class="number">1</span>,i,j+<span class="number">1</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果四个方法都失败了，说明了这个路径是错的，所以回溯。</span></span><br><span class="line">        used[i][j] =  <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//保证至少有一个元素</span></span><br><span class="line">    <span class="keyword">if</span> (board.<span class="built_in">size</span>() == <span class="number">0</span> || board[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//创建一个二维数组来记录是否字符是否被使用</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">vec</span><span class="params">(board[<span class="number">0</span>].<span class="built_in">size</span>(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; <span class="title">used</span> <span class="params">( board.<span class="built_in">size</span>(),vec )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以每一个点为起点进行查找</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; board.<span class="built_in">size</span>();i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>();j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">word</span>[<span class="number">0</span>] == board[i][j] &amp;&amp; search(board,used,<span class="keyword">word</span>,<span class="number">0</span>,i,j))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法使用了一个二维数组来记录元素是否被使用,其实可以直接在<code>board</code>中记录是否被使用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; &amp;board, <span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">    m=board.<span class="built_in">size</span>();</span><br><span class="line">    n=board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;m;x++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;n;y++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(isFound(board,<span class="keyword">word</span>.c_str(),x,y))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; &amp;board, <span class="keyword">const</span> <span class="keyword">char</span>* w, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>||y&lt;<span class="number">0</span>||x&gt;=m||y&gt;=n||board[x][y]==<span class="string">'\0'</span>||*w!=board[x][y])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(*(w+<span class="number">1</span>)==<span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">char</span> t=board[x][y];</span><br><span class="line">    board[x][y]=<span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">if</span>(isFound(board,w+<span class="number">1</span>,x<span class="number">-1</span>,y)||isFound(board,w+<span class="number">1</span>,x+<span class="number">1</span>,y)||isFound(board,w+<span class="number">1</span>,x,y<span class="number">-1</span>)||isFound(board,w+<span class="number">1</span>,x,y+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">    board[x][y]=t;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Subsets</title>
      <link href="/2017/10/20/Subsets/"/>
      <url>/2017/10/20/Subsets/</url>
      
        <content type="html"><![CDATA[<p>第27天</p><p>今天的题目是<a href="https://leetcode.com/problems/subsets/description/" target="_blank" rel="noopener">Subsets</a>:</p><blockquote><p>Given a set of distinct integers, nums, return all possible subsets.</p><p>Note: The solution set must not contain duplicate subsets.</p><p>For example,<br>If nums = [1,2,3], a solution is:</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>我的做法是用递归的方法去做:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ret;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    ret.push_back(vec);</span><br><span class="line">    subsetsIter(ret,nums,vec,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subsetsIter</span><span class="params">(<span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;ret,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; now,<span class="keyword">int</span> beg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//if (now.size() == nums.size()) return ;</span></span><br><span class="line">    now.push_back(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">auto</span> rbeg = now.rbegin();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = beg;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        *rbeg = nums[i];</span><br><span class="line">        ret.push_back(now);</span><br><span class="line">        subsetsIter(ret,nums,now,i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    now.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是在<code>dicuss</code>中看到的迭代的方法和利用二进制的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subs</span><span class="params">(<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = subs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            subs.push_back(subs[j]); </span><br><span class="line">            subs.back().push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> num_subset = <span class="built_in">pow</span>(<span class="number">2</span>, nums.<span class="built_in">size</span>()); </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">res</span><span class="params">(num_subset, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num_subset; j++)</span><br><span class="line">            <span class="keyword">if</span> ((j &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">                res[j].push_back(nums[i]);</span><br><span class="line">    <span class="keyword">return</span> res;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sort Colors</title>
      <link href="/2017/10/19/Sort-Colors/"/>
      <url>/2017/10/19/Sort-Colors/</url>
      
        <content type="html"><![CDATA[<p>第26天。</p><p>今天的题目是个排序问题，经过算法的实验一后，这个问题其实就比较简单啦。</p><blockquote><p>Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p><p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p><p>Note:<br>You are not suppose to use the library’s sort function for this problem.</p></blockquote><p>题目的意思是他会给你一个只包含<code>0,1,2</code>三个数字的数组，你要对他进行排序。</p><p>因为里面的值只有三种可能，所以显然要用<strong>计数排序</strong>,他的时间复杂度是<code>O(n)</code>.</p><p>用这个例子大概的说明一下计数排序的原理：</p><p>现在待排数组里的值只能是<code>0,1,2</code>，所以我们通过一个长度为3的数组来记录<code>0,1,2</code>在待排序列中出现的次数（所以这个排序才叫计数排序），计算各个元素出现的次数我们只需要简单的遍历一遍序列即可，这里的时间复杂度是<code>O(n)</code>。</p><p>假如对于一个长度为10的序列，<code>0</code>出现了3次，<code>1</code>出现了4次，<code>2</code>出现了3次，我们又知道<code>0&lt;1&lt;2</code>，所以排完序之后序列的前3个元素一定是0,紧接着的四个元素一定是<code>1</code>，最后三个元素一定是<code>2</code>.</p><p>所以计数排序就两个步骤：</p><ul><li>遍历待排数组，记录元素出现的次数</li><li>通过元素出现的次数，修改待排数组</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">3</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:nums)</span><br><span class="line">        count[i]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>,k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (count[i] == <span class="number">0</span>) i++;</span><br><span class="line">        nums[k] = i;</span><br><span class="line">        k++;</span><br><span class="line">        count[i]--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是在<code>dicuss</code>中看到的，模仿了快排的<code>patition</code>的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> second=n<span class="number">-1</span>, zero=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=second; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (A[i]==<span class="number">2</span> &amp;&amp; i&lt;second) swap(A[i], A[second--]);</span><br><span class="line">        <span class="keyword">while</span> (A[i]==<span class="number">0</span> &amp;&amp; i&gt;zero) swap(A[i], A[zero++]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unique Paths</title>
      <link href="/2017/10/18/Unique-Paths/"/>
      <url>/2017/10/18/Unique-Paths/</url>
      
        <content type="html"><![CDATA[<p>第25天。</p><p>感冒真难受！</p><p>今天的题目是<a href="https://leetcode.com/problems/unique-paths/description/" target="_blank" rel="noopener">Unique Paths</a>:</p><blockquote><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p><p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p><p>How many possible unique paths are there?<br>Note: m and n will be at most 100.</p></blockquote><p>如果自己尝试几次去找的话，我们可以发现在<code>m=1</code>时或<code>n=1</code>时，只要一种可能，然后我们考虑我们现在位于<code>(m,n)</code>点<code>（m!=1,n!=1)</code>，现在要走向<code>(0,0)</code>,因为我们被限制到只能向下或下右走，即只能<code>n-1</code>或<code>m-1</code>，所以我们可以找到这样一个等式<code>uniquePaths(m,n) = uniquePaths(m-1,n) + uniquePaths(m,n-1)</code>，当<code>m!=1,n!=1</code>时，所以我们可以很快的写出下面的解决方案：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> uniquePaths(m<span class="number">-1</span>,n) + uniquePaths(m,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个会时间超限，因为我们做了很多重复的计算，因为我们计算<code>uniquePaths(3,2)</code>时需要计算<code>uniquePaths(2,2)</code>,而<code>uniquePaths(2,1)</code>也需要计算一遍，这就导致了很多重复计算。</p><p>我们考虑使用一个表来记录<code>uniquePaths</code>值，这样就可以减少每次计算的值了:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[m*n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">        p[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)</span><br><span class="line">        p[n*j] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; n;j++)</span><br><span class="line">            p[i*n+j] = p[ (i<span class="number">-1</span>)*n +j ] + p[i*n + j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p[m*n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样就不会时间超限了。</p><p>然后是在<code>dicuss</code>中看到的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">path</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (n, <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            path[i][j] = path[i - <span class="number">1</span>][j] + path[i][j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> path[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(捂脸)我一直不知道怎么用<code>vector</code>来快速的构造二维数组。</p><p>上面的两个的空间复杂度都是<code>O(m*n)</code>，下面的方法可以降成<code>O(2*min(m,n))</code>，因为我们计算某一层的时候其实只需要前一行即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> uniquePaths(n, m); </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pre</span><span class="params">(m, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cur</span><span class="params">(m, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">            cur[i] = cur[i - <span class="number">1</span>] + pre[i];</span><br><span class="line">        swap(pre, cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre[m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后其实还可以继续降低到<code>O(min(m,n))</code>,只需要一个一维数组即可:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> uniquePaths(n, m);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cur</span><span class="params">(m, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">            cur[i] += cur[i - <span class="number">1</span>]; </span><br><span class="line">    <span class="keyword">return</span> cur[m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Merge-Intervals</title>
      <link href="/2017/10/17/Merge-Intervals/"/>
      <url>/2017/10/17/Merge-Intervals/</url>
      
        <content type="html"><![CDATA[<p>第24天</p><p>emmm，又是一道10分钟刷完的题目——<a href="https://leetcode.com/problems/merge-intervals/discuss/" target="_blank" rel="noopener">Merge Intervals</a></p><blockquote><p>Given a collection of intervals, merge all overlapping intervals.</p><p>For example,<br>Given [1,3],[2,6],[8,10],[15,18],<br>return [1,6],[8,10],[15,18].</p></blockquote><p>这个题目要考虑的就是怎么才能避免不断的插入删除。</p><p>其实再后来尝试优化的时候，就是陷入这个误区，尝试的写一个<code>O(n)</code>的算法出来，但是发现要不断的遍历和插入和删除元素，我们知道这对<code>vector</code>来说时比较耗时的。</p><p>我们先确定什么时候两个<code>Intervals</code>需要<code>merge</code>,考虑<code>i1</code>,<code>i2</code>,只有<code>i1.end &gt; i2.start</code>，这时<code>i1</code>和<code>i2</code>就应该<code>merge</code>成<code>{i1.start,i2.end}</code></p><ul><li>先对<code>intervals</code>按<code>start</code>排序</li><li>将第一个元素放入<code>ret</code>，因为这时<code>start</code>是最小的，我们现在只需要寻找<code>end</code>即可</li><li>我们考察第二个元素，如果第二个元素的<code>start</code>小于第一个元素的<code>end</code>，我们就将修改<code>end</code>,并考察第三个元素，如果不成立，说明当前元素的<code>end</code>就已经找到了（因为<code>start &lt; end</code>）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;Interval&gt; <span class="title">merge1</span><span class="params">(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> intervals;</span><br><span class="line"></span><br><span class="line">    sort(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>(),[](<span class="keyword">const</span> Interval &amp;a,<span class="keyword">const</span> Interval b) -&gt; <span class="keyword">bool</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.start &lt; b.start;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; ret;</span><br><span class="line">    ret.push_back(intervals[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; intervals.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ret[last].<span class="built_in">end</span> &gt;= intervals[i].start)</span><br><span class="line">            ret[last].<span class="built_in">end</span> = <span class="built_in">max</span>(intervals[i].<span class="built_in">end</span>,ret[last].<span class="built_in">end</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ret.push_back(intervals[i]);</span><br><span class="line">            last++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有在<code>dicuss</code>中看到的答案，但是这个需要做两次<code>sort</code>，所以效率不会比上面的方法高:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">merge</span><span class="params">(List&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// sort start&amp;end</span></span><br><span class="line">    <span class="keyword">int</span> n = intervals.size();</span><br><span class="line">    <span class="keyword">int</span>[] starts = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span>[] ends = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        starts[i] = intervals.get(i).start;</span><br><span class="line">        ends[i] = intervals.get(i).end;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(starts);</span><br><span class="line">    Arrays.sort(ends);</span><br><span class="line">    <span class="comment">// loop through</span></span><br><span class="line">    List&lt;Interval&gt; res = <span class="keyword">new</span> ArrayList&lt;Interval&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// j is start of interval.</span></span><br><span class="line">        <span class="keyword">if</span> (i == n - <span class="number">1</span> || starts[i + <span class="number">1</span>] &gt; ends[i]) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> Interval(starts[j], ends[i]));</span><br><span class="line">            j = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jump-Game</title>
      <link href="/2017/10/16/Jump-Game/"/>
      <url>/2017/10/16/Jump-Game/</url>
      
        <content type="html"><![CDATA[<p>第23天</p><p>又是周一，心塞，一周过去的真快。</p><p>今天的题目是<a href="https://leetcode.com/problems/jump-game/description/" target="_blank" rel="noopener">Jump Game</a>.</p><blockquote><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p><p>Each element in the array represents your maximum jump length at that position.</p><p>Determine if you are able to reach the last index.</p><p>For example:<br>A = [2,3,1,1,4], return true.</p><p>A = [3,2,1,0,4], return false.</p></blockquote><p>这道题，主要先理解到，他存放的是<code>maximum jump length</code>,也就是说，你可以跳小于这个值的步数。然后自然而然的就想到用递归去做啊：</p><ul><li>从后向前考虑，用一个值来记录可以从最后一个位置回去的最小index.</li><li>在每一个index中，把当前的index当成是自己的要到达的点，再递归调用自己。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> canJump1(nums,nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = last<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--,k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt;= k &amp;&amp; canJump1(nums,i))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，这个方法就超时了，做了很多重复的操作。</p><p>恩，再仔细看看题目的话，它其实只要求我们返回能否到达，不要求给出跳的方法，所以我们可以换一种思路来考虑，用一个<code>last</code>值来记录当前能到达的最远位置（初始值当然是0啦），然后遍历所有能到的点然后更新当前能到的最远点，如果当前能到的点已经大于<code>nums.size() - 1</code>了，那么说明我们可以到达，如果遍历完所有的点之后还没有大于，说明到不了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= last &amp;&amp; i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        last = <span class="built_in">max</span>(last,i+nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (last &gt;= nums.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个的时间复杂度是<code>O(n)</code>,尝试过优化，但是没能成功。</p><p>最后是在<code>dicuss</code>中看到的方法，其实和上面的想法是一样的，只不过它是从后往前考虑:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.<span class="built_in">size</span>() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + nums[i] &gt;= last) &#123;</span><br><span class="line">            last = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Group-Anagrams</title>
      <link href="/2017/10/15/Group-Anagrams/"/>
      <url>/2017/10/15/Group-Anagrams/</url>
      
        <content type="html"><![CDATA[<p>第22天，今天刷回了<code>Medium</code>，果然这个难度才适合我。</p><blockquote><p>Given an array of strings, group anagrams together.</p><p>For example, given: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>Return:</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="string">"ate"</span>, <span class="string">"eat"</span>,<span class="string">"tea"</span>],</span><br><span class="line">  [<span class="string">"nat"</span>,<span class="string">"tan"</span>],</span><br><span class="line">  [<span class="string">"bat"</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>Note: All inputs will be in lower-case.</p></blockquote><p>题目很简短，主要的难点是怎样判断两个字符串是同组的（即<code>s1</code>是<code>s2</code>的一个置换），我的想法是利用<code>hash</code>来区分，不过这个<code>hash</code>函数写起来就比较麻烦了，主要是要考虑碰撞：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">hashString</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> count[<span class="number">26</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)</span><br><span class="line">        count[c-<span class="string">'a'</span>]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)&#123;</span><br><span class="line">        sum = sum*<span class="number">133</span> + count[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是一些细节问题了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">groupAnagrams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; ret;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">unsigned</span>,<span class="keyword">int</span>&gt; mRet;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;s:strs) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> h = hashString(s);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; h &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (mRet.<span class="built_in">find</span>(h) == mRet.<span class="built_in">end</span>())&#123;</span><br><span class="line">            ret.push_back(&#123;&#125;);</span><br><span class="line">            mRet[h] = now;</span><br><span class="line">            now++;</span><br><span class="line">        &#125;</span><br><span class="line">        ret[mRet[h]].push_back(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dicuss</code>中有另外一种<code>hash</code>的方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; </span><br><span class="line">   <span class="keyword">int</span>[] prime = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>, <span class="number">101</span>, <span class="number">103</span>&#125;;<span class="comment">//最多10609个z</span></span><br><span class="line">            List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String s : strs) &#123;</span><br><span class="line">                <span class="keyword">int</span> key = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">                    key *= prime[c - <span class="string">'a'</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                List&lt;String&gt; t;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">                    t = res.get(map.get(key));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    t = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    res.add(t);</span><br><span class="line">                    map.put(key, res.size() - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                t.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>额，说实话，里面的数学依据我没看懂，是因为素数只能被1和它本身整除吗？</p><p>然后同样是在<code>dicuss</code>中看到的，对字符串<code>sort</code>来判断是否在同一组的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">groupAnagrams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; anagrams;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">string</span> s: strs) &#123;</span><br><span class="line">        <span class="built_in">string</span> sorted = s;</span><br><span class="line">        sort(sorted.<span class="built_in">begin</span>(), sorted.<span class="built_in">end</span>());</span><br><span class="line">        anagrams[sorted].push_back(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p: anagrams) res.push_back(p.second);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没想到这道题还有<code>solution</code>,里面有两个方法，一个是用sort的，和上面的差不多。另一个有趣点，通过计数来生成一个新的字符串，然后在<code>hash</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList();</span><br><span class="line">    Map&lt;String, List&gt; ans = <span class="keyword">new</span> HashMap&lt;String, List&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (String s : strs) &#123;</span><br><span class="line">        Arrays.fill(count, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) count[c - <span class="string">'a'</span>]++;</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            sb.append(<span class="string">'#'</span>);</span><br><span class="line">            sb.append(count[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        String key = sb.toString();</span><br><span class="line">        <span class="keyword">if</span> (!ans.containsKey(key)) ans.put(key, <span class="keyword">new</span> ArrayList());</span><br><span class="line">        ans.get(key).add(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(ans.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Median Of Two Sorted Arrays</title>
      <link href="/2017/10/14/MedianOfTwoSortedArrays/"/>
      <url>/2017/10/14/MedianOfTwoSortedArrays/</url>
      
        <content type="html"><![CDATA[<p>第21天，尝试了一下<code>hard</code>，结果是完全没做出来。。。从早上8点多到11点半，一直没能AC，最后只好看<code>dicuss</code>中的解法了，然后理解还理解了很久。。。看了现在的我还不适合做<code>hard</code>级别的。</p><blockquote><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).<br>Example 1:<br>nums1 = [1, 3]<br>nums2 = [2]</p><p>The median is 2.0<br>Example 2:<br>nums1 = [1, 2]<br>nums2 = [3, 4]</p><p>The median is (2 + 3)/2 = 2.5</p></blockquote><p>因为没做出来，所以只能写写别人的思路了。</p><p>我们现在要找的是中位数，那么就有两种情况：</p><ul><li>整体长度是奇数，那么中位数是序列中的数</li><li>整体长度是偶数，那么中位数是序列中两个数的平均值。</li></ul><p>先考虑奇数的情况，因为是序列中的数，所以我们现在要求的就是在两个序列中第<code>（size)/2 + 1</code>大的数。</p><p>现在问题转换成在两个序列中求第k个数：</p><p>不断的将<code>k</code>减半，并把小的数从序列中排出，每次都能排出掉<code>k/2</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getKth</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums1,<span class="keyword">int</span> beg1,<span class="keyword">int</span> size1,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums2,<span class="keyword">int</span> beg2,<span class="keyword">int</span> size2,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; beg1&lt;&lt;" " &lt;&lt;size1&lt;&lt;"\t"&lt;&lt;beg2&lt;&lt;" "&lt;&lt;size2&lt;&lt;"\t"&lt;&lt;k&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span> (size1 &gt; size2) &#123;</span><br><span class="line">                <span class="keyword">return</span> getKth(nums2,beg2,size2,nums1,beg1,size1,k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size1 == <span class="number">0</span>) &#123; <span class="keyword">return</span> nums2[beg2 + k<span class="number">-1</span>];&#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">min</span>(nums1[beg1],nums2[beg2]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="built_in">min</span>(size1,k/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> j = <span class="built_in">min</span>(size2,k/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums1[beg1 + i<span class="number">-1</span>] &gt; nums2[beg2 + j<span class="number">-1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> getKth(nums1,beg1,size1,nums2,beg2+j,size2-j,k-j);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> getKth(nums1,beg1+i,size1-i,nums2,beg2,size2,k-i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>考虑偶数的情况，我们只要找出第<code>(size)/2 + 1</code>和<code>(size)/2</code>的大的数的平均值即可。</p><p>将两者统一一下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = (nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>() + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = (nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>() + <span class="number">2</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; "#" &lt;&lt; l &lt;&lt; r &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">double</span> dl = getKth(nums1,<span class="number">0</span>,nums1.<span class="built_in">size</span>(),nums2,<span class="number">0</span>,nums2.<span class="built_in">size</span>(),l); </span><br><span class="line">    <span class="keyword">double</span> dr = getKth(nums1,<span class="number">0</span>,nums1.<span class="built_in">size</span>(),nums2,<span class="number">0</span>,nums2.<span class="built_in">size</span>(),r);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; dl &lt;&lt;dr &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> (dr+dl)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>恩，等下次感觉有能力做了，在来尝试一次！！！</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Permutations</title>
      <link href="/2017/10/13/Permutations/"/>
      <url>/2017/10/13/Permutations/</url>
      
        <content type="html"><![CDATA[<p>第20天，第二次超级快的刷完了一道题。。。要不明天试试刷<code>hard</code></p><p>今天的题目是<a href="https://leetcode.com/problems/permutations/description/" target="_blank" rel="noopener">Permutations</a>,emmm,之前好像好几次都忘记加地址了。</p><blockquote><p>Given a collection of distinct numbers, return all possible permutations.<br>For example,<br>[1,2,3] have the following permutations:</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>总感觉之前遇到过类似的题目，然后思路也是很简单的，直接递归的做就好了：</p><p>这里如果不算是<code>push_back</code>中的拷贝数组，应该已经是拷贝数组次数最少的了，做的时候以为<code>push_back</code>不会拷贝，不过在<code>dicuss</code>中看的做法是只在<code>push_back</code>中进行拷贝。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ret;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//if (nums.size() == 0 || nums.size() == 1) return &#123;nums&#125;;</span></span><br><span class="line">    permute(nums,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> beg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() - beg &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        ret.push_back(nums);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    permute(nums,beg+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = beg+<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = nums;</span><br><span class="line">        swap(vec[beg],vec[i]);</span><br><span class="line">        permute(vec,beg+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dicuss</code>中的做法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; result;</span><br><span class="line"></span><br><span class="line">    permuteRecursive(num, <span class="number">0</span>, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// permute num[begin..end]</span></span><br><span class="line"><span class="comment">// invariant: num[0..begin-1] have been fixed/permuted</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permuteRecursive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;result)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">begin</span> &gt;= num.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// one permutation instance</span></span><br><span class="line">        result.push_back(num);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">begin</span>; i &lt; num.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        swap(num[<span class="built_in">begin</span>], num[i]);</span><br><span class="line">        permuteRecursive(num, <span class="built_in">begin</span> + <span class="number">1</span>, result);</span><br><span class="line">        <span class="comment">// reset</span></span><br><span class="line">        swap(num[<span class="built_in">begin</span>], num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他的做法和我一开始的时候类似，但是我没想到可以换回来。。。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Combination-Sum</title>
      <link href="/2017/10/12/Combination-Sum/"/>
      <url>/2017/10/12/Combination-Sum/</url>
      
        <content type="html"><![CDATA[<p>第19天</p><p>这道题是在起床到去上课前AC出来的，emmm，大概就10多分钟的样子。。。</p><p>虽然后来尝试优化了一下，但是感觉效果都不怎么好。。</p><p>题目描述：</p><blockquote><p>Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.</p><p>The same repeated number may be chosen from C unlimited number of times.</p><p>Note:</p><ul><li>All numbers (including target) will be positive integers.</li><li>The solution set must not contain duplicate combinations.</li></ul><p>For example, given candidate set [2, 3, 6, 7] and target 7,A solution set is: </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">7</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>其实想法很简单，我既然想求<code>combinationSum(7)</code>，通过遍历数组，我们现在有了一个<code>[2]</code>，我只需要在求<code>combinatiomSum(7-2)</code>即可，然后组合起来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cand;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ret;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    cand = candidates;</span><br><span class="line">    sort(cand.<span class="built_in">begin</span>(),cand.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; now;</span><br><span class="line">    combinationSumIter(now,<span class="number">0</span>,target);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combinationSumIter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;now,<span class="keyword">int</span> beg,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; "target" &lt;&lt; target &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = beg;i &lt; cand.<span class="built_in">size</span>();++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; cand[i])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target == cand[i]) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = now;</span><br><span class="line">            vec.push_back(cand[i]);</span><br><span class="line">            ret.push_back(vec);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target - cand[i] &gt;= cand[<span class="number">0</span>] )&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = now;</span><br><span class="line">            vec.push_back(cand[i]);</span><br><span class="line">            combinationSumIter(vec,i,target-cand[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>dicuss</code>中看到的也是类似的想法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">combinationSum</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; combination;</span><br><span class="line">        combinationSum(candidates, target, res, combination, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">combinationSum</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;candidates, <span class="keyword">int</span> target, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;res, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;combination, <span class="keyword">int</span> <span class="built_in">begin</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!target) &#123;</span><br><span class="line">            res.push_back(combination);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">begin</span>; i != candidates.<span class="built_in">size</span>() &amp;&amp; target &gt;= candidates[i]; ++i) &#123;</span><br><span class="line">            combination.push_back(candidates[i]);</span><br><span class="line">            combinationSum(candidates, target - candidates[i], res, combination, i);</span><br><span class="line">            combination.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Search for a Range</title>
      <link href="/2017/10/11/search-for-a-range/"/>
      <url>/2017/10/11/search-for-a-range/</url>
      
        <content type="html"><![CDATA[<p>第18天！！！</p><p>又是一道二分查找的题目：</p><blockquote><p>Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.</p><p>Your algorithm’s runtime complexity must be in the order of O(log n).</p><p>If the target is not found in the array, return [-1, -1].</p><p>For example,<br>Given [5, 7, 7, 8, 8, 10] and target value 8,<br>return [3, 4].</p></blockquote><p>时间复杂度要求为<code>O(logn)</code>,直接就暗示我们要用二分查找去做啊，但是这个又有限定条件，就是它需要求出范围，自然而然的就想到先用二分查找，然后从找到的点向两边去寻找边界。</p><p>相当简单的方法，但是如果遇到<code>1,2,2,2,2,2,2,2,3</code>这样的序列，就变成了<code>O(n)</code>的时间复杂度。</p><p>然后就可以自然而然的想到，做多两次二分查找,在序列<code>nums[0:mid]</code>中寻找左边界，<code>nums[mid:]</code>中寻找右边界，不然如果要是用二分查找的方法去做的话，就需要转换一下，我们找左边界的前一个元素，右边界的后一个元素，这样会方便一点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">0</span>,last = nums.<span class="built_in">size</span>() - <span class="number">1</span>,mid;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(first &lt;= last) &#123;</span><br><span class="line">        mid = (first + last)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) first = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> last = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l = mid,f = mid;</span><br><span class="line">    ret[<span class="number">0</span>] = first;</span><br><span class="line">    ret[<span class="number">1</span>] = last;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(first &lt;= l) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = (first + l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] == nums[mid])</span><br><span class="line">            l = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[m+<span class="number">1</span>] != nums[mid]) first = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ret[<span class="number">0</span>] = m+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(f &lt;= last) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = (f + last)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] == nums[mid]) f = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[m<span class="number">-1</span>] != nums[mid]) last = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ret[<span class="number">1</span>] = m - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个思路很简单，也很好实现，就是代码会复杂一点，三个循环其实长得差不多，但是你不能合并起来，所以换一种思路尝试一下：</p><p>我们找到一个与<code>target</code>相等的值<code>nums[mid]</code>，我们对<code>nums[0,mid-1]</code>再进行一次二分查找：</p><ul><li>如果查找失败， 那么说明当前mid就是左边界</li><li>如果找到了，我们就更新mid，再对<code>nums[0:mid-1]</code>进行查找，直到查找失败。</li></ul><p>对右边界做同样的事，我们就得到答案了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> mid = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>( (mid = searchRangeIter(nums,<span class="number">0</span>,mid<span class="number">-1</span>,target) ) != <span class="number">-1</span>) </span><br><span class="line">        ret[<span class="number">0</span>] = mid;</span><br><span class="line">    <span class="comment">//mid = -1;</span></span><br><span class="line">    <span class="keyword">while</span>( (mid = searchRangeIter(nums,mid+<span class="number">1</span>,nums.<span class="built_in">size</span>() - <span class="number">1</span>,target)) != <span class="number">-1</span>)</span><br><span class="line">        ret[<span class="number">1</span>] = mid;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchRangeIter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums,<span class="keyword">int</span> first,<span class="keyword">int</span> last,<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(first &lt;= last) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (first + last)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;  </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) first = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> last = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>dicuss</code>中看到一个更简洁的迭代的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(<span class="number">2</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// Search for the left one</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (i + j) /<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[mid] &lt; target) i = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> j = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (A[i]!=target) <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">else</span> ret[<span class="number">0</span>] = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Search for the right one</span></span><br><span class="line">    j = n<span class="number">-1</span>;  <span class="comment">// We don't have to set i to 0 the second time.</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (i + j) /<span class="number">2</span> + <span class="number">1</span>;<span class="comment">// Make mid biased to the right</span></span><br><span class="line">        <span class="keyword">if</span> (A[mid] &gt; target) j = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> i = mid;<span class="comment">// So that this won't make the search range stuck.</span></span><br><span class="line">    &#125;</span><br><span class="line">    ret[<span class="number">1</span>] = j;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Next-Permutation</title>
      <link href="/2017/10/10/Next-Permutation/"/>
      <url>/2017/10/10/Next-Permutation/</url>
      
        <content type="html"><![CDATA[<p>打卡，第17天</p><p>恩，又是一道有趣的题目，不知不觉刷了12道<code>Medium</code>级别的题目了，要不要找个时间试试<code>hard</code>的？？</p><blockquote><p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p><p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p><p>The replacement must be in-place, do not allocate extra memory.</p><p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.<br>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p></blockquote><p>我们再观察几个示例：</p><blockquote><p>1,2,5,4,3 -&gt; 1,3,2,4,5<br>1,3,2,5,4 -&gt; 1,3,4,2,5</p></blockquote><p>我们的目的是：让这个序列变大一点，显然从后向前考虑会比较容易得出结果。</p><p>对于<code>1,2,5,4,3</code>，观察序列的最后，我们可以发现<code>4,3</code>是降序的，我们要让整个序列变得大一点，显然如果只修改对于<code>5,4,3</code>这个序列的顺序，我们是没法让整个序列变大的，所以我们要引入下一个数字，但是<code>5,4,3</code>也是降序的，所以我们也无法只修改后三个数字来是的序列变大，但是如果考虑<code>2,5,4,3</code>，这个序列再变大一点就是<code>3,2,4,5</code>,如果多试几次的话，就可以找出规律了：</p><ul><li>我们从后向前找一个最长升序序列<code>nums[i:]</code></li><li>如果<code>i=0</code>，按照题目要求，我们就应该给出一个最小的组合，就直接对<code>nums</code>进行排序即可。</li><li>如果<code>i!=0</code>，那么我们从后向前找第一个比<code>nums[i-1]</code>大的数字<code>nums[k]</code>，而且我们肯定能找出。交换<code>nums[i-1]</code>和<code>nums[k]</code>,然后再对<code>nums[i:]</code>进行一个排序即可。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>;i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i<span class="number">-1</span>] &lt; nums[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> key = nums[i <span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = i;j &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[j] &gt; key;j++)</span><br><span class="line">                <span class="comment">/*do nothing*/</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; nums[j<span class="number">-1</span>] &lt;&lt;<span class="string">" "</span> &lt;&lt; nums[i<span class="number">-1</span>];</span><br><span class="line">            swap(nums[j<span class="number">-1</span>],nums[i<span class="number">-1</span>]);</span><br><span class="line">            sort(nums.<span class="built_in">begin</span>() + i,nums.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，时间复杂度是<code>O(nlogn)</code>了。其实我们要排序的序列，在某种程度上来说，他其实是降序的，我们只需要把降序换成升序即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = nums.<span class="built_in">size</span>() - <span class="number">1</span>;i &gt; <span class="number">0</span> &amp;&amp; nums[i<span class="number">-1</span>]&gt;= nums[i] ;i--)</span><br><span class="line">        <span class="comment">/*do nothing*/</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> first = i,last = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(first &lt;= last) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[last] &gt; nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            swap(nums[i<span class="number">-1</span>],nums[last]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[first+<span class="number">1</span>] &lt;= nums[i<span class="number">-1</span>] ) &#123;</span><br><span class="line">            swap(nums[i<span class="number">-1</span>],nums[first]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[first++],nums[last--]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(first &lt; last)</span><br><span class="line">        swap(nums[first++],nums[last--]);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以先对<code>nums[i:]</code>进行<code>reverse</code>,在找出第一个比<code>nums[i-1]</code>大的数和<code>nums[i-1]</code>进行交换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> i,j = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = nums.<span class="built_in">size</span>() - <span class="number">1</span>;i &gt; <span class="number">0</span> &amp;&amp; nums[i<span class="number">-1</span>]&gt;= nums[i] ;i--)</span><br><span class="line">        <span class="comment">/*do nothing*/</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> first = i,last = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(first &lt; last)</span><br><span class="line">        swap(nums[first++],nums[last--]);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> beg = nums.<span class="built_in">begin</span>() + i;</span><br><span class="line">        <span class="keyword">auto</span> it = lower_bound(beg,nums.<span class="built_in">end</span>(),nums[i<span class="number">-1</span>]);</span><br><span class="line">        <span class="comment">//cout &lt;&lt; *it &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">while</span> (*it == nums[i<span class="number">-1</span>])</span><br><span class="line">            it++;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; *it &lt;&lt; nums[i-1] &lt;&lt; endl;</span></span><br><span class="line">        swap(*it,nums[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>dicuss</code>中的都大同小异，所以就不贴<code>dicuss</code>中的算法了。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Search-in-Rotated-Sorted-Array</title>
      <link href="/2017/10/09/Search-in-Rotated-Sorted-Array/"/>
      <url>/2017/10/09/Search-in-Rotated-Sorted-Array/</url>
      
        <content type="html"><![CDATA[<p>打卡，第16天</p><p>失眠的感觉真难受。。。一天都想睡觉，但是却睡不着，sad。</p><blockquote><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p><p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p><p>You may assume no duplicate exists in the array.</p></blockquote><p>在有序的数组中进行查找，显然第一个想到的就是二分查找啦，不过题目给的数组是多了一个限定条件，就是这个数组被<code>rotated</code>了，所以，显然直接用二分查找是不行的。</p><p>观察<code>4 5 6 7 0 1 2</code>，我们可以发现如果我们可以找到<code>7</code>这个位置，我们就可以得到两个有序数组，可以进行二分查找，所以一个简单直观的想法就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[first] &gt; nums[last]) &#123;</span><br><span class="line">    <span class="keyword">while</span>(last &gt;= <span class="number">0</span> &amp;&amp; nums[first] &gt; nums[last] &amp;&amp; nums[last] &lt; target)</span><br><span class="line">        last--;</span><br><span class="line">    <span class="keyword">while</span>(first &lt;= last &amp;&amp;  nums[first] &gt; nums[last] &amp;&amp; nums[first] &gt; target)</span><br><span class="line">        first++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//binarySearch</span></span><br></pre></td></tr></table></figure><p>但是这样的时间复杂度就是<code>O(n)</code>了，显然不是我们想要的结果，我们可以对这个转折点进行一次二分查找：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[first] &gt; nums[last]) &#123;</span><br><span class="line">    <span class="keyword">int</span> f= first,l = last;</span><br><span class="line">    <span class="comment">//找转折点</span></span><br><span class="line">    <span class="keyword">while</span>(f &lt;= l) &#123;</span><br><span class="line">        mid = (f + l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[first]) f = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[last]) l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target &gt; nums[last]) last = mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[first]) first = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target == nums[first]) <span class="keyword">return</span> first;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//binary Serarch</span></span><br></pre></td></tr></table></figure><p>这样的时间复杂度就是<code>O(2*logn)</code>了。</p><p>完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">0</span>,last = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (last &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nums[first] &gt; nums[last]) &#123;</span><br><span class="line">        <span class="keyword">int</span> f= first,l = last;</span><br><span class="line">        <span class="comment">//找转折点</span></span><br><span class="line">        <span class="keyword">while</span>(f &lt;= l) &#123;</span><br><span class="line">            mid = (f + l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[first]) f = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[last]) l = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target &gt; nums[last]) last = mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[first]) first = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target == nums[first]) <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; first &lt;&lt; last;</span><br><span class="line">    <span class="comment">//binary search</span></span><br><span class="line">    <span class="keyword">while</span>(first &lt;= last) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (first + last)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) first = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> last = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过显然这不是最优的方法啦，毕竟要<code>O(2*logn)</code>,事实上只需要对二分查找进行修改，就可以直接运用了,恩，这是在<code>dicuss</code>中看到的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hi = A.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (A[lo] &lt;= A[mid]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target &gt;= A[lo] &amp;&amp; target &lt; A[mid]) &#123;</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (target &gt; A[mid] &amp;&amp; target &lt;= A[hi]) &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A[lo] == target ? lo : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Generate Parentheses</title>
      <link href="/2017/10/08/Generate-Parentheses/"/>
      <url>/2017/10/08/Generate-Parentheses/</url>
      
        <content type="html"><![CDATA[<p>打卡，第15天</p><p>今天做了一道比较好玩的题，之前有做个一个括号匹配的题目，今天的题目刚好反过来，不是验证括号是否正确，而是生成正确括号——<a href="https://leetcode.com/problems/generate-parentheses/description/" target="_blank" rel="noopener">Generate Parentheses</a>.</p><p>题目描述：</p><blockquote><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p><p>For example, given n = 3, a solution set is:</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">"((()))"</span>,</span><br><span class="line">  <span class="string">"(()())"</span>,</span><br><span class="line">  <span class="string">"(())()"</span>,</span><br><span class="line">  <span class="string">"()(())"</span>,</span><br><span class="line">  <span class="string">"()()()"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>再看看<code>n = 2</code>时：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="string">"(())"</span>,</span><br><span class="line">    <span class="string">"()()"</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>我们观察上面的例子，可以发现n=3,其实是由n=2加上一个<code>()</code>组合起来的，可以分成三种情况：</p><ul><li>在前面加上<code>()</code>,</li><li>在后面加上<code>()</code>,</li><li>在前面加上<code>(</code>后面加上<code>)</code></li></ul><p>我们大概可以写出这样的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> &#123;<span class="string">"()"</span>&#125;;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; r = generateParenthesis(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> s:r)&#123;</span><br><span class="line">        ret.insert(s+<span class="string">"()"</span>);</span><br><span class="line">        ret.insert(<span class="string">"()"</span> + s);</span><br><span class="line">        ret.insert(<span class="string">"("</span> + s + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;ret.<span class="built_in">begin</span>(),ret.<span class="built_in">end</span>()&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在<code>n &lt;= 3</code>时是ok的，但是如果<code>n = 4</code>还有一种可能，就是<code>(())(())</code>,这时由两个<code>n=2</code>的括号组合而成的，以及<code>n = 5</code>时，可以由<code>n = 3</code>和<code>n = 2</code>组合而成，也可以由<code>n = 1</code>和<code>n = 4</code>组合而成。</p><p>故我们可以做以下改进，得到正确答案：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> &#123;<span class="string">"()"</span>&#125;;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; r = generateParenthesis(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> s:r)&#123;</span><br><span class="line">        ret.insert(s+<span class="string">"()"</span>);</span><br><span class="line">        ret.insert(<span class="string">"()"</span> + s);</span><br><span class="line">        ret.insert(<span class="string">"("</span> + s + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n/<span class="number">2</span>;i &gt; <span class="number">1</span>;i--) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; r1 = generateParenthesis(n - i);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; r2 = generateParenthesis(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> s1:r1)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> s2:r2) &#123;</span><br><span class="line">                ret.insert(s1+s2);</span><br><span class="line">                ret.insert(s2+s1);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;ret.<span class="built_in">begin</span>(),ret.<span class="built_in">end</span>()&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，这里出现了很多次重复计算，可以用动态规划去做：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; par&#123;</span><br><span class="line">        &#123;<span class="string">""</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; now;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> s:par[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            now.insert(s + <span class="string">"()"</span>);</span><br><span class="line">            now.insert(<span class="string">"()"</span> + s);</span><br><span class="line">            now.insert(<span class="string">"("</span> + s + <span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = i - l;</span><br><span class="line">        <span class="keyword">while</span>(r &gt;= l) &#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> s1:par[l])</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> s2:par[r])&#123;</span><br><span class="line">                    <span class="comment">//cout &lt;&lt; s1 &lt;&lt; " " &lt;&lt; s2 &lt;&lt; endl;</span></span><br><span class="line">                    now.insert(s1+s2);</span><br><span class="line">                    now.insert(s2+s1);</span><br><span class="line">                &#125;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        par.push_back(&#123;now.<span class="built_in">begin</span>(),now.<span class="built_in">end</span>()&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> par[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是在<code>discuss</code>中看到的另一种思路：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    helper(<span class="string">""</span>, n, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  this hepler function insert result strings to "vector&lt;string&gt; result"</span></span><br><span class="line"><span class="comment">    When number of '(' less than "n", can append '(';</span></span><br><span class="line"><span class="comment">    When number of '(' is more than number of ')', can append ')';</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    string s : current string;</span></span><br><span class="line"><span class="comment">    int leftpare_need : number of '(' that have not put into "string s";</span></span><br><span class="line"><span class="comment">    int moreleft : number of '(' minus number of ')' in the "string s";</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> leftpare_need, <span class="keyword">int</span> moreleft)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(leftpare_need == <span class="number">0</span> &amp;&amp; moreleft == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result.push_back(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(leftpare_need &gt; <span class="number">0</span>)</span><br><span class="line">        helper(s + <span class="string">"("</span>, leftpare_need - <span class="number">1</span>, moreleft+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(moreleft &gt; <span class="number">0</span>)</span><br><span class="line">        helper(s + <span class="string">")"</span>, leftpare_need, moreleft - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个的想法是，不断的生成左括号，有左括号，后面就一定会生成一个右括号。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Remove Nth Node From End of List</title>
      <link href="/2017/10/07/Remove-Nth-Node-From-End-of-List/"/>
      <url>/2017/10/07/Remove-Nth-Node-From-End-of-List/</url>
      
        <content type="html"><![CDATA[<p>打卡，第14天</p><p>今天的题目是<a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/" target="_blank" rel="noopener">Remove Nth Node From End of List</a>,一开始以为是道很简单的题目，后来看<code>dicuss</code>时才发现是自己没看清题目。</p><blockquote><p>Given a linked list, remove the nth node from the end of list and return its head.</p><p>For example,<br>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</p><p>After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.<br>Note:<br>Given n will always be valid.<br>Try to do this in one pass.</p></blockquote><p>一开始没看到<code>Try to do this in one pass.</code>,然后就用两遍遍历方法去做了:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRightN</span><span class="params">(ListNode *head,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode *p = head;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="built_in">size</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span> - n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">ListNode <span class="title">h</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    h.next = head;</span><br><span class="line">    ListNode *p = &amp;h;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = getRightN(p,n);</span><br><span class="line">    <span class="keyword">while</span>(--k)</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line"></span><br><span class="line">    head = p-&gt;next;</span><br><span class="line">    p-&gt;next = head-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> head;</span><br><span class="line">    <span class="keyword">return</span> h.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个方法太简单了，还是看看在<code>dicuss</code>中的方法吧：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">removeNthFromEnd</span><span class="params">(ListNode *head, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode <span class="title">new_head</span><span class="params">(<span class="number">-1</span>)</span></span>;</span><br><span class="line">    new_head.next = head;</span><br><span class="line"></span><br><span class="line">    ListNode *slow = &amp;new_head, *fast = &amp;new_head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode *to_de_deleted = slow-&gt;next;</span><br><span class="line">    slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> to_be_deleted;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个看起来会比较简单，想法就是利用快慢指针去做，先让<code>fast</code>指针先走<code>n</code>步，然后在<code>fast</code>指针和<code>slow</code>指针一起移动，这样<code>fast</code>和<code>slow</code>始终保持着n个节点的距离，当<code>fast</code>为最后一个节点时，<code>slow</code>就指向倒数第n+1个节点，这时就可以把倒数第n个节点删掉了。</p><p>有一个更简洁的版本，不过有点难懂就是了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode** t1 = &amp;head, *t2 = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t2 = t2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(t2-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t1 = &amp;((*t1)-&gt;next);</span><br><span class="line">        t2 = t2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    *t1 = (*t1)-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个和上一个的思路其实是完全一样的，只是实现方法思路不一样就是，这里的<code>t1</code>是指向某个节点(包括一开始时虚拟的头结点）的<code>next</code>指针的指针。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Letter Combinations of a Phone Number</title>
      <link href="/2017/10/06/Letter-Combinations-of-a-Phone-Number/"/>
      <url>/2017/10/06/Letter-Combinations-of-a-Phone-Number/</url>
      
        <content type="html"><![CDATA[<p>打卡，第13天</p><p>昨晚贼晚睡，然后今天就快吃午饭才起来，然后我又躺尸了一个下午。。。</p><p>今天刷了一道<code>Medium</code>的题目——<a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/" target="_blank" rel="noopener"> Letter Combinations of a Phone Number</a>，不过感觉好水，就和学校oj一样水。。。</p><blockquote><p>Given a digit string, return all possible letter combinations that the number could represent.</p><p>A mapping of digit to letters (just like on the telephone buttons) is given below.<br>Input:Digit string “23”<br>Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].<br>Note:<br>Although the above answer is in lexicographical order, your answer could be in any order you want.</p></blockquote><p>恩，大概思路就是要求<code>letterCombinations(digits)</code>,我们就需要求<code>letterCombinations(digits.substr(0,n-1)</code>.</p><p>然后把这个思路转换迭代的方式就成了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCombinations</span><span class="params">(<span class="built_in">string</span> digits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; sMap &#123;<span class="string">""</span>,<span class="string">""</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">    <span class="keyword">if</span> (digits.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> ret;</span><br><span class="line">    ret.push_back(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; digits.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; now;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:sMap[digits[i] - <span class="string">'0'</span>]) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> s:ret)</span><br><span class="line">                now.push_back(s+c);</span><br><span class="line">        &#125;</span><br><span class="line">        ret.swap(now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路很简单，实现起来也很简单，没什么好提的，而且<code>dicuss</code>中的思路也很这个差不多，不过还是总结一下吧：</p><ul><li><p>c++ 中 <code>char</code>转<code>string</code>真心麻烦:</p><ul><li>用<code>stringstream</code>很优雅，但是也很麻烦，而且只适用于要平凡从尾部插入的情况,不过这个方法结合io可以做很多漂亮的转换</li><li>用<code>&quot;&quot; + c</code>,之前的时候用的时候好像是可以的，但是刚才在做题的时候是不行的会出现一些奇怪的字符串。</li><li>最后是比较简单，可以常用的方法：<code>string(1,c)</code>,可以把<code>1</code>换成其他数字以获取有重复字符的字符串。</li></ul></li><li><p>然后是在<code>dicuss</code>中看到的<code>vector</code>的<code>swap</code>方法，有些情况应该还是不错的，可以提高效率，它应该是直接交换底层指针。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Longest SubString with At Least K Repeating Characters</title>
      <link href="/2017/10/05/Longest-SubString-with-At-Least-K-Repeating-Characters/"/>
      <url>/2017/10/05/Longest-SubString-with-At-Least-K-Repeating-Characters/</url>
      
        <content type="html"><![CDATA[<p>打卡，第12天</p><p>今天刷的题目是<a href="https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/description/" target="_blank" rel="noopener">Longest Substring with At Least K Repeating Characters</a>:</p><blockquote><p>Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times.</p><p>Input:<br>s = “aaabb”, k = 3</p><p>Output:<br>3</p><p>The longest substring is “aaa”, as ‘a’ is repeated 3 times.</p><p>Input:<br>s = “ababbc”, k = 2</p><p>Output:<br>5</p><p>The longest substring is “ababb”, as ‘a’ is repeated 2 times and ‘b’ is repeated 3 times.</p></blockquote><p>本来是以为像<a href="https://wuxiaobai24.github.io/2017/10/01/LongestSubstringWithoutRepeatingCharacters/" target="_blank" rel="noopener">Longest Substring Without Repeating Characters</a>一样用两个下标去遍历，然后动态规划的去做（问题来了？动态规划是什么。。。我竟然还没有去翻，拖延症又犯了），一开始发现我可能需要在遍历前先知道当前字符是否会出现k次啊，恩，那就先用一个<code>unordered_map</code>去遍历一遍字符串来记录出现的次数吧：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; count;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c:s)</span><br><span class="line">    ++count[c];</span><br></pre></td></tr></table></figure><p>然后就开始思考什么时候<code>i</code>应该向前移动了，当<code>s[j]</code>出现的次数小于k时,<code>i</code>就应该变成<code>j+1</code>了，恩，这个时候我就应该计算<code>s[i,j]</code>的长度,显然不能直接是<code>j-i</code>来算长度啦，因为在以下情况时，它就失灵了：</p><blockquote><p>Input: s = “ababacb” k = 3</p></blockquote><p>如果直接<code>j-i</code>的话，就会得出5，但是显然在这个子串中，<code>b</code>只出现了两次，所以我们还要回去检查一遍，然后就开始想要怎么计算长度，大概需要一个下标<code>t</code>从<code>i</code>一直往<code>j</code>移动，遍移动遍计算，那么问题来了，我怎么知道什么时候<code>t</code>应该往前走，什么时候应该计算，恩，干脆先遍历一遍计算一下出现次数，然后我才能知道什么计算。。。突然发现有点不对，我好像写的代码是重复的，恩，按照这个逻辑一直走下去，好像我会一直递归这个过程，想了想就写成递归的形式吧，看起来好像就莫名其妙的写出了一个用分治法的解法了：</p><ul><li>先遍历一遍计算整个串中出现的次数</li><li>然后开始从头遍历，找出一个<code>t</code>使得<code>count[ s[t] ] &lt; k</code></li><li>找到了，我们就分别计算<code>s[i:t]</code>和s[<code>t+1:j]</code>的最大长度即可</li><li>没找到，那么说明整个串是符合的，我们直接返回串长度即可</li><li>递归结束的条件就是当串长度比k小的时候啦。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;   <span class="comment">//为了减少递归传递而设置的全局变量</span></span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(<span class="built_in">string</span> ss, <span class="keyword">int</span> tt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tt &lt;= <span class="number">1</span>) <span class="keyword">return</span> ss.<span class="built_in">size</span>();</span><br><span class="line">    s = ss;</span><br><span class="line">    t = tt;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; count;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)</span><br><span class="line">        ++count[c];</span><br><span class="line">    <span class="keyword">return</span> longestSubString(<span class="number">0</span>,s.<span class="built_in">size</span>(),count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestSubString</span><span class="params">(<span class="keyword">int</span> beg,<span class="keyword">int</span> <span class="built_in">end</span>,<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; &amp;imap )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">end</span> - beg &lt; t) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(j = beg;j &lt; <span class="built_in">end</span> &amp;&amp; imap[s[j]] &gt;= t;j++)</span><br><span class="line">        <span class="comment">/*do nothing*/</span>;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="built_in">end</span>) <span class="keyword">return</span> <span class="built_in">end</span> - beg;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; right;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = beg;k &lt; j;k++)&#123;</span><br><span class="line">        --imap[ s[k] ];<span class="comment">//重复利用imap，减少空间复杂度</span></span><br><span class="line">        ++right[ s[k] ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(longestSubString(beg,j,right),</span><br><span class="line">                longestSubString(j+<span class="number">1</span>,<span class="built_in">end</span>,imap));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一点要注意的就是：如果是使用<code>map</code>而不是<code>unordered_map</code>的话，时间是会超限的。</p><p>然后是在<code>dicuss</code>中看到的解法：</p><p>下面这个的解法和我的类似，他的会比较简洁，不过应该没我的快，因为他每次都需要递归都是直接传递string的，而且调用<code>s.substr</code>其实挺耗费时间的，应该每次都是深拷贝。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">0</span> || k &gt; s.<span class="built_in">size</span>())   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)  <span class="keyword">return</span> s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; Map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            Map[s[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(idx &lt;s.<span class="built_in">size</span>() &amp;&amp; Map[s[idx]] &gt;= k)    idx++;</span><br><span class="line">        <span class="keyword">if</span>(idx == s.<span class="built_in">size</span>()) <span class="keyword">return</span> s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> left = longestSubstring(s.substr(<span class="number">0</span> , idx) , k);</span><br><span class="line">        <span class="keyword">int</span> right = longestSubstring(s.substr(idx+<span class="number">1</span>) , k);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left, right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第二个是用迭代的方法做的，比较快点，但是好像最坏情况是会出现<code>O(n^2)</code>的时间复杂度：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> first = <span class="number">0</span>; first+k &lt;= s.<span class="built_in">size</span>();) &#123;</span><br><span class="line">       <span class="keyword">int</span> count[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">       <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> max_last = first;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> last = first; last &lt; s.<span class="built_in">size</span>(); ++last) &#123;</span><br><span class="line">           <span class="keyword">int</span> i = s[last] - <span class="string">'a'</span>;</span><br><span class="line">           count[i]++;</span><br><span class="line">           <span class="keyword">if</span> (count[i]&lt;k) mask |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">           <span class="keyword">else</span>   mask &amp;= (~(<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span> (mask == <span class="number">0</span>) &#123;</span><br><span class="line">               max_len = <span class="built_in">max</span>(max_len, last-first+<span class="number">1</span>);</span><br><span class="line">               max_last = last;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       first = max_last + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> max_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Characters</title>
      <link href="/2017/10/05/Characters/"/>
      <url>/2017/10/05/Characters/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>4Sum_2</title>
      <link href="/2017/10/04/4Sum-2/"/>
      <url>/2017/10/04/4Sum-2/</url>
      
        <content type="html"><![CDATA[<p>打卡,第11天。</p><p>今天刷的题是<a href="https://leetcode.com/problems/4sum-ii/description/" target="_blank" rel="noopener">4Sum II</a>,</p><blockquote><p>Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.</p><p>To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -2^28 to 2^28 - 1 and the result is guaranteed to be at most 2^31 - 1.</p><p>Example:</p><p>Input:A = [ 1, 2]<br>B = [-2,-1]<br>C = [-1, 2]<br>D = [ 0, 2]<br>Output:<br>2</p><p>Explanation:</p><p>The two tuples are:</p><p>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</p><p>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</p></blockquote><p>这道题如果贼容易写出一个时间超限的题目，比如简单的四重循环。</p><p>一开始老是会出现时间超限的情况，想着要把时间复杂度将下来，就想着把他转换成2Sum去做，于是就用就先把<code>A</code>和<code>B</code>的和放在一个<code>vector</code>中，同理也把<code>C</code>和<code>D</code>的和放在一个<code>vector</code>中。天真的以为这样就可以把时间复杂度降下来了。。。然而这两个vector的大小分别是<code>A.size()*B.size()</code>和<code>C.size()*D.size()</code>,然后一直没想出来怎么搞，突然想起来昨天在《像程序员一样思考》中看到的<strong>削减问题</strong>的方法，就开始考虑两个数组的的情况。</p><p>显然如果不对数组进行排序的话，肯定是要用两个循环对所有元素遍历的，然后就考虑如果数组是排好序的话，要怎么才能减少一些不必要的遍历，如果一个较小的数一定需要一个较大的数才能使得和为0，所以一个数组从前向后遍历，一个数组从后向前进行遍历。因为数组已经有序了，所以第一个数组越前面的元素（越小）就需要第二个数组越后面的的元素（越大），可以找到一下规律：</p><ul><li>sum &gt; 0 -&gt; j–</li><li>sum &lt; 0 -&gt; i++</li><li>sum == 0 -&gt; count++;j–,i++</li></ul><p>当然如果直接这样写的话可能会漏掉一些重复元素，所以还需要一些修改,但是大体的思路已经出来了，所以直接上代码把：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; C, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; D)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    vector&lt;int&gt; v1 (A.size()*B.size() ), v2(C.size()*D.size());</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:C)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> d:D)</span><br><span class="line">            v2[k++] = c+d;</span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> a:A)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> b:B)</span><br><span class="line">            v1[k++] = a+b;</span><br><span class="line">    sort(v1.<span class="built_in">begin</span>(),v1.<span class="built_in">end</span>());</span><br><span class="line">    sort(v2.<span class="built_in">begin</span>(),v2.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>,j = v2.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; v1.<span class="built_in">size</span>() &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        sum = v1[i] + v2[j];</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; <span class="number">0</span>)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> k1 = <span class="number">1</span>,k2 = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//处理重复元素的情况</span></span><br><span class="line">            <span class="keyword">while</span>(i + <span class="number">1</span>&lt; v1.<span class="built_in">size</span>() &amp;&amp; v1[i + <span class="number">1</span> ] == v1[i])&#123; k1++; i++; &#125;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; v2[j<span class="number">-1</span>] == v2[j]) &#123; k2++; j--; &#125;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">            count += k1*k2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是看看<code>dicuss</code>中别人的解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; C, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; D)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;  abSum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> a : A) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> b : B) &#123;</span><br><span class="line">            ++abSum[a+b];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : C) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> d : D) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = abSum.<span class="built_in">find</span>(<span class="number">0</span> - c - d);</span><br><span class="line">            <span class="keyword">if</span>(it != abSum.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                count += it-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他使用<code>unordered_map</code>来完成的耶,在c++的STL中，<code>map</code>是用的红黑树，<code>find</code>的时间复杂度是<code>O(nlogn)</code>,而<code>unordered_map</code>是<code>hash table</code>,所以<code>find</code>的时间复杂度是<code>O(1)</code>，突然发现一个好用的东西。。。</p><hr><p>貌似今天是中秋，恩，中秋快乐！！</p><p>可惜喉咙发炎没法吃月饼。。。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LongestPalindromicSubString</title>
      <link href="/2017/10/03/LongestPalindromicSubString/"/>
      <url>/2017/10/03/LongestPalindromicSubString/</url>
      
        <content type="html"><![CDATA[<p>打卡，第10天</p><p>今天刷的题是<a href="https://leetcode.com/problems/longest-palindromic-substring/description/" target="_blank" rel="noopener">Longest Palindromic Substring</a>,开始想着用动态规划做，但是我好像连动态规划是什么我都不知道。。。</p><p>题目:</p><blockquote><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p><p>Example:</p><p>Input: “babad”</p><p>Output: “bab”</p><p>Note: “aba” is also a valid answer.<br>Example:</p><p>Input: “cbbd”</p><p>Output: “bb”</p></blockquote><p>所以一如既往的想到了分治法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> &amp;s,<span class="keyword">int</span> first,<span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(first &lt; last &amp;&amp; s[first] == s[last])&#123;</span><br><span class="line">        first++;</span><br><span class="line">        last--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (first &gt;= last) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retF,retL;</span><br><span class="line">    <span class="keyword">int</span> l = longestPalindrome(s,<span class="number">0</span>,s.<span class="built_in">size</span>() <span class="number">-1</span> ,retF);</span><br><span class="line">    <span class="keyword">return</span> s.substr(retF,l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> &amp;s,<span class="keyword">int</span> first,<span class="keyword">int</span> last,<span class="keyword">int</span> &amp;retF)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first &lt; last)&#123;</span><br><span class="line">        <span class="keyword">int</span> lF,rF,mF;</span><br><span class="line">        <span class="keyword">int</span> mid = (first + last)/<span class="number">2</span>;   <span class="comment">//分</span></span><br><span class="line">        <span class="comment">//治</span></span><br><span class="line">        <span class="keyword">int</span> l = longestPalindrome(s,first,mid,lF);</span><br><span class="line">        <span class="keyword">int</span> r = longestPalindrome(s,mid + <span class="number">1</span>,last,rF);</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="built_in">max</span>(l,r);</span><br><span class="line">        <span class="comment">//合，已知</span></span><br><span class="line">        <span class="keyword">int</span> midMax = ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = first;i &lt;=mid ;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = mid + <span class="number">1</span>;j &lt;= last;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (j-i +<span class="number">1</span> &gt; midMax &amp;&amp; isPalindrome(s,i,j))&#123;</span><br><span class="line">                    midMax = j-i+<span class="number">1</span>;</span><br><span class="line">                    mF = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (midMax &gt; ret)&#123;</span><br><span class="line">            retF = mF;</span><br><span class="line">            <span class="keyword">return</span> midMax;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == l)&#123;</span><br><span class="line">            retF = lF;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            retF = rF;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (first == last ) &#123;</span><br><span class="line">        retF = first;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        retF = first;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概的思路是：</p><ul><li>先用分治法将问题规模不断减半，那么现在只需要考虑如何“合”了</li><li>这里”合”的时间复杂度是O(n^2)，没能找出更快的，嗯，不对，好像是O(n^3)….</li><li>whatever，这里的合就是用穷举法去做的，不过不知道为什么还是过了测试</li></ul><p>然后是<code>dicuss</code>中的解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.empty()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">int</span> min_start = <span class="number">0</span>, max_len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>();) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s.<span class="built_in">size</span>() - i &lt;= max_len / <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">int</span> j = i, k = i;</span><br><span class="line">      <span class="keyword">while</span> (k &lt; s.<span class="built_in">size</span>()<span class="number">-1</span> &amp;&amp; s[k+<span class="number">1</span>] == s[k]) ++k; <span class="comment">// Skip duplicate characters.</span></span><br><span class="line">      i = k+<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (k &lt; s.<span class="built_in">size</span>()<span class="number">-1</span> &amp;&amp; j &gt; <span class="number">0</span> &amp;&amp; s[k + <span class="number">1</span>] == s[j - <span class="number">1</span>]) &#123; ++k; --j; &#125; <span class="comment">// Expand.</span></span><br><span class="line">      <span class="keyword">int</span> new_len = k - j + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (new_len &gt; max_len) &#123; min_start = j; max_len = new_len; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substr(min_start, max_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>emmm,这里好像也是用点穷举的感觉。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 串 </tag>
            
            <tag> 分治法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maximum Product Subarray</title>
      <link href="/2017/10/02/MaximumProductSubarray/"/>
      <url>/2017/10/02/MaximumProductSubarray/</url>
      
        <content type="html"><![CDATA[<p>打卡，第9天</p><p>今天这道题做了好久。。。</p><blockquote><p>Find the contiguous subarray within an array (containing at least one number) which has the largest product.</p><p>For example, given the array [2,3,-2,4],<br>the contiguous subarray [2,3] has the largest product = 6.</p></blockquote><p>看到这道题，就让我想起了昨天做得那道<a href="https://wuxiaobai24.github.io/2017/10/01/LongestSubstringWithoutRepeatingCharacters/" target="_blank" rel="noopener">Longest Substring Without Repeating Characters</a>。</p><p>看起来很像是同一类的题目，想着用同一种方法去做，然后就考虑了好多奇奇怪怪的情况，最后代码写的及其混乱。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = INT_MIN;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(now &lt; <span class="number">0</span> &amp;&amp; i &lt; j <span class="number">-1</span>)</span><br><span class="line">                now /= nums[i++];</span><br><span class="line">            ret = <span class="built_in">max</span>(ret,now);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) ret = <span class="number">0</span>;</span><br><span class="line">            now = <span class="number">0</span>;</span><br><span class="line">            i = j+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            now = (now)?now*nums[j]:nums[j];</span><br><span class="line">            ret = <span class="built_in">max</span>(ret,now);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(now &lt; <span class="number">0</span> &amp;&amp; i &lt; j - <span class="number">1</span>)</span><br><span class="line">        now /= nums[i++];</span><br><span class="line">    ret = <span class="built_in">max</span>(ret,now);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这还是做完后进行了一些删减的答案，看起来很复杂，要我现在去解释它都有点困难。</p><p>先提提我的思路：</p><ul><li><p>和昨天的一样，我用两个下标来标识当前<code>Subarray</code>,也就是说，然后让<code>j</code>不断向前去遍历。</p></li><li><p>我需要考虑的就是什么时候<code>i</code>向前，我的想法是：</p><blockquote><p>当我们遇到一个0时，我们需要把i改成j+1,因为正常情况下<code>Subarray</code>中如果有个<code>0</code>，那么<code>Subarray</code>的乘积就必定是0，为什么说是正常情况呢，因为如果当前最大乘积小于0的话，那么我们遇到一个<code>0</code>，要把最大乘积改成<code>0</code>.</p></blockquote></li><li><p>但是如果我们遇到这样的数组<code>2 -1 4 0</code>,我们当前的策略的返回值是<code>2</code>，但真正应该是4，因此另一个<code>i</code>向前的情况是：</p><blockquote><p>遇到一个<code>0</code>或遍历完整个数组，我们需要让<code>i</code>向前移动，直到让当前乘积变成大于0，或者到达<code>j</code>。</p></blockquote></li></ul><p>最后将这一大段思路变成代码就成了我上面写的了，其实仔细想想，这些思路其实并不复杂，只是有点繁琐，如果心能静点的话，应该可以更快的AC掉这道题。</p><p>下面是<code>dicuss</code>中的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// store the result that is the max we have found so far</span></span><br><span class="line">    <span class="keyword">int</span> r = A[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// imax/imin stores the max/min product of</span></span><br><span class="line">    <span class="comment">// subarray that ends with the current number A[i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, imax = r, imin = r; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// multiplied by a negative makes big number smaller, small number bigger</span></span><br><span class="line">        <span class="comment">// so we redefine the extremums by swapping them</span></span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt; <span class="number">0</span>)</span><br><span class="line">            swap(imax, imin);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// max/min product for the current number is either the current number itself</span></span><br><span class="line">        <span class="comment">// or the max/min by the previous number times the current one</span></span><br><span class="line">        imax = <span class="built_in">max</span>(A[i], imax * A[i]);</span><br><span class="line">        imin = <span class="built_in">min</span>(A[i], imin * A[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the newly computed max value is a candidate for our global result</span></span><br><span class="line">        r = <span class="built_in">max</span>(r, imax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把注释去掉话，其实没几句话，说实话，第一次看没看懂，分析一下他的思路：</p><ul><li><p>同样是遍历，但是它维护的不是下标，而是在A[0:j]中的子数组的最大值imax和子数组最小值imin.</p></li><li><p>他用的是减治法，大概的想法是，我们知道A[0:n-1]imax和imin，我们如果求出A[0:n]的<code>imax,imin</code>。</p><ul><li>如果<code>A[n]&gt;=0</code>,那么<code>imax = max(A[n],imax*A[n]);imin = min(A[n],imin*A[n])</code></li><li>如果<code>A[n] &lt; 0</code>，那么<code>imin = min(A[n],imax*A[n]);imax = max(A[n],imin*A[n])</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VBO_and_VAO.md</title>
      <link href="/2017/10/01/VBO-and-VAO-md/"/>
      <url>/2017/10/01/VBO-and-VAO-md/</url>
      
        <content type="html"><![CDATA[<p>最近在写计算机图形学的期中作业，写一个简易的俄罗斯方块。在写的过程中感觉好像之前暑假看的<code>OpenGL</code>的东西都忘光光了，所以还是及时的写写笔记吧！</p><blockquote><p>顶点数组对象： Vertex Array Object,vao</p><p>顶点缓冲对象：Vertex Buffer Object,vbo</p></blockquote><p>在敲代码的时候就觉得老是会搞混这两个概念，所以今天就总结一下。</p><p>先来段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> VERTICES_NUM = <span class="number">3</span>;</span><br><span class="line">    vec3 vertices[VERTICES_NUM] = &#123;</span><br><span class="line">        &#123;<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0.0</span>,<span class="number">1.0</span>,<span class="number">0.0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GLuint vao[<span class="number">1</span>];</span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>,vao);</span><br><span class="line">    glBindVertexArray(vao[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    GLuint <span class="built_in">buffer</span>;</span><br><span class="line">    glGenBuffers(<span class="number">1</span>,&amp;<span class="built_in">buffer</span>);</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, <span class="built_in">buffer</span>);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices),vertices,CL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    GLuint program = InitShader(<span class="string">"vshader.glsl"</span>,<span class="string">"fshader.glsl"</span>);</span><br><span class="line">    glUseProgram(program);</span><br><span class="line"></span><br><span class="line">    GLuint location = glGetAttribLocation(program,<span class="string">"vPosition"</span>);</span><br><span class="line">    glEnableVertexAttribArray(location);</span><br><span class="line">    glVertexAttribPointer(location,<span class="number">3</span>,GL_FLOAT,GL_FALSE,<span class="number">0</span>,BUFFER_OFFSET(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    glClearColor(<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OpenGL里的对象都是通过<code>id</code>来管理的,有的地方叫做名字，或者说标识符，whatever,我们在这里统一用id。我们需要用<code>glGen*</code>模式的函数来获取未使用的id，这里的id可以想成是指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GLuint vao[<span class="number">1</span>];                  <span class="comment">//用来存放id的数组</span></span><br><span class="line">glGenVertexArrays(<span class="number">1</span>,vao);       <span class="comment">//获取id，第一个参数是想要获取的个数</span></span><br><span class="line">                                <span class="comment">//第二个参数是存放这些id的数组</span></span><br></pre></td></tr></table></figure><p>现在我们有了顶点数组对象的<code>id</code>了（换句话说，我们有了一个可以存放地址的指针），我们就需要真正的<code>new</code>一个对象出来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glBindVertexArray(vao);</span><br></pre></td></tr></table></figure><ul><li>如果vao非0，并且是<code>glGenVertexArrays()</code>返回的，那么它创建一个新的顶点数组，并且==并且与其名称向关联==</li><li>如果vao已经被绑定到一个顶点数组对象中，那么这个函数的作用就是激活这个顶点数组。</li><li>如果为0，那么OpenGL将不再使用程序所分配的顶点数组对象，并且OpenGL状态将重设为顶点数组的默认状态。</li></ul><p>第一个很好理解就是等价于<code>new</code>,第二个作用可以理解为根据<code>id</code>获取对象（对指针解引用），第三个作用是在每次对某个顶点数组对象操作完后对当前顶点数组对象进行解绑。</p><p>有<code>new</code>就会有<code>delete</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//void glDeleteVertexArray(GLsizei n,GLuint *arrays);</span></span><br><span class="line">glDeleteVertexArray(<span class="number">1</span>,vao);</span><br></pre></td></tr></table></figure><p>我们还可以判断一个<code>id</code>是否是一个用<code>glGenVertexArray()</code>创建并且没有被删除的顶点数组对象的<code>id</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GLboolean <span class="title">glIsVertexArray</span><span class="params">(GLuint <span class="built_in">array</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>现在我们已经有一个vao了，但是我们好像还不知道vao有什么用，要回答这个问题，我们还需要一些其他的背景知识，所以这个问题放到后面再回答。</p><p>我们之所以需要VAO与VBO是因为我们想要把某些顶点数组发送给图像渲染pipeline，而pipleline需要接受一些Vertex Data,然后再进行一些变换或修改并渲染。</p><p><img src="https://learnopengl-cn.github.io/img/01/04/pipeline.png" alt=""></p><p>我们在定义了顶点数据之后，我们需要把他发送给顶点着色器，我们的顶点数据通常是放在GPU的内存中的，我们利用顶点缓冲对象(vertext buffer objects,vbo)进行管理</p><p>vbo也有相应的函数进行申请<code>id</code>，绑定等等，与vao类似：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glGenBuffers</span><span class="params">(GLsizei n,GLuint *buffers)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glBindBuffers</span><span class="params">(GLenum traget,GLuint <span class="built_in">buffer</span>)</span></span>;</span><br><span class="line"><span class="comment">//target 的值可以为：</span></span><br><span class="line"><span class="comment">//      GL_ARRAY_BUFFER</span></span><br><span class="line"><span class="comment">//      GL_ELEMENT_ARRAY_BUFFER</span></span><br><span class="line"><span class="comment">//      ...</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glDeleteBuffers</span><span class="params">(GLsizei n,<span class="keyword">const</span> GLuint *buffers)</span></span>;</span><br><span class="line"><span class="function">GLboolean <span class="title">glIsBuffers</span><span class="params">(GLuint <span class="built_in">buffer</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>在申请完<code>id</code>并绑定后，我们可以想GPU的内存发送数组:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glBufferData</span><span class="params">(GLenum target,GLsizeiptr <span class="built_in">size</span>,cons GLvoid *data,GLenum usage)</span></span>;</span><br><span class="line"><span class="comment">//target 与上面glBindBuffers的类似，</span></span><br><span class="line"><span class="comment">//usage 是设置读取和写入的方式</span></span><br><span class="line"><span class="comment">//      GL_STREAM_DRAM</span></span><br><span class="line"><span class="comment">//      GL_DYNAMICDRAM</span></span><br><span class="line"><span class="comment">//      ...</span></span><br></pre></td></tr></table></figure><p>在我们向GPU内存中发送完数据后，我们可能需要告诉OpenGL如何解释我们的数据:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GLuint location = glGetAttribLocation(program,<span class="string">"vPosition"</span>);</span><br><span class="line">glEnableVertexAttribArray(location);</span><br><span class="line">glVertexAttribPointer(location,<span class="number">3</span>,GL_FLOAT,GL_FALSE,<span class="number">0</span>,BUFFER_OFFSET(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>我们先要向着色器程序获取顶点属性的位置值，即<code>GLuint location = glGetAttribLocation(program,&quot;vPosition&quot;);</code>我们应该可以在<code>vshader.glsl</code>中看到这样一句话<code>in vec3 vPosition</code>,他表示的是我们会给他一个类型为vec3的输入值，而<code>glGetAttribLocation</code>可以获取这个输入值的位置，这样我们才可以把我们的数据和这里的<code>vPosition</code>绑定起来。</p><p><code>glEnableVertexAttribArray(location)</code>启用顶点属性（默认是禁用的)</p><p>而<code>glVertexAttribPointer(location,3,GL_FLOAT,GL_FALSE,0,BUFFER_OFFSET(0));</code>才是真正告诉OpenGL如何解释的函数。</p><p>他的参数解释分别为：</p><ul><li>顶点属性的位置值</li><li>顶点属性大小，因为我们传入的是<code>vec3</code>,所以是3</li><li>数组类型</li><li>是否归一化</li><li>两个元素之间的偏移值</li><li>起始位置地址</li></ul><p>有了这些东西，我们就可以绘制某个物体了，但是如果我们需要绘制多个物体呢，这时VAO的作用就出来了。</p><p>如果我们只使用VBO，我们可能需要重复的调用<code>glVertexAttribPointer</code>等。</p><p>我们可以通过VAO来管理这些琐碎的设置，一个VAO会存储以下内容：</p><ul><li><code>glEnableVertexAttribArray</code>和<code>glDisableVertexAttribArray</code>的调用。</li><li>通过<code>glVertexAttribPointer</code>设置的顶点属性配置。</li><li>通过<code>glVertexAttribPointer</code>调用与顶点属性关联的顶点缓冲对象。</li></ul><p>有了vao后，我们只需要在每次绘制前<code>glBindVertexArray(vao)</code>即可。</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
            <tag> note </tag>
            
            <tag> 计算机图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>quickSort效率分析以及改进</title>
      <link href="/2017/10/01/quickSort%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E6%94%B9%E8%BF%9B/"/>
      <url>/2017/10/01/quickSort%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E6%94%B9%E8%BF%9B/</url>
      
        <content type="html"><![CDATA[<p>终于找到时间来写这个了。</p><p>上半个月一直在做算法课的实验，实验的大概内容是实现几个基本的排序算法，分别用不同的规模去测试然后进行分析。</p><p>恩，当然现在我只想扯扯快排。</p><p>先放段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;  <span class="comment">//注意待排序列为: a[first,last]</span></span><br><span class="line">    <span class="keyword">if</span> (first &lt; last) &#123;                         <span class="comment">//递归结束条件：first &gt;= last</span></span><br><span class="line">        <span class="keyword">int</span> mid = partition(a,first,last);      <span class="comment">//找出枢点</span></span><br><span class="line">        quicksort(a, first, q1 - <span class="number">1</span>);</span><br><span class="line">        quicksort(a, q2 + <span class="number">1</span>, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;                <span class="comment">//O(last-first + 1)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> key = a[first];</span><br><span class="line">    <span class="keyword">while</span> (first &lt; last) &#123;</span><br><span class="line">        <span class="comment">//在两个循环中，当last在动时，first所指向的元素是多余的，反之亦然。</span></span><br><span class="line">        <span class="comment">//所以当first和last指向同一个元素时，这个元素显然是多余的，而这个位置就是key最后的位置。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (first &lt; last &amp;&amp; a[last] &gt;= key) last--;      <span class="comment">//注意要满足的是x &lt;= k &lt;= y</span></span><br><span class="line">        a[first] = a[last];</span><br><span class="line">        <span class="keyword">while</span> (first &lt; last &amp;&amp; a[first] &lt;= key) first++;    <span class="comment">//如果内层循环中的条件缺少=，会出现死循环。</span></span><br><span class="line">        a[last] = a[first];</span><br><span class="line">    &#125;</span><br><span class="line">    a[first] = key;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是测出的数据和利用比值的方法（基准是n=100000）计算的出来的理论值（单位是ms):</p><p><img src="http://olrv1mriz.bkt.clouddn.com/blog/171001/Hac36HaC9h.png?imageslim" alt="mark"></p><p>画成散点图：</p><p><img src="http://olrv1mriz.bkt.clouddn.com/blog/171001/l346eJD289.png?imageslim" alt="mark"></p><p>由于n的差距过大，导致大部分点看不清，所以进行对数化在进行绘图：</p><p><img src="http://olrv1mriz.bkt.clouddn.com/blog/171001/lLhkC8K650.png?imageslim" alt="mark"></p><p>从前面的数据我们可以发现快排时间复杂度是<code>O(nlogn)</code>，但是他其实是不稳定的。</p><p>我们向排序算法喂入一些比较极端的数据：</p><p><img src="http://olrv1mriz.bkt.clouddn.com/blog/171001/F37kHbFCK4.png?imageslim" alt="mark"></p><p><img src="http://olrv1mriz.bkt.clouddn.com/blog/171001/F0DIkchF6E.png?imageslim" alt="mark"></p><p>快排有一个比较奇葩的特性就是序列越乱越快。</p><p>我们对原来的算法进行一些改进：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;                <span class="comment">//O(last-first + 1)</span></span><br><span class="line"></span><br><span class="line">    swap(a[first],a[ rand() % (last - first + <span class="number">1</span>) ]);        <span class="comment">//让key的选取随机化</span></span><br><span class="line">    <span class="keyword">int</span> key = a[first];</span><br><span class="line">    <span class="keyword">while</span> (first &lt; last) &#123;</span><br><span class="line">        <span class="comment">//在两个循环中，当last在动时，first所指向的元素是多余的，反之亦然。</span></span><br><span class="line">        <span class="comment">//所以当first和last指向同一个元素时，这个元素显然是多余的，而这个位置就是key最后的位置。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (first &lt; last &amp;&amp; a[last] &gt;= key) last--;      <span class="comment">//注意要满足的是x &lt;= k &lt;= y</span></span><br><span class="line">        a[first] = a[last];</span><br><span class="line">        <span class="keyword">while</span> (first &lt; last &amp;&amp; a[first] &lt;= key) first++;    <span class="comment">//如果内层循环中的条件缺少=，会出现死循环。</span></span><br><span class="line">        a[last] = a[first];</span><br><span class="line">    &#125;</span><br><span class="line">    a[first] = key;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进后，快排的在遇到顺序和倒序的序列时就不会出现最坏情况了：</p><p><img src="http://olrv1mriz.bkt.clouddn.com/blog/171001/ebBLA1FIk4.png?imageslim" alt="mark"></p><p>但是对于重复序列，这个算法仍然不能很好的解决。</p><p>在《算法导论》快排那一章的习题中有提到一个算法去解决这种情况，大概的想法是每次<code>分</code>的时候把序列分成三个区域，第一个区域是小于key的值，第二个区域是等于key的值，第三个区域是大于key的值，这样遇到大量重复元素的时候，partition能够很好处理这种情况。</p><p>但是看完这个算法就想着实现以下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> first, <span class="keyword">int</span> last, <span class="keyword">int</span> &amp;q1, <span class="keyword">int</span> &amp;q2)</span> </span>&#123;</span><br><span class="line">    swap(a[first], a[first + rand() % (last - first + <span class="number">1</span>)]);<span class="comment">//使得轴点的选取随机化，减少最坏情况的出现的概率</span></span><br><span class="line">    q1 = first;</span><br><span class="line">    q2 = last;</span><br><span class="line">    <span class="keyword">int</span> key = a[first];</span><br><span class="line">    <span class="keyword">while</span> (q1 &lt; q2) &#123;</span><br><span class="line">        <span class="comment">//在两个循环中，当last在动时，first所指向的元素是多余的，反之亦然。</span></span><br><span class="line">        <span class="comment">//所以当first和last指向同一个元素时，这个元素显然是多余的，而这个位置就是key最后的位置。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (q1 &lt; q2 &amp;&amp; a[q2] &gt;= key) q2--;   <span class="comment">//注意要满足的是x &lt;= k &lt;= y</span></span><br><span class="line">        a[q1] = a[q2];</span><br><span class="line">        <span class="keyword">while</span> (q1 &lt; q2 &amp;&amp; a[q1] &lt;= key) q1++;   <span class="comment">//如果内层循环中的条件缺少=，会出现死循环。</span></span><br><span class="line">        a[q2] = a[q1];</span><br><span class="line">    &#125;</span><br><span class="line">    a[q1] = key;</span><br><span class="line">    <span class="keyword">while</span> (q1 &gt;= first &amp;&amp; a[q1 - <span class="number">1</span>] == key) q1--;   <span class="comment">//解决重复元素</span></span><br><span class="line">    <span class="keyword">while</span> (q2 &lt;= last  &amp;&amp; a[q2 + <span class="number">1</span>] == key) q2++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;      <span class="comment">//注意待排序列为: a[first,last]</span></span><br><span class="line">    <span class="keyword">if</span> (first &lt; last) &#123;                             <span class="comment">//递归结束条件：first &gt;= last</span></span><br><span class="line">        <span class="keyword">int</span> q1, q2;</span><br><span class="line">        partition(a, first, last,q1,q2);            <span class="comment">//找出轴点的位置</span></span><br><span class="line">        <span class="comment">//q1 = q2 = partition(a, first, last);</span></span><br><span class="line">        quicksort(a, first, q1 - <span class="number">1</span>);</span><br><span class="line">        quicksort(a, q2 + <span class="number">1</span>, last);</span><br><span class="line">        <span class="keyword">int</span> *b = <span class="keyword">new</span> <span class="keyword">int</span>[last - first + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt;= last; i++)</span><br><span class="line">            b[i - first] = a[i];</span><br><span class="line">        <span class="keyword">delete</span>[] b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实仔细看的话，我这样写是没能达到三分的，不过他在处理大量重复数据的时候也能很好工作。</p><p>然后是真正实现三分的算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort3Way</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lo &lt; hi) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> lt = lo;</span><br><span class="line">    <span class="keyword">int</span> i = lo + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> gt = hi;</span><br><span class="line">    swap(a[lo], a[rand() % (hi - lo + <span class="number">1</span>)]);</span><br><span class="line">    <span class="keyword">int</span> v = a[lo];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= gt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; v)</span><br><span class="line">            swap(a[lt++], a[i++]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i] &gt; v)</span><br><span class="line">            swap(a[i], a[gt--]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i++;</span><br><span class="line">    &#125;</span><br><span class="line">    quickSort3Way(a,lo, lt - <span class="number">1</span>);</span><br><span class="line">    quickSort3Way(a,gt + <span class="number">1</span>, hi);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Longest Substring Without Repeating Characters</title>
      <link href="/2017/10/01/LongestSubstringWithoutRepeatingCharacters/"/>
      <url>/2017/10/01/LongestSubstringWithoutRepeatingCharacters/</url>
      
        <content type="html"><![CDATA[<h1 id="Longest-Substring-Without-Repeating-Characters"><a href="#Longest-Substring-Without-Repeating-Characters" class="headerlink" title="Longest Substring Without Repeating Characters"></a>Longest Substring Without Repeating Characters</h1><p>打卡，第8天</p><p>今天国庆，然而不会家，找了一道之前不敢做的题目做了——<a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/" target="_blank" rel="noopener">Longest Substring Without Repeating Characters</a>,开始又是想着用分治法去完成（因为算法课在讲分治法），然而并没有做出来，又是同一个原因，在治的时候复杂度降不下来。</p><p>题目描述：</p><blockquote><p>Given a string, find the length of the longest substring without repeating characters.</p><p>Examples:</p><p>Given “abcabcbb”, the answer is “abc”, which the length is 3.</p><p>Given “bbbbb”, the answer is “b”, with the length of 1.</p><p>Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</p></blockquote><p>先放code吧：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">bool</span>&gt; cbmap;</span><br><span class="line">    <span class="keyword">while</span>( j &lt; s.<span class="built_in">size</span>() )&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; s.<span class="built_in">size</span>() &amp;&amp; cbmap[s[j]] == <span class="literal">false</span>)</span><br><span class="line">            cbmap[ s[j++] ] = <span class="literal">true</span>;</span><br><span class="line">        ret = <span class="built_in">max</span>(j-i,ret);</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; cbmap[s[j]] != <span class="literal">false</span>)</span><br><span class="line">            cbmap[ s[i++] ] = <span class="literal">false</span>;</span><br><span class="line">        cbmap[ s[j++] ] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概的思路是：</p><ul><li>用两个下标来标识<code>Substring</code>的位置，<code>s[i,j)</code>就是我们当前的<code>Substring</code>.</li><li>用j去遍历整个串，如果当前子串中没有<code>s[j]</code>，<code>j</code>就继续往下遍历，如果有，这时就可以计算一下当前子串的长度和之前的最长子串长度进行对比。</li><li>在<code>j</code>停止遍历后，我们就让<code>i</code>向前移动，直到，当前子串不包含<code>s[j]</code>,这样我们就可以把<code>s[j]</code>加入当前子串，并继续进行遍历。</li></ul><p>写着写着突然发现，有个地方可以改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">bool</span>&gt; cbmap;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>; j &lt; s.<span class="built_in">size</span>();j++ )&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; s.<span class="built_in">size</span>() &amp;&amp; cbmap[s[j]] == <span class="literal">false</span>)</span><br><span class="line">            cbmap[ s[j++] ] = <span class="literal">true</span>;</span><br><span class="line">        ret = <span class="built_in">max</span>(j-i,ret);</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; s[i++] != s[j])</span><br><span class="line">            cbmap[ s[i - <span class="number">1</span>] ] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路还是一样的，只不过写的更加精炼了罢了。</p><p>然后看看<code>dicuss</code>中别人写的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// for ASCII char sequence, use this as a hashmap</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">charIndex</span><span class="params">(<span class="number">256</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> longest = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        m = <span class="built_in">max</span>(charIndex[s[i]] + <span class="number">1</span>, m);    <span class="comment">// automatically takes care of -1 case</span></span><br><span class="line">        charIndex[s[i]] = i;</span><br><span class="line">        longest = <span class="built_in">max</span>(longest, i - m + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他这里用的是<code>vector&lt;int&gt;</code>去记录最大的下标，而我是用的是<code>map</code>去记录当前子串中是否有这个字符，用他这种方法可以把<code>i</code>向前移的循环给去掉。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Add Two Numbers</title>
      <link href="/2017/09/30/AddTwoNumbers/"/>
      <url>/2017/09/30/AddTwoNumbers/</url>
      
        <content type="html"><![CDATA[<p>打卡，第7天</p><blockquote><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p></blockquote><blockquote><p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</p><p>Output: 7 -&gt; 0 -&gt; 8</p></blockquote><p>从示例来看，这里的<code>digits</code>应该是倒过来的，即<code>2-&gt;4-&gt;3</code>表示的是<code>342</code></p><p>如果它不是倒过来的话，我们可能还需要用栈去将元素取出来。</p><p>虽然这是一道<code>Medium</code>的题目，但是难度其实很小，思路大概是：</p><p>将当期指针所指向的值相加得到一个数<code>x</code>，那么<code>x%10</code>就是这个位应该为的数，<code>x/10</code>就是进位，所以算法思路很简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans,add = <span class="number">0</span>;</span><br><span class="line">    <span class="function">ListNode <span class="title">ret</span><span class="params">(<span class="number">0</span>)</span></span>;                        <span class="comment">//头结点让单链表操作变简单</span></span><br><span class="line">    ListNode *p = &amp;ret;</span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        ans = (l1-&gt;val + l2-&gt;val) + add;    <span class="comment">//记得加上进位</span></span><br><span class="line">        add = ans/<span class="number">10</span>;                       <span class="comment">//求出进位</span></span><br><span class="line">        p-&gt;next = <span class="keyword">new</span> ListNode(ans%<span class="number">10</span>);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">        l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l1)&#123;</span><br><span class="line">        ans = l1-&gt;val + add;</span><br><span class="line">        add = ans/<span class="number">10</span>;</span><br><span class="line">        p-&gt;next = <span class="keyword">new</span> ListNode(ans%<span class="number">10</span>);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l2)&#123;</span><br><span class="line">        ans = l2-&gt;val + add;</span><br><span class="line">        add = ans/<span class="number">10</span>;</span><br><span class="line">        p-&gt;next = <span class="keyword">new</span> ListNode(ans%<span class="number">10</span>);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        l2 = l2-&gt;next;            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (add != <span class="number">0</span>) p-&gt;next = <span class="keyword">new</span> ListNode(add);<span class="comment">//记得出来进位不为0的情况</span></span><br><span class="line">    <span class="keyword">return</span> ret.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dicuss</code>中还有一个更精炼的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="function">ListNode <span class="title">ret</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    ListNode *p = &amp;ret;</span><br><span class="line">    <span class="keyword">int</span> add = <span class="number">0</span>,sum;</span><br><span class="line">    <span class="keyword">while</span>(l1 || l2 || add)&#123;</span><br><span class="line">        sum = (l1?l1-&gt;val:<span class="number">0</span>) + (l2?l2-&gt;val:<span class="number">0</span>) + add;</span><br><span class="line">        add = sum/<span class="number">10</span>;</span><br><span class="line">        p-&gt;next = <span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        l1 = (l1?l1-&gt;next:<span class="literal">nullptr</span>);</span><br><span class="line">        l2 = (l2?l2-&gt;next:<span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加一</title>
      <link href="/2017/09/29/%E5%8A%A0%E4%B8%80/"/>
      <url>/2017/09/29/%E5%8A%A0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>打卡，第6天</p><p>今天不知道为什么网速特别慢，<code>LeetCode</code>几乎没法用，所以就改成在<code>LintCode</code>上刷了。</p><blockquote><p>给定一个非负数，表示一个数字数组，在该数的基础上+1，返回一个新的数组。</p></blockquote><blockquote><p>该数字按照大小进行排列，最大的数在列表的最前面。</p></blockquote><p>因为今晚出去浪了，就找了一道Easy的题目。</p><p>实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">plusOne</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;digits)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = digits.rbegin();it != digits.rend();++it) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((*it += a) &lt; <span class="number">10</span>) <span class="keyword">return</span> digits;</span><br><span class="line">      *it = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    digits.insert(digits.<span class="built_in">begin</span>(),<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> digits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路很简单，而且因为只是加一，所以<code>for</code>循环里面的东西可以写的简单一点。</p><hr><p>今天终于把算法实验课的演示搞定了，明天或后天把东西整理一下，把排序算法的分析放出来。</p>]]></content>
      
      
      <categories>
          
          <category> LintCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LintCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>约瑟夫环</title>
      <link href="/2017/09/28/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E5%AE%9E%E7%8E%B0/"/>
      <url>/2017/09/28/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>今天上数据结构实验课，有道题是约瑟夫环，感觉挺好玩的，就拿出来总结一下（今天的LeetCode那道题真的是太Easy了）。</p><blockquote><p>约瑟夫环是一个数学的应用问题：已知n个人（以编号1，2，3…n分别表示）围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列。</p></blockquote><p>这里是用双向循环链表实现的：</p><p>先是类的申明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JCircle</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">ListNode *next,*prior;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">ListNode(<span class="keyword">int</span> v,ListNode *n = <span class="literal">NULL</span>,ListNode *p = <span class="literal">NULL</span>)</span><br><span class="line">:val(v),next(n),prior(p)&#123;&#125;</span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">JCircle</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getVal</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line"><span class="function">ListNode *<span class="title">getNext</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> next; &#125;</span><br><span class="line"><span class="function">ListNode *<span class="title">getPrior</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> prior; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JCircle</span>&#123;</span></span><br><span class="line">ListNode *head;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">JCircle(<span class="keyword">int</span> n);</span><br><span class="line">~JCircle();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> k)</span></span>;<span class="comment">//向前移动k步 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del</span><span class="params">()</span></span>;<span class="comment">//删除head所指向的ListNode并返回其 val </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> k)</span></span>;<span class="comment">//报数 </span></span><br><span class="line"><span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream&amp; out,JCircle &amp;jc);</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size</span> == <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">JCircle::JCircle(<span class="keyword">int</span> n)</span><br><span class="line">:head(<span class="literal">NULL</span>),<span class="built_in">size</span>(<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">size</span> = n;</span><br><span class="line">head = <span class="keyword">new</span> ListNode(<span class="number">1</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">head-&gt;next = head;</span><br><span class="line">head-&gt;prior = head;</span><br><span class="line">ListNode *p = head;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) &#123;</span><br><span class="line">p-&gt;next = <span class="keyword">new</span> ListNode(i,p-&gt;next);</span><br><span class="line">p-&gt;next-&gt;prior = p;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">head-&gt;prior = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JCircle::~JCircle()&#123;</span><br><span class="line">ListNode *p;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">size</span>--)&#123;</span><br><span class="line">p = head;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JCircle::move</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; "move";</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; k;i++)</span><br><span class="line">head = head-&gt;next;</span><br><span class="line"><span class="comment">//cout &lt;&lt; " over\n";</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">JCircle::del</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">2</span>)&#123;</span><br><span class="line">ListNode *p = head;</span><br><span class="line"><span class="keyword">int</span> ret = p-&gt;val;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">head-&gt;next = head-&gt;prior = head;</span><br><span class="line"><span class="built_in">size</span>--; </span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">size</span>--;</span><br><span class="line">head-&gt;next-&gt;prior = head-&gt;prior;</span><br><span class="line">head-&gt;prior-&gt;next = head-&gt;next;</span><br><span class="line">ListNode *p = head;</span><br><span class="line"><span class="keyword">int</span> t = p-&gt;val;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">JCircle::count</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="built_in">move</span>(k);</span><br><span class="line"><span class="comment">//cout &lt;&lt; "count";</span></span><br><span class="line"><span class="keyword">return</span> del();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream&amp; out,JCircle &amp;jc)&#123;</span><br><span class="line">ListNode *p = jc.head;</span><br><span class="line"><span class="keyword">int</span> n = jc.<span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line">out &lt;&lt; p-&gt;getVal() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">p = p-&gt;getNext();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//out &lt;&lt; "asdsad\n";</span></span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test</span></span><br><span class="line"><span class="comment">//人数  开始位置  报数 </span></span><br><span class="line"><span class="keyword">int</span>  n,  k,       m;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; m)&#123;</span><br><span class="line"><span class="function">JCircle <span class="title">jc</span><span class="params">(n)</span></span>;</span><br><span class="line">jc.<span class="built_in">move</span>(k);</span><br><span class="line"><span class="comment">//cout &lt;&lt; jc &lt;&lt; endl; </span></span><br><span class="line"><span class="keyword">while</span>(!jc.empty())</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; jc.count(m) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想写这个的原因是，我写了很久，事实上回到宿舍写多一遍的时候，我也写了很久（现在是20:16:00），写了一个多小时了，感觉自己还不怎么熟悉一些的基本数据结构（虽然已经在之前的学院上过一次了，恩，相当水的一门课）。</p><p>重写一遍的感觉是，该掉的坑，我还是掉下去了，之前写了的一遍的效果就是，我能比较快的爬出来，而且不会纠结于选择双向链表还是单向链表。</p><p>写的过程中，也体会了一下双向链表的坑点：</p><ul><li><code>size==2</code>时，不能用常规方法<code>delete</code>掉自己。</li><li>加入size会减少一些常见的错误，一些实现敲起来也会简单点（唯一一个一开始就选择正确的点）。</li></ul><p>感觉以后要多总结一些一些基本的数据结构，不然做算法题的时候，会很难找到适合的数据结构。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 循环链表，双向链表，数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Merge Two Sorted List</title>
      <link href="/2017/09/28/MergeTwoSortedList/"/>
      <url>/2017/09/28/MergeTwoSortedList/</url>
      
        <content type="html"><![CDATA[<p>打卡，第五天</p><p>今天偷个懒，找下自信先，做个<code>Easy</code>的题目——<a href="https://leetcode.com/problems/merge-two-sorted-lists/description/" target="_blank" rel="noopener">Merge Two Sorted List</a> （我也没想到是这么简单的题目）</p><p>之前在 <code>LintCode</code>做个一个链表排序，也写过一篇<a href="https://wuxiaobai24.github.io/2017/09/19/%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F/" target="_blank" rel="noopener">blog</a><br>解这道题时用的是<code>MergeSort</code>去做.所以已经写过一次<code>Merge Two Sorted List</code>了，之前的写法是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">mergeList</span><span class="params">(ListNode *l1,ListNode *l2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!l1) <span class="keyword">return</span> l2;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!l2) <span class="keyword">return</span> l1;</span><br><span class="line">  ListNode* ret = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  ListNode*p = ret;</span><br><span class="line">  <span class="keyword">while</span>(l1 &amp;&amp; l2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1-&gt;val &gt; l2-&gt;val) &#123;</span><br><span class="line">      ret-&gt;next = l2;</span><br><span class="line">      ret = ret-&gt;next;</span><br><span class="line">      l2 = l2-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ret-&gt;next = l1;</span><br><span class="line">      ret = ret-&gt;next;</span><br><span class="line">      l1 = l1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ret-&gt;next = (l1)?l1:l2;</span><br><span class="line">  ret = p-&gt;next;</span><br><span class="line">  <span class="keyword">delete</span> p;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次做一个小改进（可能时间复杂度上没有改进）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* ret = head;</span><br><span class="line">        <span class="keyword">while</span>(l1 || l2) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((l1 &amp;&amp; l2 &amp;&amp; l1-&gt;val &gt; l2-&gt;val )|| !l1) &#123;</span><br><span class="line">                head-&gt;next = l2;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                head-&gt;next = l1;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = ret-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> ret;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>恩，细细想想，这个思路效率可能跟慢，不过用在对数组的<code>Merge</code>的情况还是可以的（起码比较简洁）。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Container With Most Water</title>
      <link href="/2017/09/27/Container_With_Most_Water/"/>
      <url>/2017/09/27/Container_With_Most_Water/</url>
      
        <content type="html"><![CDATA[<p>打卡，第四天</p><p>今天的题目是<a href="https://leetcode.com/problems/container-with-most-water/description/" target="_blank" rel="noopener">Container With Most Water</a></p><blockquote><p>Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.<br>Note: You may not slant the container and n is at least 2.</p></blockquote><p>很烦，今天老是时间超限，就是不能想出一个时间复杂度小的算法来。</p><p>先理解一下题目先，大概就是给你一个数组<code>height</code>，你要找出两个i，j使得<code>min(height[i],height[j])*(j - i)</code>最大。</p><p>很容易写出一个$ O(n^{2}) $ 的算法出来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> water = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="built_in">height</span>.<span class="built_in">size</span>(); ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="built_in">height</span>.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line"><span class="keyword">int</span> h = <span class="built_in">min</span>(<span class="built_in">height</span>[i],<span class="built_in">height</span>[j]);</span><br><span class="line">water = <span class="built_in">max</span>(water,h*(j - i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> water;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个算法是不能过最后一个测例的。</p><p>想了一个小时都没想出一个好方法来减少他的复杂度,后来就去翻<code>dicuss</code>，看到这样一个算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> water = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="built_in">height</span>.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line"><span class="keyword">int</span> h = <span class="built_in">min</span>(<span class="built_in">height</span>[i],<span class="built_in">height</span>[j]);</span><br><span class="line">water = <span class="built_in">max</span>(water,h*(j - i));</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">height</span>[i] &lt;= h &amp;&amp; i &lt; j) i++;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">height</span>[j] &lt;= h &amp;&amp; i &lt; j) j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是先取最宽的容器，假设他就是我们要的结果。<br>因为<code>i</code>不断变大,<code>j</code>不断变小，这样wide就不断变小，因为wide在变小，要比当前最大的容器还大的话就只能比当前高度高，这就是那两个<code>while</code>的作用，去除掉一个不可能的情况。</p><p>啊，我真菜，为什么老是想不出来呢！</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pow(x,n)</title>
      <link href="/2017/09/26/Pow(x,y)/"/>
      <url>/2017/09/26/Pow(x,y)/</url>
      
        <content type="html"><![CDATA[<p>打卡第三天！！！</p><p>今天刷的题是<a href="https://leetcode.com/problems/powx-n/description/" target="_blank" rel="noopener">Pow(x,n)</a></p><blockquote><p>implement pow(x,n)</p></blockquote><p>题目相当简洁，看起来好像也不会很难的样子，不过他竟然是一道<code>Medium</code>的题目（万万没想到）.<br><code>pow(x,n)</code>大家应该都多少有接触过，就是求x的n次方嘛。<br>我们可以把n分成三种情况去考虑：</p><ul><li><code>n &gt; 0</code> ： 可以转化成求<code>myPow(1/x,-n)</code></li><li><code>n == 0</code> ：直接<code>return 1</code>即可</li><li><code>n &lt; 0</code> ：这个是我们实现的关键，只要完成这个就可以AC这道题了。</li></ul><p>首先，一个最简单的思路就是n个<code>x</code>相乘.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> ret = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">ret *= x;</span><br><span class="line"><span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><p>这样需要做n次乘法，时间复杂度是<code>O(n)</code>,在<code>LeetCode</code>中，这样做是会超时的，我们需要找到一个 时间复杂度更小的算法。</p><p>可以考虑使用分治法去完成：<br>也就是说，我们要求<code>myPow(x,n)</code>的值，那我们可以转化成求<code>myPow(x,n/2)</code>的值，然后将其返回值乘二即可（n为奇数，还需要 乘多一个x）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> ret = myPow(x,n/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> (n%<span class="number">2</span>)?(ret*ret*x):(ret*ret);</span><br></pre></td></tr></table></figure><p>这是递归的做法，显然这已经能够完成了,这也是我的做法。<br>这里面还有一个坑点没提到，就是在<code>n &lt; 0</code>的情况下，我们前面的做法是直接<code>return myPow(1/x,-n)</code>的，但是这样是会出错的：<br>当<code>n=-2147483648</code>时，会出现<code>RunTime Error</code>，也就是那个<code>-n</code>是求不出来的，因为<code>int</code>类型的最大值为2147483647。<br>这里用了一个小技巧：<br><code>return myPow(1/x, -(n + 1) ) *1/x;</code><br> 因为这里的<code>n</code>满足<code>n &lt; 0</code>，所以可以不用考虑正溢出的情况。<br> 完整的代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">double</span> ret = myPow(x,n/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> (n%<span class="number">2</span>)?ret*ret*x:ret*ret;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//n &lt; 0</span></span><br><span class="line">        <span class="keyword">return</span> myPow(<span class="number">1</span>/x,-(n + <span class="number">1</span> )) * <span class="number">1</span>/x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>恩，按照惯例，看看<code>dicuss</code>中别人的做法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> ans;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">if</span> ( n &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">p = -n;</span><br><span class="line">x = <span class="number">1</span>/x;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">p = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(p) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">ans *= x;</span><br><span class="line">x *= x;</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这个做法的第一眼就想起了某位老师说的：</p><blockquote><p>“有时候你需要从二进制的角度去看问题。”</p></blockquote><p>我们来考虑<code>myPow(a,7)</code>的情况：<br><code>7</code>的二进制编码为：<code>0000 0111</code>,也就是<code>7 = 4 + 2 + 1</code><br>而 $ a^{7} = a^{4} * a^{2} * a^{1} $<br>相信上面的代码应该能够很容易的看懂了。<br>另外我们还可以看到，他用<code>unsigned long long</code>来避免溢出的情况，这也是一个小技巧。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Longest Common Prefix</title>
      <link href="/2017/09/25/LongestCommonPrefix/"/>
      <url>/2017/09/25/LongestCommonPrefix/</url>
      
        <content type="html"><![CDATA[<p>恩，今天早上1,2节没课，闲来无事就先把今天的题刷了（你的算法分析实验呢？）今天的题目是<a href="https://leetcode.com/problems/longest-common-prefix/description/" target="_blank" rel="noopener">Longest Common Prefix</a>,恩，比那个什么最长公共子串简单多了，很容易就可以找到思路（虽然写出来的代码很难看）</p><p>大概的解题思路是：</p><ul><li>先找出最短的字符串，假定他就是我们要的答案</li><li>遍历所有字符串，看他们是否有这个字符串<ul><li>如果有就直接返回</li><li>如果没有就把子串长度减小，再进行重复操作</li></ul></li></ul><p>思路很简单，但我写的很渣（直接过，我也是很懵，我还想再敲多一下的）</p><p>先上我的代码吧：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs.empty()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (strs.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">string</span> ret =  strs[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;s:strs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ret.<span class="built_in">size</span>() &gt; s.<span class="built_in">size</span>())</span><br><span class="line">            ret = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ret.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">bool</span> is = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;s:strs)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.substr(<span class="number">0</span>,ret.<span class="built_in">size</span>()) != ret) &#123;</span><br><span class="line">                is = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!is) ret = ret.substr(<span class="number">0</span>,ret.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">恩，我是没想到它会直接过的，思路相当简单，当然思路简单一般效率就不会很高。</span><br><span class="line"></span><br><span class="line">我的思路一开始是假定最短的串是我们要的结果，而在`dicuss`中别人的写法是另一种思路：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">string</span> prefix = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> idx=<span class="number">0</span>; strs.<span class="built_in">size</span>()&gt;<span class="number">0</span>; prefix+=strs[<span class="number">0</span>][idx], idx++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;strs.<span class="built_in">size</span>(); i++)</span><br><span class="line">            <span class="keyword">if</span>(idx &gt;= strs[i].<span class="built_in">size</span>() ||(i &gt; <span class="number">0</span> &amp;&amp; strs[i][idx] != strs[i<span class="number">-1</span>][idx]))</span><br><span class="line">                <span class="keyword">return</span> prefix;</span><br><span class="line">    <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比我的代码简洁很多，他是先假定最长前缀是空，然后在用动态规划的思路去做的（恩，要好好研究一下动态规划），而且他这种写法就不需要判断传入的<code>vector</code>是不是空了。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Valid Parentheses</title>
      <link href="/2017/09/24/Valid-Parentheses/"/>
      <url>/2017/09/24/Valid-Parentheses/</url>
      
        <content type="html"><![CDATA[<p> 恩，照常打个卡（差点忘记）。。。。</p><p>由于比较晚才发现要刷个题（捂脸），所以找了个<code>Easy</code>的题目——<a href="https://leetcode.com/problems/valid-parentheses/description/" target="_blank" rel="noopener">Valid Parentheses</a></p><blockquote><p>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p><p>The brackets must close in the correct order, <code>&quot;()&quot;</code> and <code>&quot;()[]{}&quot;</code> are all valid but <code>&quot;(]&quot;</code> and <code>&quot;([)]&quot;</code> are not.</p></blockquote><p>很经典（很简单）的题目——括号匹配，显然用个栈来完成是最简单的了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> c:str)&#123;</span><br><span class="line">    <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'('</span>:<span class="keyword">case</span> <span class="string">'&#123;'</span>: <span class="keyword">case</span> <span class="string">'['</span>:</span><br><span class="line">        s.push(c);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">        <span class="keyword">if</span> (s.empty() || s.top() != <span class="string">'('</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'&#125;'</span>:</span><br><span class="line">        <span class="keyword">if</span> (s.empty() || s.top() != <span class="string">'&#123;'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">']'</span>:</span><br><span class="line">        <span class="keyword">if</span> (s.empty() || s.top() != <span class="string">'['</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s.empty()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>恩，好像没什么难度，多注意点细节就好了。</p><p>做完之后顺手看了一下<code>Discuss</code>,看了一下别人的<a href="https://leetcode.com/problems/valid-parentheses/discuss/" target="_blank" rel="noopener">实现</a>，同样是c++，同样的方法，为什么别人写的看起来就很舒服呢？</p><p>一起来对比一下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; paren;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">char</span>&amp; c : s) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'('</span>: </span><br><span class="line">      <span class="keyword">case</span> <span class="string">'&#123;'</span>: </span><br><span class="line">      <span class="keyword">case</span> <span class="string">'['</span>: paren.push(c); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">')'</span>: <span class="keyword">if</span> (paren.empty() || paren.top()!=<span class="string">'('</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="keyword">else</span> paren.pop(); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'&#125;'</span>: <span class="keyword">if</span> (paren.empty() || paren.top()!=<span class="string">'&#123;'</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="keyword">else</span> paren.pop(); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">']'</span>: <span class="keyword">if</span> (paren.empty() || paren.top()!=<span class="string">'['</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="keyword">else</span> paren.pop(); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>: ; <span class="comment">// pass</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> paren.empty() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>突然很嫌弃自己的代码风格！！！</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stack </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3Sum</title>
      <link href="/2017/09/20/3Sum/"/>
      <url>/2017/09/20/3Sum/</url>
      
        <content type="html"><![CDATA[<h1 id="3Sum"><a href="#3Sum" class="headerlink" title="3Sum"></a>3Sum</h1><p>觉得立个<code>flag</code>：从今天开始每天在LeetCode刷一道题,今天的是<a href="https://leetcode.com/problems/3sum/description/" target="_blank" rel="noopener">3Sum</a></p><p>题目：</p><blockquote><p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p></blockquote><blockquote><p>Note: The solution set must not contain duplicate triplets.</p></blockquote><blockquote><p>For example, given array S = [-1, 0, 1, 2, -1, -4],</p></blockquote><blockquote><p>A solution set is:<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p></blockquote><p>这个题的坑点有几个：</p><ul><li>它要求的是不同的，但是如果处理的不好的话，是很容易出现相同的。</li><li>第二个是他很容易写出一个O(n^3)的算法，但是好像是跑不过去的。</li></ul><p>接近的大概思路是：</p><ul><li>先对数组进行排序，这样比较好解决第一个坑点</li><li>把他转换成2Sum去做</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ret;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());      <span class="comment">//先进行排序</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">2</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> target = -nums[i];          <span class="comment">//转换成求2Sum</span></span><br><span class="line">            <span class="keyword">if</span> (target &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> beg = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">end</span> = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(beg &lt; <span class="built_in">end</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[beg] + nums[<span class="built_in">end</span>];</span><br><span class="line">                <span class="keyword">if</span> (sum &lt; target)</span><br><span class="line">                    beg++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target)</span><br><span class="line">                    <span class="built_in">end</span>--;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> n1 = nums[beg];</span><br><span class="line">                    <span class="keyword">int</span> n2 = nums[<span class="built_in">end</span>];</span><br><span class="line">                    ret.push_back( &#123;nums[i],nums[beg],nums[<span class="built_in">end</span>]&#125; );</span><br><span class="line">                    <span class="comment">//处理重复</span></span><br><span class="line">                    <span class="keyword">while</span>(beg &lt; <span class="built_in">end</span> &amp;&amp; nums[beg] == n1) beg++;</span><br><span class="line">                    <span class="keyword">while</span>(beg &lt; <span class="built_in">end</span> &amp;&amp; nums[<span class="built_in">end</span>] == n2) <span class="built_in">end</span>--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理重复</span></span><br><span class="line">            <span class="keyword">while</span>(i + <span class="number">1</span> &lt; nums.<span class="built_in">size</span>()- <span class="number">2</span> &amp;&amp; nums[i + <span class="number">1</span>] == nums[i])</span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Different Ways to Add Parentheses</title>
      <link href="/2017/09/20/different-ways-to-add-parentheses/"/>
      <url>/2017/09/20/different-ways-to-add-parentheses/</url>
      
        <content type="html"><![CDATA[<h1 id="Different-Ways-to-Add-Parentheses"><a href="#Different-Ways-to-Add-Parentheses" class="headerlink" title="Different Ways to Add Parentheses"></a>Different Ways to Add Parentheses</h1><blockquote><p>开始每天坚持刷OJ和Paper吧。</p></blockquote><p>今天的题目是<a href="https://leetcode.com/problems/different-ways-to-add-parentheses/" target="_blank" rel="noopener"> Different Ways to Add Parentheses </a>:</p><p>Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are <code>+</code>, <code>-</code> and <code>*</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;2-1-1&quot;</span><br><span class="line">Output: [0, 2]</span><br><span class="line">Explanation: </span><br><span class="line">((2-1)-1) &#x3D; 0 </span><br><span class="line">(2-(1-1)) &#x3D; 2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;2*3-4*5&quot;</span><br><span class="line">Output: [-34, -14, -10, -10, 10]</span><br><span class="line">Explanation: </span><br><span class="line">(2*(3-(4*5))) &#x3D; -34 </span><br><span class="line">((2*3)-(4*5)) &#x3D; -14 </span><br><span class="line">((2*(3-4))*5) &#x3D; -10 </span><br><span class="line">(2*((3-4)*5)) &#x3D; -10 </span><br><span class="line">(((2*3)-4)*5) &#x3D; 10</span><br></pre></td></tr></table></figure><p>太久没刷过题的后果就是之前掌握的一些解题思路好像有点生疏了，但还是勉强完成了这道题，首先从两个Example开始分析，第一个太简单好像看不出什么，我们分析一下第二个，我们可以看到，<code>(2*(3-(4*5))) = -34</code>是先算第二个<code>*</code>，然后再算<code>-</code>，最后算第一个<code>*</code>。大概可以猜出来我们需要穷举所有运算顺序，但应该不是全排列，因为当运算符个数为3时，他的运算顺序只有5个，而不是6个。仔细分析一下可以发现，这是因为已下两种算法是一样的：</p><ol><li>先算第一个，再算第三个，最后算第二个</li><li>先算第三个，再算第一个，最后算第二个</li></ol><p>这就有点像一个二叉树了，层数相同的情况。我们尝试把上面五种运行顺序用二叉树表示出来，首先，分别用<code>1</code>,<code>2</code>,<code>3</code>代替<code>*</code>,<code>-</code>,<code>*</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">    \</span><br><span class="line">     3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   2</span><br><span class="line"> &#x2F;   \</span><br><span class="line">1     3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  3</span><br><span class="line"> &#x2F;</span><br><span class="line">2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F;</span><br><span class="line">3</span><br><span class="line"> \</span><br><span class="line">  2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F;     </span><br><span class="line">  2</span><br><span class="line"> &#x2F;</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>画出来后，我们很容易的发现，这个问题变成了对平衡二叉树的穷举问题，因此代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; ops;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diffWaysToCompute</span><span class="params">(<span class="built_in">string</span> input)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num; <span class="keyword">char</span> op;</span><br><span class="line">    <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(input)</span></span>;</span><br><span class="line"></span><br><span class="line">    ss &gt;&gt; num;</span><br><span class="line">    nums.push_back(num);</span><br><span class="line">    <span class="keyword">while</span>(ss &gt;&gt; op &gt;&gt; num) &#123;</span><br><span class="line">        nums.push_back(num);</span><br><span class="line">        ops.push_back(op);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    helper(<span class="number">0</span>, ops.<span class="built_in">size</span>(), res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">char</span> op, <span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>: res = i1 + i2; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'-'</span>: res = i1 - i2; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'*'</span>: res = i1 * i2; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> last, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;outputs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first == last) &#123;</span><br><span class="line">        outputs.push_back(nums[first]);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lefts;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rights;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = first; i &lt; last;i++) &#123;</span><br><span class="line">        <span class="comment">// select ops[i] in this layer</span></span><br><span class="line">        lefts.<span class="built_in">clear</span>();</span><br><span class="line">        rights.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        helper(first, i, lefts);</span><br><span class="line">        helper(i+<span class="number">1</span>, last, rights);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> l: lefts) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> r: rights) &#123;</span><br><span class="line">                outputs.push_back(calc(ops[i], l, r));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>stringstream</code>的效率的确不行，所以我们可以尝试将解析字符串的那段代码改成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> beg = <span class="number">0</span>, <span class="built_in">end</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;<span class="built_in">end</span> &lt; input.<span class="built_in">size</span>(); <span class="built_in">end</span>++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (input[<span class="built_in">end</span>] == <span class="string">'+'</span> || input[<span class="built_in">end</span>] == <span class="string">'-'</span> || input[<span class="built_in">end</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">        nums.push_back(stoi(input.substr(beg, <span class="built_in">end</span> - beg)));</span><br><span class="line">        ops.push_back(input[<span class="built_in">end</span>]);</span><br><span class="line">        beg = <span class="built_in">end</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">nums.push_back(stoi(input.substr(beg, <span class="built_in">end</span> - beg)));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表排序</title>
      <link href="/2017/09/19/%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F/"/>
      <url>/2017/09/19/%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>今天中午在<a href="http://www.lintcode.com" target="_blank" rel="noopener">Lintcode</a>上刷了一道题——<a href="http://www.lintcode.com/zh-cn/problem/sort-list/" target="_blank" rel="noopener">链表排序</a></p><p>题目很短：</p><blockquote><p>在 O(<em>n</em> log <em>n</em>) 时间复杂度和常数级的空间复杂度下给链表排序。</p></blockquote><p>最近几天也在做排序算法的实验，所以看到这道题想刷一下。</p><p>从题目的要求我们可以大概的想出几种能达到要求的排序：</p><ul><li>快速排序</li><li>归并排序</li></ul><p>这里是归并排序的实现：</p><p>归并排序的大概思路是：</p><p>在待排序列中找到中间元素，将待排序列分成两个待排序列，分别对这两个待排序列递归地调用归并排序，当待排序列中元素只剩一个时，序列显然有序。</p><p>现在只需要将两个有序序列合并成一个有序序列。</p><hr><p>实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  ListNode* next;</span><br><span class="line">  ListNode(<span class="keyword">int</span> v):val(v),next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode * <span class="title">sortList</span><span class="params">(ListNode * head)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// write your code here</span></span><br><span class="line">  <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  ListNode *fast,*slow;</span><br><span class="line">  fast = slow = head;</span><br><span class="line">  <span class="keyword">while</span>(fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    fast = fast-&gt;next-&gt;next;</span><br><span class="line">    slow = slow-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  fast = slow;</span><br><span class="line">  slow = slow-&gt;next;</span><br><span class="line">  fast-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">  fast = sortList(head);</span><br><span class="line">  slow = sortList(slow);</span><br><span class="line">  <span class="keyword">return</span> mergeList(fast,slow);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode *<span class="title">mergeList</span><span class="params">(ListNode *l1,ListNode *l2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!l1) <span class="keyword">return</span> l2;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!l2) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">  ListNode* ret = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  ListNode*p = ret;</span><br><span class="line">  <span class="keyword">while</span>(l1 &amp;&amp; l2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1-&gt;val &gt; l2-&gt;val) &#123;</span><br><span class="line">      ret-&gt;next = l2;</span><br><span class="line">      ret = ret-&gt;next;</span><br><span class="line">      l2 = l2-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ret-&gt;next = l1;</span><br><span class="line">      ret = ret-&gt;next;</span><br><span class="line">      l1 = l1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ret-&gt;next = (l1)?l1:l2;</span><br><span class="line">  ret = p-&gt;next;</span><br><span class="line">  <span class="keyword">delete</span> p;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的难点就是找出中间元素，将一个序列分成两个序列，这里的实现是<code>快慢指针</code>来实现的，即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ListNode *fast,*slow;</span><br><span class="line">fast = slow = head;</span><br><span class="line"><span class="keyword">while</span>(fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  fast = fast-&gt;next-&gt;next;</span><br><span class="line">  slow = slow-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法实现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于Blog</title>
      <link href="/2017/09/18/%E5%85%B3%E4%BA%8EBlog/"/>
      <url>/2017/09/18/%E5%85%B3%E4%BA%8EBlog/</url>
      
        <content type="html"><![CDATA[<p>早在很久之前就想弄个Blog了，先后试过博客园，CSDN，简书这些现有的博客网站，恩，但是都没写几篇就把他忘记了。后来也想自己写一个，github中<a href="https://github.com/wuxiaobai24/flask-study" target="_blank" rel="noopener">flask-study</a>就是这样来的，然而死在了前端上。。。</p><p>昨天可能考完CCF CSP有点懵，就开始想搞个blog，一开始也想着继续学学前端，自己搭一个出来，后来想着这学期课有点多，不知道要多久才能搭完，就先用github pages＋hexo 搭一个用用先。</p><p>说到CCF CSP就有点心塞，连续两年都是没做完第三题（搞得我会第四题一样），最烦的是每年第三天都是写一个Parser。今年是<code>json</code>,去年是<code>Markdown</code>。每次都做得很蹦，希望能混到几十分吧。</p><p>说到底，还是自己太渣了，每次写一些复杂的逻辑的时候，感觉大脑就不够用了，一旦程序达到300行，就开始有点接受不了了。这次考试暴露自己挺多不足的地方：</p><ul><li><p>数据结构的底子还不够扎实。</p><blockquote><p>一遇到图就直接崩，遇到适合树结构的也不敢用。</p></blockquote></li><li><p>不会写注释</p><blockquote><p>从这次做题的时候就可以感觉出来，如果一开始敲的时候加一些注释，后面就不会看自己代码都需要想好久，而且最近在写的sort算法，也不会记一些注释，写的时候老是觉得很简单，自己可以很容易记住，然而每次都打自己的脸。</p></blockquote></li><li><p>遇事没有韧性</p><blockquote><p>总感觉自己老是会放弃，做题时也是这样，做第三题时老是想着“要不不写了，直接走吧”，好在忍了下来，不然估计连几十分都不敢奢望。</p></blockquote></li><li><p>对STL根本不熟悉</p><blockquote><p>即使翻着书也不写不好，总是会忘记一下东西，最后还是用c那一套写了一堆。</p></blockquote></li><li><p>不会组织程序结构</p><blockquote><p>总是会写出一个很长的函数，明明很多时候是可以把一些实现分成函数，然后分别测试的。在想要实现一个东西的时候，首先做得是打开编辑器开写，而不是思考怎么做。</p></blockquote></li></ul><p>总结的有点心塞。。。</p><p>一点一点的改变吧。</p><ul><li>把树和图的一些基本算法实现出来（开一个repositories来放一些算法）</li><li>写好注释（起码能让自己几天后一看就知道自己当时想的是什么）</li><li>坚持写blog，起码每周更新一次</li><li>尝试着研究一下STL（如果有时间的话，捂脸）</li></ul><p>路还远着呢！</p>]]></content>
      
      
      <categories>
          
          <category> 杂事一堆 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
