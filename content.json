{"meta":{"title":"Code & Fun","subtitle":"wuxiaobai24's blog","description":"wuxiaobai24's blog","author":"wuxiaobai24","url":"http://blog.codeand.fun","root":"/"},"pages":[{"title":"","date":"2020-04-02T14:43:48.831Z","updated":"2020-04-02T14:43:48.831Z","comments":true,"path":"404.html","permalink":"http://blog.codeand.fun/404.html","excerpt":"","text":""},{"title":"categories","date":"2019-02-14T11:18:45.000Z","updated":"2020-04-02T14:43:48.843Z","comments":false,"path":"categories/index.html","permalink":"http://blog.codeand.fun/categories/index.html","excerpt":"","text":""},{"title":"个人简历","date":"2019-02-26T22:12:13.000Z","updated":"2020-04-02T14:43:48.843Z","comments":false,"path":"resume/index.html","permalink":"http://blog.codeand.fun/resume/index.html","excerpt":"","text":"个人信息 吴坤汉/男/1997 本科/深圳大学计算机科学与技术2015级 研究生/深圳大学软件工程2019级 Blog：https://wuxiaobai24.github.io Github：https://github.com/wuxiaobai24 联系方式 手机：MTM3NTEwMTU5MTk= Email：wuxiaobai24#foxmail.com WeChat： d3V4aWFvYmFpMjQ= QQ：OTkyMDI5MDM2 个人经历2015.9 - 2019.6（深圳大学） 学业之星（三等奖），专业前6% | 2017年 &amp; 2018年 CCF 计算机软件能力认证 | 220分/前13.16% 大学英语四级考试 | 四级501分 从光电工程学院转入计算机与软件学院 | 2016年 大学平均绩点 | 3.88 专业排名 | 15/195 转入计算机与科学技术后平均绩点 | 4.08 2019.9至今（深圳大学） 以总评第一的成绩考入深圳大学软件工程专业 技能清单以下均为我熟悉的技能 编程语言：C/C++/Python 版本管理：Git 计算机图形学：OpenGL 操作系统：Linux 项目经历 密码学：利用n-gram模型和爬山算法破解单表加密 计算机图形学：利用OpenGL完成简单的俄罗斯方块 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。"},{"title":"categories","date":"2019-02-14T11:18:45.000Z","updated":"2020-04-02T14:43:48.843Z","comments":false,"path":"tags/index.html","permalink":"http://blog.codeand.fun/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2019-02-14T10:52:46.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"about/index.html","permalink":"http://blog.codeand.fun/about/index.html","excerpt":"","text":""}],"posts":[{"title":"2020 02 & 03 Reading","slug":"2020-02-03-Reading","date":"2020-04-02T21:09:55.000Z","updated":"2020-04-02T14:43:48.831Z","comments":true,"path":"2020/04/02/2020-02-03-Reading/","link":"","permalink":"http://blog.codeand.fun/2020/04/02/2020-02-03-Reading/","excerpt":"","text":"从2月7号开始，开始每天花一定的时间看书，想要养成读书的习惯，为了激励一下自己，所以在这里记录下 2、3 月份读的书。 2020-02 2月份读了10本书，大部分书都是在微信上看完的，当时应该有点刻意的让虚构和非虚构的数量相同，所以基本上是一本虚构、一本非虚构的。 《人生海海》 开始时间：2020-02-07 完成时间：2020-02-09 评分：★★★★☆ 发现了一个本土的好作家——麦家 《牛奶可乐经济学》 开始时间：2020-02-11 完成时间：2020-02-17 评分：★★★☆☆ 一开始看感觉还挺好玩的，但看到3分之一时就觉得有些无趣了，可能因为经济学本来就不是什么太有趣的东西吧。ps：有种看十万个为什么的感觉。 《白夜行》 开始时间：2020-02-17 完成时间：2020-02-20 评分：★★★★★ 东野圭吾的书，果然没让我失望，“枪虾和虾虎鱼的故事”，强烈推荐。 《精进》 开始时间：2020-02-17 完成时间：2020-02-19 评分：★★★☆☆ 知乎式“干货”。第2，3章的一些观点感觉还不错，但后面真的是越看越无趣。 《娱乐至死》 开始时间：2020-02-19 完成时间：2020-02-21 评分：★★★★★ “人们感到痛苦的不是他们用笑声代替了思考，而是他们不知道自己为什么笑以及为什么不再思考。” 值得多读几遍的书籍。 《美丽新世界》 开始时间：2020-02-21 完成时间：2020-02-28 评分：★★★★★ 看这本书是因为看了《娱乐至死》，hhh，貌似我在高中就看过开头，然而当时并没有看下去。 《呼吸》 开始时间：2020-02-21 完成时间：2020-02-23 评分：★★★★☆ 看起来像是一部作品集，我对这本书的期望值好像有点过高了，有几篇读起来和寓言故事的感觉。恩，像是《一千零一夜》的感觉。 《练习的心态》 开始时间：2020-02-23 完成时间：2020-02-26 评分：★★★☆☆ 翻译真的是太烂了吧，有些句子读起来都拗口难懂，书中观点也呈现的不够清晰（也可能是翻译的锅），不过感觉书中有些想法还是不错的，感觉看得下去完全是因为有些观点引起了共鸣。 《月亮与六便士》 开始时间：2020-02-29 结束时间：2020-03-01 评分：★★★★☆ 我看的那个版本似乎特别冷门，感觉之后可以找其他版本来看看。 2020-03 这个月读书比较随意，经常同时读好几本书（后来感觉这样不好就改掉了），没想到这样还是读了10本。同时，因为购入了kpw4，所以有一半的书是在 Kindle 上读完的，而且也开始养成了睡前读书的习惯，10点半洗澡，洗完澡就爬到床上去读一个小时的书。感觉这样的生活还是很惬意的，emmm，虽然4月份就不一定有这种好氛围了，哎，美好的假期似乎要结束了。 《如何高效学习》 开始时间：2020-03-02 结束时间：2020-03-04 评分：★★★★☆ 我应该是第二遍读这本书了，看的时候不断地思考之前自己的做法，发现自己有段时间应该是在践行书中的一些观点的，但是后来似乎就没有有意识地去做这件事了。这也导致了自己有段时间也出现了死读书的情况，比如不思考地抄笔记，记录书中的观点什么的。 《动物农场》 开始时间：2020-03-03 结束时间：2020-03-04 评分：★★★★★ “目光从猪移到人，再从人移到猪，又重新从猪移到人，要分清哪张脸是猪的，哪张脸是人的，已经不可能了。” 看这本书最开始是因为想读这本书的原版，然而到现在都没开始（捂脸）。 《掌控习惯》 开始时间：2020-03-04 结束时间：2020-03-15 评分：★★★★☆ 虽然看到后半部分就感觉有点无聊了，但是还是讲了许多关于习惯的技巧，比如想，将要养成的习惯挂在已经有的习惯后面等等。 《孤独小说家》 开始时间：2020-03-04 结束时间：2020-03-07 评分：★★★★☆ 有点碎碎念的小说，看的时候感觉很平淡，但是莫名其妙看的进去。BTW，你要是说，这本书是耕平写的，我完全相信。 《82年生的金智英》 开始时间：2020-03-08 结束时间：2020-03-09 评分：★★★★☆ 一本很快就能看完的书，晚上睡前看了一会，然后早上起来看了一会就看完。虽然写的是韩国的事情，但是把地点改成中国也完全不会有违和感。 《1984》 开始时间：2020-03-18 结束时间：2020-03-30 看完《娱乐至死》就已经决定要看的书了，一开始有点略微无聊，不过看到后面就还好。 《房思琪的初恋乐园》 开始时间：2020-03-09 结束时间：2020-03-13 评分：★★★★★ 这个月让我印象最深刻的书，看这本书的这几天几乎陷进去了，那几天心情有点过于低落。这本书给人一种很奇怪的感觉，一开始看的时候会觉得作者的写作风格很奇怪，读到后半段的时候，会有种既厌恶又难以掩饰喜欢的感觉。 《微习惯》 开始时间：2020-03-13 结束时间：2020-03-31 评分：★★★★☆ 很短的一本书，有种看博客集合的感觉，不过看完后，我也想试试“一个俯卧撑挑战”，hhh。 《无人生还》 开始时间：2020-03-20 结束时间：2020-03-21 评分：★★★★☆ 士兵岛童谣杀人事件，估计是因为之前在其他地方看到过对这本书的模仿，所以看这本书的时候其实挺无感的。 《禅与摩托车维修艺术》 开始时间：2020-03-21 结束时间：2020-03-26 评分：★★★★☆ 游记？哲学书？说实话有点没看懂，书中所说的“良质”是指“Good”吗？？ 总结 &amp; Flag2 月份和 3 月份读的书都是和专业无关的，以后可以稍微增加一点专业相关的书籍。 接下来是下个月想读的书： 别逗了，费曼先生 黑客与画家 肖申克的救赎 非暴力沟通 流浪地球 乌合之众 Animal Farm 学习之道 深入浅出 Docker MySQL 必知必会 BTW, 想读 != 一定要读","categories":[{"name":"Reading","slug":"Reading","permalink":"http://blog.codeand.fun/categories/Reading/"}],"tags":[{"name":"Reading","slug":"Reading","permalink":"http://blog.codeand.fun/tags/Reading/"}]},{"title":"Binary Search Tree Iterator","slug":"Binary-Search-Tree-Iterator","date":"2020-03-31T10:55:25.000Z","updated":"2020-04-02T14:43:48.831Z","comments":true,"path":"2020/03/31/Binary-Search-Tree-Iterator/","link":"","permalink":"http://blog.codeand.fun/2020/03/31/Binary-Search-Tree-Iterator/","excerpt":"","text":"貌似又是一道之前做了，但是没写题解的题目。 今天的题目是Binary Search Tree Iterator。 这道题要求我们按从小到大的顺序返回二叉搜索树的值，而我们知道二叉搜索树的中序遍历就是从小到大的，所以问题就变成了，对一个二叉树的中序遍历问题。 因为之前总结过二叉树遍历，所以这里我们可以套用当时提到的三种方法来解这道题： 递归由于题目只要求了next()和hasNext()的时间复杂度，所以我们可以在构造器中对二叉树进行遍历，然后存储下来： 123456789101112131415161718192021222324252627class BSTIterator &#123;public: vector&lt;int&gt; vec; int index; BSTIterator(TreeNode* root) &#123; index = 0; inorderTraversal(root); &#125; void inorderTraversal(TreeNode *root) &#123; if (root) &#123; inorderTraversal(root-&gt;left); vec.push_back(root-&gt;val); inorderTraversal(root-&gt;right); &#125; &#125; /** @return the next smallest number */ int next() &#123; return vec[index++]; &#125; /** @return whether we have a next smallest number */ bool hasNext() &#123; return index != vec.size(); &#125;&#125;; 这样next()和hasNext()的时间复杂度肯定是O(1)的，但是空间复杂度却是O(n)，而题目要求的是O(h)。 基于栈进行迭代。基于栈对二叉树进行迭代的中序遍历大体可以分为两部： 不断地把先左节点移动，并把节点压入栈中（以下简称 step 1)。 弹出栈顶节点，并输出，然后先右节点方向移动（以下简称 step 2)。 一旦做完以上两步，我们就输出了一个值。 因为当时是在一个循环中实现的，所以和现在的情况是不一样的，root是在构造器中输入的，所以我们得在构造器中就把root压入栈中，为了不把过程弄的复杂，所以我们在构造器中就直接把 step 1 给做完，然后在next()中把两步的顺序倒过来，即先执行 step 2 然后执行 step 1，当然 step 2 中的输出操作显然要放到最后来做。因为在两个地方都进行了 step 1，所以我们可以把它抽象成一个单独的函数pushleft： 1234567891011121314151617181920212223242526class BSTIterator &#123;public: stack&lt;TreeNode *&gt; st; BSTIterator(TreeNode* root) &#123; pushleft(root); &#125; void pushleft(TreeNode *root) &#123; while(root) &#123; st.push(root); root = root-&gt;left; &#125; &#125; /** @return the next smallest number */ int next() &#123; auto root = st.top(); st.pop(); pushleft(root-&gt;right); return root-&gt;val; &#125; /** @return whether we have a next smallest number */ bool hasNext() &#123; return !st.empty(); &#125;&#125;; 因为基于栈的遍历算法的空间复杂度是O(h)，所以上面这个算法的空间复杂度也是O(h)（其实也很好理解，因为栈要临时存放节点个数最大就是 h），然后hasNext()的时间复杂度显然也是O(1)。下面的问题就是，next()的时间复杂度是否是O(1)。 如果我们仔细观察一下题目的话，我们会发现它要求的是平均时间复杂度，因为一颗有n个节点的树进行遍历，我们需要做n次st.push，同时next()我们也要调用n次才能遍历整棵树，所以n / n = 1，即平均时间复杂度为O(1)。 莫里斯遍历我们先看下莫里斯遍历的代码： 1234567891011121314151617181920212223TreeNode *GetRightLeaf(TreeNode *root, TreeNode *end) &#123; while(root-&gt;right &amp;&amp; root-&gt;right != end) root = root-&gt;right; return root;&#125;void inorderTraversal(TreeNode* root) &#123; while(root) &#123; if (root-&gt;left) &#123; TreeNode *p = GetRightLeaf(root-&gt;left, root); if (p-&gt;right == root) &#123; p-&gt;right = nullptr; cout &lt;&lt; root-&gt;val &lt;&lt; endl; root = root-&gt;right; &#125; else &#123; p-&gt;right = root; root = root-&gt;left; &#125; &#125; else &#123; cout &lt;&lt; root-&gt;val &lt;&lt; endl; root = root-&gt;right; &#125; &#125;&#125; 几乎可以什么都不用改的情况下，把代码移植过去： 12345678910111213141516171819202122232425262728293031323334353637383940414243class BSTIterator &#123;public: TreeNode *root; TreeNode *GetRightLeaf(TreeNode *root, TreeNode *end) &#123; while(root-&gt;right &amp;&amp; root-&gt;right != end) root = root-&gt;right; return root; &#125; BSTIterator(TreeNode* _root):root(_root) &#123; &#125; /** @return the next smallest number */ int next() &#123; int res = -1; while(root) &#123; if (root-&gt;left) &#123; TreeNode *p = GetRightLeaf(root-&gt;left, root); if (p-&gt;right == root) &#123; p-&gt;right = nullptr; // cout &lt;&lt; root-&gt;val &lt;&lt; endl; res = root-&gt;val; root = root-&gt;right; break; &#125; else &#123; p-&gt;right = root; root = root-&gt;left; &#125; &#125; else &#123; // cout &lt;&lt; root-&gt;val &lt;&lt; endl; res = root-&gt;val; root = root-&gt;right; break; &#125; &#125; return res; &#125; /** @return whether we have a next smallest number */ bool hasNext() &#123; return root != nullptr; &#125;&#125;; 这个的空间复杂度显然是O(1)，而时间复杂度，我们可以这样理解，每个节点都会被访问两遍，即O(2n)，而next()要调用 n 次，所以时间复杂度是O(2n / 2) = O(2) = O(1)。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"Tree","slug":"Tree","permalink":"http://blog.codeand.fun/tags/Tree/"},{"name":"Stack","slug":"Stack","permalink":"http://blog.codeand.fun/tags/Stack/"},{"name":"Design","slug":"Design","permalink":"http://blog.codeand.fun/tags/Design/"}]},{"title":"Evaluate Reverse Polish Notation","slug":"Evaluate-Reverse-Polish-Notation","date":"2020-03-31T09:29:10.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2020/03/31/Evaluate-Reverse-Polish-Notation/","link":"","permalink":"http://blog.codeand.fun/2020/03/31/Evaluate-Reverse-Polish-Notation/","excerpt":"","text":"因为最近在总结 LeetCode 中 Stack 标签下做过的题目，然后这道题做了但是没有写题解，所以补充一下。 一道Medium的题目，但是数据结构课上提到栈时，都会举这个例子才对，所以这道题挺简单的。 因为输入的已经是解析好的token了，所以不用额外的做 parse 的工作。我们只需要用一个栈来保存操作树即可。 当遇到一个操作数时，就压入栈中。 当遇到一个操作符时，就弹出两个操作数，然后根据操作符对这两个操作数进行操作，并将结果压入栈中。 由于题目保证了输入一定是正确的，所以很多判断都可以省略掉。然后又一个需要主要的就是栈是后进先出的，所以操作数的顺序不要弄反了就好了。 12345678910111213141516171819202122232425bool isOp(const string &amp;s) &#123; return s.size() == 1 &amp;&amp; (s[0] == '+' || s[0] == '-' || s[0] == '*' || s[0] == '/');&#125;int calc(int a, char op, int b) &#123; switch(op) &#123; case '+': return a + b; case '-': return a - b; case '*': return a * b; case '/': return a / b; &#125; return -1;&#125;int evalRPN(vector&lt;string&gt;&amp; tokens) &#123; stack&lt;int&gt; st; for(auto &amp;s: tokens) &#123; if (!isOp(s)) &#123; st.push(atoi(s.c_str())); &#125; else &#123; int b = st.top(); st.pop(); int a = st.top(); st.pop(); st.push(calc(a, s[0], b)); &#125; // else return -1; &#125; return st.top();&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"Stack","slug":"Stack","permalink":"http://blog.codeand.fun/tags/Stack/"}]},{"title":"Gitea + Drone CI/CD","slug":"Gitea-Drone-CI-CD","date":"2020-03-27T20:38:51.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2020/03/27/Gitea-Drone-CI-CD/","link":"","permalink":"http://blog.codeand.fun/2020/03/27/Gitea-Drone-CI-CD/","excerpt":"","text":"最近想实践一下 DevOps，所以准备搭建一套代码托管和CI/CD 系统。 技术选型代码托管代码托管系统的选择其实并不多： Gitea Gogs GitLab 由于 Gitlab 资源占用过大，所以可以直接去除（毕竟这个系统只有我一个人在用，而且只有一台1核2G的服务器）。 Gitea是脱胎于Gogs的，在Gogs上做了较多的扩展，而且迭代的也毕竟快。Gitea对现有的代码托管做了横向对比,我们可以看出来Gitea几乎是最优选择。 Gitea有一个比较显著的缺点，它没有像Gitlab一样内置了CI/CD，所以我们必须搭另外一套CI/CD系统。 CI/CD对现有的 CI/CD 进行了一下调研: Jenkins 优点：最为流行，出现坑的容易找到解决方案 缺点：用 Java 编写，过于笨重 GitLab CI 优点：据说很好用 缺点：笨重 Drone 优点：轻量级，支持Gitea 缺点：生态不够丰富，文档差 在这里我们选择Drone作为CI/CD，主要原因当然是因为只有它轻量级啊。 Gitea在安装Gitea和Drone时，我们都选择使用docker-compose来管理，因此需要先安装docker和docker-compose。 创建一个gitea文件夹，并在该文件夹下创建docker-compose.yml文件： 1234567891011121314151617181920212223242526version: \"2\"networks: gitea: external: falseservices: server: image: gitea/gitea:1.11 environment: - USER_UID=1000 - USER_GID=1000 - RUN_MODE=prod - SSH_PORT= 3022 #SSH端口 - SSH_DOMAIN= #IP地址或URL - DISABLE_REGISTRATION=False #取消注册 restart: always networks: - gitea volumes: - ./gitea:/data - /etc/timezone:/etc/timezone:ro - /etc/localtime:/etc/localtime:ro ports: - \"3000:3000\" - \"3022:3022\" 这里面需要注意的是，设置SSH_PORT和SSH_DOMAIN，这样 gitea 生成的 repo SSH 链接才是能直接使用的形式。 填写完后，直接docker-compose up -d开启服务即可，第一次登陆时，会跳出一个安装页面，可以设置所使用的数据库和管理员账号，同时要记得检查一下 SSH 端口和域名是否正确。 DroneDrone的安装比Gitea复杂的多，同时需要先在Gitea中创建OAuth2应用程序： 打开Gitea的页面 -&gt; 个人信息 -&gt; 应用 -&gt; 管理 OAuth2 应用程序 应用名称填什么都无所谓，但是重定向 URL 比较重要，要填 Drone服务的地址（虽然现在还没启动），比如说，你的 Drone 的 ip 地址为1.2.3.4，Drone端口的为8000，那么就可以填http://1.2.3.4:8000。 创建后会得到一个客户端ID和客户端密钥。这时，Gitea的设置就已经完成了。 为了让Drone Server和Drone Runer能够通过RPC连接，我们需要生成RPC密钥，可以在 shell 中使用该命令来生成随机数，用该随机数作为 RPC 的密钥 1$ openssl rand -hex 16 上面的操作中可以得到： 客户端 ID 客户端密钥 RPC 密钥 创建一个drone文件夹并在其中创建一个docker-compose.yml文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243version: \"3.5\"networks: drone: name: drone_networkservices: drone-server: image: drone/drone:1 ports: - 8000:80 - 443:443 networks: - drone volumes: - ./drone-data:/var/lib/drone - /var/run/docker.sock:/var/run/docker.sock restart: always environment: - DRONE_GITEA_CLIENT_ID= # Gitea 客户端ID - DRONE_GITEA_CLIENT_SECRET= # Gitea 客户端密钥 - DRONE_GITEA_SERVER= # Gitea URL 地址 - DRONE_GITEA=true - DRONE_RPC_SECRET= # Drone RPC 密钥 - DRONE_SERVER_HOST= # Drone URL,可以填域名或 ip:port - DRONE_SERVER_PROTO=http # Drone 所使用的协议 http 或者 https # 由于我的 Gitea 的设置是只允许登陆用户访问代码的，所以 Git 需要 Auth - DRONE_GIT_ALWAYS_AUTH=true - DRONE_GIT_USERNAME= # Gitea 用户名 - DRONE_GIT_PASSWORD= # Gitea 密码 drone-agent: image: drone/drone-runner-docker:1 restart: always depends_on: - drone-server networks: - drone volumes: - /var/run/docker.sock:/var/run/docker.sock environment: - DRONE_RPC_SECRET= # 这里的密钥要和 Server 一样 - DRONE_RPC_PROTO=http - DRONE_RPC_HOST= # 和上面的 DRONE_SERVER_HOST 和Gitea同理，我们只需要在docker-compose up -d即可。 第一次打开 Drone 会先跳到 Gitea 进行验证。由于打开 Drone 会验证 Gitea 是否登陆，所以不用担心 Drone 的页面直接暴露到公网。 测试 Drone 和 Gitea 在 Gitea 中创建一个 repo 在 Drone 激活该 repo 创建公钥并加入到 gitea 中（这一步和 Github 类似） 将 repo clone 到本地 创建一个.drone.yml文件： git commit and push .drone.yml的样例如下： 12345678910kind: pipelinetype: dockername: defaultsteps:- name: greeting image: alpine commands: - echo hello - echo world 关于.drone.yml的信息可以查看官方文档。 之后估计也会写一篇 blog 对 Drone 的使用进行下总结。","categories":[{"name":"DevOps","slug":"DevOps","permalink":"http://blog.codeand.fun/categories/DevOps/"}],"tags":[{"name":"Gitea","slug":"Gitea","permalink":"http://blog.codeand.fun/tags/Gitea/"},{"name":"Drone","slug":"Drone","permalink":"http://blog.codeand.fun/tags/Drone/"},{"name":"CI/CD","slug":"CI-CD","permalink":"http://blog.codeand.fun/tags/CI-CD/"}]},{"title":"Binary Tree (Preorder|Inorder|Postorder) Traversal","slug":"Binary-Tree-Preorder-Inorder-Postorder-Traversal","date":"2020-03-24T12:10:21.000Z","updated":"2020-04-02T14:43:48.831Z","comments":true,"path":"2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/","link":"","permalink":"http://blog.codeand.fun/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/","excerpt":"","text":"今天将二叉树的先、中、后遍历的做了一些总结。三种遍历都有三种写法： 递归 时间复杂度：O(n) 空间复杂度：O(h)，h为树高 基于栈进行迭代： 时间复杂度:O(n) 空间复杂度：O(n) 莫里斯算法： 时间复杂度：O(n) 空间复杂度：O(1) 接下来内容有一下几个部分组成： 首先介绍二叉树先、中、后序遍历的含义 递归算法 基于栈的迭代算法 莫里斯算法 二叉树 &amp; 先、中、后序遍历 先序遍历： 访问当前节点 遍历左子树 遍历右子树 中序遍历： 遍历左子树 访问当前节点 遍历右子树 后序遍历： 遍历左子树 遍历右子树 访问当前节点 如上图中显示的二叉树中，先、中、后序遍历分别为： 先序：1 2 3 4 5 中序：3 2 4 1 5 后序：3 4 2 5 1 递归算法已知三种遍历的含义之后，我们可以很容易的写出三种遍历的递归算法: 1234567891011121314151617181920212223void prevorderTraversal(TreeNode *root) &#123; if (root) &#123; cout &lt;&lt; root-&gt;val &lt;&lt; endl; prevorderTraversal(root-&gt;left); prevorderTraversal(root-&gt;right); &#125;&#125;void inorderTraversal(TreeNode *root) &#123; if (root) &#123; inorderTraversal(root-&gt;left); cout &lt;&lt; root-&gt;val &lt;&lt; endl; inorderTraversal(root-&gt;right); &#125;&#125;void postorderTraversal(TreeNode *root) &#123; if (root) &#123; postorderTraversal(root-&gt;left); postorderTraversal(root-&gt;right); cout &lt;&lt; root-&gt;val &lt;&lt; endl; &#125;&#125; 由于递归算法比较简单，所以这里不做过多的说明。 为了方便，访问节点时，只是输出节点的值。 基于栈的迭代算法基于栈的迭代算法——先序遍历基于栈的遍历算法中，先序遍历是最简单的。因为先序遍历本身可以进行尾递归优化，所以很容易用stack对递归调用进行模拟： 12345678910void preorderTraversal(TreeNode *root) &#123; stack&lt;TreeNode *&gt; st; if (root) st.push(root); while(!st.empty()) &#123; root = st.top(); st.pop(); cout &lt;&lt; root-&gt;val &lt;&lt; endl; if (root-&gt;right) st.push(root-&gt;right); if (root-&gt;left) st.push(root-&gt;left); &#125;&#125; 需要注意的是，因为栈用后进先出的特性，所以要先将右子树压入栈中，然后再将左子树压入栈中。 基于栈的迭代算法——中序遍历 我们以上图为例子，其中圆圈表示树中的节点，而三角形表示子树。其中的序号为访问顺序，我们可以发现，进行中序遍历的二叉树都符合这样的移动规律： 先一直往左孩子的方向移动，直到没有左孩子。 然后访问该节点，并遍历其右子树（这时相当于对其右子树进行 1、2、3步）。 最后返回到其父节点并从第 2 步开始。 为了方便实现和代码的简洁，我们可以把观察到规律转换一下： 先一直往左孩子的方向移动，直到当前节点为空，同时把所有经过的节点压入栈中。 如果栈不空，则将栈顶弹出并访问，向右孩子移动并返回第一步。 因此我们可以写出如下代码： 12345678910111213void inorderTraversal(TreeNode *root) &#123; stack&lt;TreeNode *&gt; st; while(root || !st.empty()) &#123; while(root) &#123; st.push(root); root = root-&gt;left; &#125; // 栈一定不为空 root = st.top(); st.pop(); cout &lt;&lt; root-&gt;val &lt;&lt; endl; root = root-&gt;right; &#125;&#125; 基于栈的迭代算法——后序遍历 后序遍历与中序遍历有些类似，同样需要先一直往左孩子方向移动直到没有左孩子，但是后序遍历要先访问完右子树才能访问当前节点，因此对于栈顶节点是否要访问并弹出，我们需要判断其右子树是否被访问了。同时，因为后序遍历中，一颗树的根节点是最后访问的，所以我们可以根据右孩子是否被访问了来判断右子树是否被访问了。而我们知道，当访问完右孩子，就可以马上访问该节点了，所以我们可以维护一个指针，该指针指向上一次被访问的节点。通过判断上一次被访问的节点是否为右子树或者nullpter，我们就可以知道是否要访问该节点并弹栈了。 123456789101112131415161718void postorderTraversal(TreeNode* root) &#123; TreeNode *prev = nullptr; stack&lt;TreeNode *&gt; st; while(root || !st.empty()) &#123; while(root) &#123; st.push(root); root = root-&gt;left; &#125; root = st.top(); if (root-&gt;right == nullptr || root-&gt;right == prev) &#123; cout &lt;&lt; root &lt;&lt; right &lt;&lt; endl; prev = root; root = nullptr; st.pop(); &#125; else root = root-&gt;right; &#125; return res; &#125; 莫里斯算法莫里斯算法是一种用时间来换空间的二叉树遍历算法。他只需要O(1)的空间复杂度。 个人觉得它非常像中序线索树，所以我们先介绍中序线索树，然后再来理解莫里斯遍历。 中序线索树假设一颗二叉树有N个节点，因为每个节点有 2 个指向孩子的指针，所以我们就有了 2*N 个指向节点的指针。同时，因为根节点不需要指针指向它，所以我们就使用了2*N - (N-1) = N + 1个空指针。线索树的想法就是将这些空指针利用上，来加快遍历速度的。 对于上面的二叉树来说，其中序遍历的结果为[6 4 7 2 5 8 9 1 3]。 如果节点 A 被访问后，马上访问 B，我们就认为 A 是 B 的前驱，B 是 A 的后继。从中序遍历的结果可以看出 6 是 4 的前驱，4 是 6 的后继。 上图中，红色虚线表示后继，绿色虚线表示前驱，一般我们将前驱放在左孩子，后继放在右孩子中。为了区分一个节点的两个孩子指针到底是真的孩子，还是线索，一般需要在每个节点中增加两个flag 位来区分。 莫里斯算法——中序遍历因为中序线索树需要给每个节点都增加两个flag，但是因为很多时候我们不能修改二叉树节点的数据结构，所以它在很多情况是不适合的。通过观察我们可以发现，在建立完中序线索树后，一个节点的左子树中最右边的节点的后继线索是总指向该节点的。我们可以根据这个规律来判断当前节点是否需要访问，是向左孩子移动还是向右孩子移动。同时，因为遍历时不需要用到前驱，所以我们不用建立前驱的节点，只需要建立后继即可。 当我们访问节点root的时候： 如果它有左孩子，则找出左子树中最右边节点，并将该节点的右孩子设置为root（建立线索），并向左孩子移动。 如果它有左孩子，同时在找出左子树最右边节点的时候，如果发现某个节点的右孩子为root，则表示为该节点为左子树的最右边的节点，且已经建立了线索。这表示我们已经访问过左子树了。我们可以清除线索，访问root节点，并向右子树移动。 如果它没有左孩子，则直接访问root，并向右子树移动。 1234567891011121314151617181920212223TreeNode *GetRightLeaf(TreeNode *root, TreeNode *end) &#123; while(root-&gt;right &amp;&amp; root-&gt;right != end) root = root-&gt;right; return root;&#125;void inorderTraversal(TreeNode* root) &#123; while(root) &#123; if (root-&gt;left) &#123; TreeNode *p = GetRightLeaf(root-&gt;left, root); if (p-&gt;right == root) &#123; p-&gt;right = nullptr; cout &lt;&lt; root-&gt;val &lt;&lt; endl; root = root-&gt;right; &#125; else &#123; p-&gt;right = root; root = root-&gt;left; &#125; &#125; else &#123; cout &lt;&lt; root-&gt;val &lt;&lt; endl; root = root-&gt;right; &#125; &#125;&#125; 莫里斯算法——先序遍历在莫里斯算法中，先序遍历与中序遍历非常想，只是访问root的节点的位置变了。在中序遍历中，我们总是在向右子树移动的时候访问root节点。而在先序遍历的中，我们总是在向左子树移动的时候访问root。当然，在没有左孩子的情况时，一样也是先访问root节点，再想右孩子移动。 当我们访问节点root的时候： 如果它有左孩子，则找出左子树中最右边节点，并将该节点的右孩子设置为root（建立线索），访问root节点，并向左孩子移动。 如果它有左孩子，同时在找出左子树最右边节点的时候，如果发现某个节点的右孩子为root，则表示为该节点为左子树的最右边的节点，且已经建立了线索。这表示我们已经访问过左子树了。我们可以清除线索，并向右子树移动。 如果它没有左孩子，则直接访问root，并向右子树移动。 因此代码如下： 1234567891011121314151617181920212223TreeNode *GetRightLeaf(TreeNode *root, TreeNode *end) &#123; while(root-&gt;right &amp;&amp; root-&gt;right != end) root = root-&gt;right; return root;&#125;void preorderTraversal(TreeNode* root) &#123; while(root) &#123; if (root-&gt;left) &#123; // if (root-&gt;right == nullptr) cout &lt;&lt; \"NULL\" &lt;&lt; endl; TreeNode *p = GetRightLeaf(root-&gt;left, root); if (p-&gt;right == root) &#123; p-&gt;right = nullptr; root = root-&gt;right; &#125; else &#123; p-&gt;right = root; cout &lt;&lt; root-&gt;val &lt;&lt; endl; root = root-&gt;left; &#125; &#125; else &#123; cout &lt;&lt; root-&gt;val &lt;&lt; endl; root = root-&gt;right; &#125; &#125;&#125; 莫里斯遍历——后序遍历 通过观察，我们可以发现先、中、后序遍历有上面这种规律，因此我们可以发现，当所有左子树被访问完了（这时只剩下一条由右孩子组成的边，这里为了简便，将其称为，右边），按逆序访问由右边即可。 当我们访问节点root的时候： 如果它有左孩子，则找出左子树中最右边节点，并将该节点的右孩子设置为root（建立线索），并向左孩子移动。 如果它有左孩子，同时在找出左子树最右边节点的时候，如果发现某个节点的右孩子为root，则表示为该节点为左子树的最右边的节点，且已经建立了线索。这表示我们已经访问过左子树了。我们可以清除线索，逆序访问左子树的右边。 如果它没有左孩子，并向右子树移动。 按上面的算法进行的话，会导致有一条右边没办法访问到，所以增加一个虚节点，该虚节点的左孩子为root,右孩子为空，即： 123456789101112131415161718192021222324252627282930313233343536373839404142TreeNode *GetRightLeaf(TreeNode *root, TreeNode *end) &#123; while(root-&gt;right &amp;&amp; root-&gt;right != end) root = root-&gt;right; return root;&#125;TreeNode *reverse(TreeNode *p, const function&lt;void(int)&gt; &amp;func) &#123; TreeNode *prev, *next; prev = nullptr; while(p) &#123; func(p-&gt;val); next = p-&gt;right; p-&gt;right = prev; prev = p; p = next; &#125; return prev;&#125;vector&lt;int&gt; postorderTraversal2(TreeNode* root) &#123; TreeNode node(0); node.left = root; root = &amp;node; auto func1 = [&amp;](int val) &#123; res.push_back(val); &#125;; auto func2 = [](int val) &#123;&#125;; while(root) &#123; if (root-&gt;left) &#123; TreeNode *p = GetRightLeaf(root-&gt;left, root); if (p-&gt;right == root) &#123; p-&gt;right = nullptr; p = reverse(root-&gt;left, func2); reverse(p, func1); root = root-&gt;right; &#125; else &#123; p-&gt;right = root; root = root-&gt;left; &#125; &#125; else root = root-&gt;right; &#125; return res;&#125; 为了使得空间复杂度为O(1)，在逆序访问时，我们通过“翻转链表”的方式进行逆序访问，而不是用栈来实现。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"Tree","slug":"Tree","permalink":"http://blog.codeand.fun/tags/Tree/"},{"name":"Stack","slug":"Stack","permalink":"http://blog.codeand.fun/tags/Stack/"}]},{"title":"LeetCode Stack Tag 总结","slug":"LeetCode-Stack-Tag-总结","date":"2020-03-23T10:03:40.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2020/03/23/LeetCode-Stack-Tag-总结/","link":"","permalink":"http://blog.codeand.fun/2020/03/23/LeetCode-Stack-Tag-%E6%80%BB%E7%BB%93/","excerpt":"","text":"准备按 Tag 过一遍之前刷过的 LeetCode，总结一些常用的技巧和套路。 题目列表 Name No Difficulty Blog Link Note Valid Parentheses 20 Easy https://blog.codeand.fun/2017/09/24/Valid-Parentheses/ 可以建一个右括号到左括号的map来使代码更加简洁 Simplify Path 71 Medium https://blog.codeand.fun/2019/03/02/Simplify-Path/ 用FSM的思想也可以解，可以用stringstream和getline进行字符串分割 Binary Tree Inorder Traversal 94 Medium https://blog.codeand.fun/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/ 递归、栈、莫里斯遍历 Binary Tree Zigzag Level Order Traversal 103 Medium https://blog.codeand.fun/2018/02/11/Binary-Tree-Zigzag-Level-Order-Traversal/ 用栈来模拟，可以避免逆序操作 Binary Tree Preorder Traversal 144 Medium https://blog.codeand.fun/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/ 递归、栈、莫里斯遍历 Binary Tree Postorder Traversal 145 Medium https://blog.codeand.fun/2020/03/24/Binary-Tree-Preorder-Inorder-Postorder-Traversal/ function对象+lambda表达式可以减少代码冗余。 Evaluate Reverse Polish Notation 150 Medium https://blog.codeand.fun/2020/03/31/Evaluate-Reverse-Polish-Notation/ Binary Search Tree Iterator 173 Medium https://blog.codeand.fun/2020/03/31/Binary-Search-Tree-Iterator/ 可以用递归、栈和莫里斯遍历来实现中序遍历 Verify Preorder Serialization of a Binary Tree 331 Medium https://blog.codeand.fun/2018/02/19/Verify-Preorder-Serialization-of-a-Binary-Tree/ ??这道题和栈好像没有关系啊，不用栈去想反而更简单更快 Flatten Nested List Iterator 341 Medium","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"Stack","slug":"Stack","permalink":"http://blog.codeand.fun/tags/Stack/"}]},{"title":"《 Java 编程思想》CH09 接口","slug":"《-Java-编程思想》CH09-接口","date":"2020-02-19T11:52:21.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2020/02/19/《-Java-编程思想》CH09-接口/","link":"","permalink":"http://blog.codeand.fun/2020/02/19/%E3%80%8A-Java-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8BCH09-%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法。 抽象类和抽象方法Java 提供一个叫做“抽象方法”的机制来建立通用接口，这样不同的子类可以用不同的方式表示此接口。如abstract void fun()。包含抽象方法的类叫做抽象类，如果一个类包含一个或多个抽象方法，则该类必须限定为抽象的，如abstract class ClassName。 如果一个从一个抽象类中继承，我们需要为基类中所有的抽象方法提供定义，否则该导出类也是抽象类，需要用abstract进行限定。 123456abstract class Instrument &#123; private int i; public abstract void play(Note n); public String what() &#123; return \"Instrument\"; &#125; public abstract void adjust();&#125; 接口interface关键字可以产生一个完全抽象的类，它允许创建者确定方法名，参数列表和返回类型，但是没有任何方法体。接口只提供了形式，但是没有提供任何实现。通常，接口被用来建立类之间的协议。之所以有了抽象类后还需要接口是因为：一个类可以实现多个接口，从而实现类似多继承的特性。 接口有两种访问权限： public 包访问权限 接口中可以包含域，但是这些域隐式地是public和static的。接口中的方法是public的，因此类在实现接口时，必须指定方法为public的。 12345678910111213141516171819interface InstrumentInterface &#123; int VALUE = 5; // static final public void play(Note n); // public void adjust();&#125;class Wind implements InstrumentInterface &#123; public void play(Note n) &#123; System.out.println(\"Wind.play() n = \" + n); &#125; public void adjust() &#123; &#125; public String what() &#123; return \"Wind\"; &#125;&#125; 完全解耦策略设计模式：创建一个能够根据所传递的参数对象的不同而具有不同行为的方法。这类方法包含要执行算法中固定不变的部分，而“策略”包含变化的部分。 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.company.ch09;import java.util.Arrays;class Processor &#123; public String name() &#123; return getClass().getSimpleName(); &#125; Object process(Object input) &#123; return input; &#125;&#125;class Upcase extends Processor &#123; String process(Object input) &#123; // 协变返回类型 return ((String) input).toUpperCase(); &#125;&#125;class Downcase extends Processor &#123; String process(Object input) &#123; return ((String) input).toLowerCase(); &#125;&#125;class Splitter extends Processor &#123; @Override String process(Object input) &#123; return Arrays.toString(((String) input).split(\" \")); &#125;&#125;public class Apply &#123; public static void process(Processor p, Object s) &#123; System.out.println(\"Using Processor p.name() = \" + p.name()); System.out.println(p.process(s)); &#125; public static String s = \"Disagreement with beliefs is by definition incorrect\"; public static void main(String[] args) &#123; process(new Upcase(), s); process(new Downcase(), s); process(new Splitter(), s); &#125;&#125; 如果Filter类与Processer有相同的接口，但是它不是继承与Processer，那么它就不能被Apply.proceess所使用。这是因为Processer和Apply过于耦合了，而导致我们没法复用代码。我们可以将Processer转变成接口来解耦。我们可以依据接口来实现Filter，也可以用适配器设计模式来完成。设配器中代码将接收已有的接口/代码，实现需要的接口： 123456789101112class FilterAdapter implements Processor &#123; Filter filter; public FilterAdapter(Filter filter) &#123; this.filter &#x3D; filter; &#125; public String name() &#123; return filter.name(); &#125; public Waveform process(Object object) &#123; return filter.process((Waveform)objec); &#125;&#125; Java 中的多重继承Java 可以组合多个接口来实现了类似C++中的多继承。 实现一个接口需要保证接口中所有方法类中都有，该方法可以继承自基类。 使用接口的原因： 为了能够向上转型为多个基类 防止客户端创建该类的对象，并确保这个仅仅是一个接口 如果要创建不带任何方法定义和成员变量的基类，那就应该选择接口而不是抽象类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.company.ch09;interface CanFight &#123; void fight();&#125;interface CanSwim &#123; void swim();&#125;interface CanFly &#123; void fly();&#125;class ActionCharacter &#123; public void fight() &#123; &#125;&#125;class Hero extends ActionCharacter implements CanFight, CanFly, CanSwim &#123; @Override public void swim() &#123; &#125; @Override public void fly() &#123; &#125; // 注意到这里fight()函数是继承与ActionCharac&#125;public class Adventure &#123; public static void t(CanFight x) &#123; x.fight(); &#125; public static void u(CanSwim x) &#123; x.swim(); &#125; public static void v(CanFly x) &#123; x.fly(); &#125; public static void w(ActionCharacter x) &#123; x.fight(); &#125; public static void main(String[] args) &#123; Hero h = new Hero(); t(h); u(h); v(h); w(h); &#125;&#125; 通过继承来扩展接口 接口可以继承一个或多个接口 接口中方法签名同样是由函数名和参数列表组成的，因此如果两个接口有相同函数名和参数类型的方法，并且返回类型不相同的话，则不能同时implement。 1234567891011interface CanFight &#123; void fight();&#125;interface CanSwim &#123; void swim();&#125;interface CanFightAndSwim extends CanFight, CanSwim &#123;&#125; 接口中的域接口中的的域都是 static 和 final 的，所以接口用来创建常量组，接口中定义的域不能是”空final“，但是可以被非常量表达式初始化。现在建议使用enum来创建。 12345public interface RandVals &#123; Random RAND = new Random(24); int RANDOM_INT = RAND.nextInt(10); long RANDOM_LONG = RAND.nextLong(20) * 10;&#125; 嵌套接口接口可以嵌套在类或其他皆苦中。 嵌套在类中的接口除了 public 和包访问权限，还有 private 访问权限。 嵌套在接口中的接口自动是 public 访问权限。","categories":[{"name":"《Java编程思想》","slug":"《Java编程思想》","permalink":"http://blog.codeand.fun/categories/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.codeand.fun/tags/Java/"},{"name":"阅读笔记","slug":"阅读笔记","permalink":"http://blog.codeand.fun/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"name":"《Java编程思想》","slug":"《Java编程思想》","permalink":"http://blog.codeand.fun/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"},{"name":"后端","slug":"后端","permalink":"http://blog.codeand.fun/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"《 Java 编程思想》CH08 多态","slug":"《-Java-编程思想》CH08-多态","date":"2020-02-18T11:19:00.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2020/02/18/《-Java-编程思想》CH08-多态/","link":"","permalink":"http://blog.codeand.fun/2020/02/18/%E3%80%8A-Java-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8BCH08-%E5%A4%9A%E6%80%81/","excerpt":"","text":"在面向对象的程序设计语言中，多态是继数据抽象和继承之后的第三种基本特征。 多态通过分离做什么和怎么做，从另一个角度将接口和实现分离开来。 “封装”通过合并特征和行为来创建新的数据类型。“实现隐藏”则通过将细节“私有化”把接口和实现分离开来，而多态的作用则是消除类型之间的耦合关系。 再论向上转型 &amp; 转机 对象既可以作为它自己本身的类型使用，也可以作为它的基类使用，而这种把某个对象的引用视为其基类的引用的做法被称为“向上转型” 将一个方法调用同一个方法主体关联起来被称为绑定。 若在程序执行前进行绑定（如果有的话，由编译器和链接器实现），叫做前期绑定。 若在运行时根据对象的类型进行绑定，则叫做后期绑定，也叫做动态绑定或运行时绑定。 Java 中除了 static 方法和 final 方法（private 方法属于 final 方法）外，其他所有方法都是后期绑定的。 Java 用动态绑定实现了多态后，我们可以只编写与基类相关的代码，而这些代码可以对所有该基类的导出类正确运行。 多态的例子可以参考练习2。 在一个设计良好的 OOP 程序中，大多数或所有方法都只与基类接口通信。这样的程序是可扩展的，因为可以从通用的基类继承出新的数据类型，从而新添加一些功能。 域没有多态。 如果一个方法是静态的，那么它的行为就不具有多态性。静态方法是与类，而不是与单个对象相关联的。 由于 final 方法是无法覆盖的，所以 private 也是无法覆盖的，因此没办法进行动态绑定。即只有非 private 方法可以覆盖，但是“覆盖”private 方法编译器不会报错，但运行结果往往与预期不符： 12345678910111213141516171819package com.company.ch08;public class PrivateOverride &#123; private void func() &#123; System.out.println(\"private func()\"); &#125; public static void main(String[] args) &#123; PrivateOverride privateOverride = new Derived(); privateOverride.func(); &#125;&#125;class Derived extends PrivateOverride &#123; public void func() &#123; // 这里其实没有覆盖。 System.out.println(\"Derived func()\"); &#125;&#125;// private func() 构造器和多态构造器不具有多态性，它们实际上是 static 方法，只不过该 static 是隐式声明的。 构造器的调用顺序 基类的构造器总是在导出类的构造过程中调用，而且按照继承层次逐渐向上链接，以使每个基类的构造器都能得到调用。 在导出类的构造器主体中，如果没有明确指定调用某个基类构造器，它会默默地调用默认构造器。如果不存在默认构造器，编译器就会出错（如果某个类没有任何构造器，则编译器会给他添加一个默认构造器） 构造器的调用顺序： 调用基类构造器。 按照声明顺序调用成员的初始化方法。 调用导出类的构造器的主体。 继承与清理Java 中通常不需要考虑清理的问题，垃圾回收机制会解决大部分问题，但是如果真的需要进行清理操作时，我们需要手动调用某个特定的函数进行清理操作。因为继承的原因，我们在覆盖基类的清理函数时，需要调用基类版本的清理函数。通常在导出类清理函数的末尾。同时如果成员对象也有需要清理的话，也需要在清理函数中调用该成员的清理函数。调用的原则就是：清理的顺序应该与初始化的顺序相同。 如果某些成员对象存在于其他一个或多个对象共享的情况下，我们不能简单的调用其清理函数，我们可以使用“引用计数”来跟踪访问着共享对象的对象数量（就是C++中的shared_ptr）。 构造器内部的多态方法的行为：如果在一个构造器的内部调用正在构造的对象的某个动态绑定方法，会发生什么？ 1234567891011121314151617181920212223242526272829303132333435package com.company.ch08;class Glyph &#123; void draw() &#123; System.out.println(\"Glyph.draw()\"); &#125; Glyph() &#123; System.out.println(\"Glyph() before draw()\"); draw(); System.out.println(\"Glyph() after draw()\"); &#125;&#125;class RoundGlyph extends Glyph &#123; private int radius = 1; RoundGlyph(int r) &#123; radius = r; System.out.println(\"RoundGlyph.RoundGlyph(), radius = \" + radius); &#125; @Override void draw() &#123; System.out.println(\"RoundGlyph.draw(), radius = \" + radius); &#125;&#125;public class PolyConstructors &#123; public static void main(String[] args) &#123; new RoundGlyph(5); &#125;&#125;// Glyph() before draw()// RoundGlyph.draw(), radius = 0// Glyph() after draw()// RoundGlyph.RoundGlyph(), radius = 5 从上面的输出可以看出，在基类中调用动态方法，的确会调用到对应导出类的方法，但是导出类的域却未完成初始化。 初始化实例的过程： 在其他任何事物发生之前，将分配给对象的存储空间初始化成二进制的零 调用基类构造器 按声明顺序调用成员的初始化方法 调用导出类的构造器主题。 在构造器内唯一能够安全调用的那些方法是基类中 final 方法（private 方法属于 final 方法） 协变返回类型Java SE5 中添加了协变返回类型，它表示在导出类中的被覆盖方法可以返回基类方法的返回类型的某种导出类型。 1234567891011121314151617181920212223242526272829303132333435363738394041package com.company.ch08;class Grain &#123; @Override public String toString() &#123; return \"Grain\"; &#125;&#125;class Wheat extends Grain &#123; @Override public String toString() &#123; return \"Wheat\"; &#125;&#125;class Mill &#123; Grain process() &#123; return new Grain(); &#125;&#125;class WheatMill extends Mill &#123; @Override Wheat process() &#123; // 关键在这里，原本返回类型应该是 Grain，而这里使用了 Grain 的导出类 Wheat return new Wheat(); &#125;&#125;public class CovariantReturn &#123; public static void main(String[] args) &#123; Mill mill = new Mill(); Grain grain = mill.process(); System.out.println(\"grain = \" + grain); mill = new WheatMill(); grain = mill.process(); System.out.println(\"grain = \" + grain); &#125;&#125;// grain = Grain// grain = Wheat 用继承进行设计我们应该首先选择“组合”，尤其是不能十分确定应该使用哪种方法时。组合不会强制我们的程序谁叫进入继承的层次结构。而且，组合更加灵活，他可以动态选择类型。 12345678910111213141516171819202122232425262728293031323334353637383940package com.company.ch08;class Actor &#123; public void act() &#123;&#125;&#125;class HappyActor extends Actor &#123; @Override public void act() &#123; System.out.println(\"HappyActor\"); &#125;&#125;class SadActor extends Actor &#123; @Override public void act() &#123; System.out.println(\"SadActor\"); &#125;&#125;class Stage &#123; private Actor actor = new HappyActor(); public void change() &#123; actor = new SadActor(); &#125; public void performPlay() &#123; actor.act(); &#125;&#125;public class Transmogrify &#123; public static void main(String[] args) &#123; Stage stage = new Stage(); stage.performPlay(); stage.change(); stage.performPlay(); &#125;&#125;// HappyActor// SadActor 我们通过在运行时将引用与不同的对象重新绑定起来，可以让我们在运行期间获得动态灵活性（也称为“状态模式”）。 继承表示行为间的差异，字段表示状态上的变化。 纯继承与扩展 is-a 关系（纯继承）：只覆盖在基类中已有的方法，不对其进行扩展 导出类和基类有完全相同的接口。 只需要从导出类向上转型，永远不需要知道正在处理的对象的确切类型 is-like-a 关系：对基类进行了扩展 导出类接口中扩展部分不能被基类访问。 向下转型与运行时类型识别在 Java 中，所有转型都会得到检查。即使我们只是进行一次普通的加括弧形式的类型转换，在进入运行期时仍然会对其进行检查，如果不是我们想要转换的类型，那么会返回一个 ClassCastException。 练习练习112345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.company.ch08;public class Cycle &#123; void run() &#123; System.out.println(\"Cycle run\"); &#125;&#125;class Unicycle extends Cycle &#123; @Override void run() &#123; System.out.println(\"Unicycle run\"); &#125;&#125;class Bicycle extends Cycle &#123; @Override void run() &#123; System.out.println(\"Bicycle run\"); &#125;&#125;class Tricycle extends Cycle &#123; @Override void run() &#123; System.out.println(\"Tricycle run\"); &#125;&#125;class Test &#123; static void ride(Cycle c) &#123; c.run(); &#125; public static void main(String[] args) &#123; Unicycle unicycle = new Unicycle(); Bicycle bicycle = new Bicycle(); Tricycle tricycle = new Tricycle(); unicycle.run(); bicycle.run(); tricycle.run(); &#125;&#125;// Unicycle run// Bicycle run// Tricycle run 练习2123456package com.company.ch08;public class Shape &#123; public void draw() &#123;&#125; public void erase() &#123;&#125;&#125; 12345678910111213package com.company.ch08;public class Circle extends Shape&#123; @Override public void draw() &#123; System.out.println(\"Circle draw\"); &#125; @Override public void erase() &#123; System.out.println(\"Circle erase\"); &#125;&#125; 12345678910111213package com.company.ch08;public class Square extends Shape&#123; @Override public void draw() &#123; System.out.println(\"Square draw\"); &#125; @Override public void erase() &#123; System.out.println(\"Square erase\"); &#125;&#125; 12345678910111213package com.company.ch08;public class Triangle extends Shape &#123; @Override public void draw() &#123; System.out.println(\"Triangle draw\"); &#125; @Override public void erase() &#123; System.out.println(\"Triangle erase\"); &#125;&#125; 12345678910111213141516package com.company.ch08;import java.util.Random;// 工厂模式public class RandomShapeGenerator &#123; private Random random = new Random(47); public Shape next() &#123; switch (random.nextInt(3)) &#123; default: case 0: return new Circle(); case 1: return new Square(); case 2: return new Triangle(); &#125; &#125;&#125; 123456789101112131415161718192021222324package com.company.ch08;public class Shapes &#123; private static RandomShapeGenerator randomShapeGenerator = new RandomShapeGenerator(); public static void main(String[] args) &#123; Shape[] shapes = new Shape[9]; for (int i = 0;i &lt; 9;i++) &#123; shapes[i] = randomShapeGenerator.next(); &#125; for (Shape shape: shapes) &#123; shape.draw(); &#125; &#125;&#125;// Triangle draw// Triangle draw// Square draw// Triangle draw// Square draw// Triangle draw// Square draw// Triangle draw// Circle draw 练习31234567public class Shape &#123; public void draw() &#123;&#125; public void erase() &#123;&#125; public void info() &#123; System.out.println(\"Shape info\"); &#125;&#125; 即使导出类没有覆盖它，但是由于继承的原因，导出类任然会有该方法。 123456789101112131415161718package com.company.ch08;public class Circle extends Shape&#123; @Override public void draw() &#123; System.out.println(\"Circle draw\"); &#125; @Override public void erase() &#123; System.out.println(\"Circle erase\"); &#125; @Override public void info() &#123; System.out.println(\"Circle info\"); &#125;&#125; 123456789101112131415161718192021222324package com.company.ch08;public class Shapes &#123; private static RandomShapeGenerator randomShapeGenerator = new RandomShapeGenerator(); public static void main(String[] args) &#123; Shape[] shapes = new Shape[9]; for (int i = 0;i &lt; 9;i++) &#123; shapes[i] = randomShapeGenerator.next(); &#125; for (Shape shape: shapes) &#123; shape.info(); &#125; &#125;&#125;// Shape info// Shape info// Circle info// Circle info// Shape info// Shape info// Shape info// Shape info// Circle info 如果只有一个导出类Circle覆盖了该方法，只有在正式类型为Circle的Shape调用info时，才会调用到覆盖后的方法，而其余的则是调用到基类的方法。 练习412345678910111213141516171819202122232425262728293031323334353637class Line extends Shape &#123; @Override public void draw() &#123; System.out.println(\"Line draw\"); &#125; @Override public void erase() &#123; System.out.println(\"Line erase\"); &#125;&#125;public class Shapes &#123; private static RandomShapeGenerator randomShapeGenerator = new RandomShapeGenerator(); public static void main(String[] args) &#123; Shape[] shapes = new Shape[9]; for (int i = 0;i &lt; 9;i++) &#123; shapes[i] = randomShapeGenerator.next(); &#125; for (Shape shape: shapes) &#123; shape.draw(); &#125; shapes[0] = new Line(); shapes[0].draw(); &#125;&#125;//Shape info//Shape info//Circle info//Circle info//Shape info//Shape info//Shape info//Shape info//Circle info 练习5123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.company.ch08;public class Cycle &#123; void run() &#123; System.out.println(\"Cycle run\"); &#125; int wheels() &#123; return 0; &#125;&#125;class Unicycle extends Cycle &#123; @Override void run() &#123; System.out.println(\"Unicycle run\"); &#125; @Override int wheels() &#123; return 1; &#125;&#125;class Bicycle extends Cycle &#123; @Override void run() &#123; System.out.println(\"Bicycle run\"); &#125; @Override int wheels() &#123; return 2; &#125;&#125;class Tricycle extends Cycle &#123; @Override void run() &#123; System.out.println(\"Tricycle run\"); &#125; @Override int wheels() &#123; return 3; &#125;&#125;class Test &#123; static void ride(Cycle c) &#123; c.run(); &#125; public static void main(String[] args) &#123; Unicycle unicycle = new Unicycle(); Bicycle bicycle = new Bicycle(); Tricycle tricycle = new Tricycle(); unicycle.run(); bicycle.run(); tricycle.run(); Cycle[] cycles = new Cycle[]&#123;unicycle, bicycle, tricycle&#125;; for (Cycle cycle: cycles) &#123; System.out.println(\"cycle.wheels() = \" + cycle.wheels()); &#125; &#125;&#125;// Unicycle run// Bicycle run// Tricycle run// cycle.wheels() = 1// cycle.wheels() = 2// cycle.wheels() = 3 练习6123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122package com.company.ch08;enum Note &#123; MIDDLE_C, C_SHARP, B_FLAT;&#125;class Instrument &#123; void play(Note n) &#123; System.out.println(\"Instrument.play() n = \" + n); &#125; @Override public String toString() &#123; return \"Instrument\"; &#125; void adjust() &#123; System.out.println(\"Adusting Instrument\"); &#125;&#125;class Wind extends Instrument &#123; @Override void play(Note n) &#123; System.out.println(\"Wind.play() n = \" + n); &#125;&#125;class Percussion extends Instrument &#123; @Override void play(Note n) &#123; System.out.println(\"Percussion.play() n = \" + n); &#125; @Override public String toString() &#123; return \"Percussion\"; &#125; @Override void adjust() &#123; System.out.println(\"Adjusting Percussion\"); &#125;&#125;class Stringed extends Instrument &#123; @Override void play(Note n) &#123; System.out.println(\"Stringed.play() n = \" + n); &#125; @Override public String toString() &#123; return \"Stringed\"; &#125; @Override void adjust() &#123; System.out.println(\"Adjusting Stringed\"); &#125;&#125;class Brass extends Wind &#123; @Override void play(Note n) &#123; System.out.println(\"Brass.play() n = \" + n); &#125; @Override void adjust() &#123; System.out.println(\"Adjusting Brass\"); &#125;&#125;class Woodwind extends Wind &#123; @Override void play(Note n) &#123; System.out.println(\"Woodwind.play() n = \" + n); &#125; @Override public String toString() &#123; return \"Woodwind\"; &#125;&#125;public class Music3 &#123; public static void tune(Instrument i) &#123; i.play(Note.MIDDLE_C); &#125; public static void tuneAll(Instrument[] instruments) &#123; for (Instrument instrument: instruments) &#123; tune(instrument); &#125; &#125; public static void main(String[] args) &#123; Instrument[] instruments = &#123; new Wind(), new Percussion(), new Stringed(), new Brass(), new Woodwind(), &#125;; tuneAll(instruments); for (Instrument instrument: instruments) &#123; System.out.println(instrument); &#125; &#125;&#125;// Wind.play() n = MIDDLE_C// Percussion.play() n = MIDDLE_C// Stringed.play() n = MIDDLE_C// Brass.play() n = MIDDLE_C// Woodwind.play() n = MIDDLE_C// Instrument// Percussion// Stringed// Instrument// Woodwind 练习712345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Piano extends Instrument &#123; @Override void play(Note n) &#123; System.out.println(\"Piano.play() n = \" + n); &#125; @Override public String toString() &#123; return \"Piano\"; &#125; @Override void adjust() &#123; System.out.println(\"Adjusting Piano\"); &#125;&#125;public class Music3 &#123; public static void tune(Instrument i) &#123; i.play(Note.MIDDLE_C); &#125; public static void tuneAll(Instrument[] instruments) &#123; for (Instrument instrument: instruments) &#123; tune(instrument); &#125; &#125; public static void main(String[] args) &#123; Instrument[] instruments = &#123; new Wind(), new Percussion(), new Stringed(), new Brass(), new Woodwind(), new Piano(), &#125;; tuneAll(instruments); for (Instrument instrument: instruments) &#123; System.out.println(instrument); &#125; &#125;&#125;// Wind.play() n = MIDDLE_C// Percussion.play() n = MIDDLE_C// Stringed.play() n = MIDDLE_C// Brass.play() n = MIDDLE_C// Woodwind.play() n = MIDDLE_C// Piano.play() n = MIDDLE_C// Instrument// Percussion// Stringed// Instrument// Woodwind// Piano 练习812345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class InstrumentGenerator &#123; private Random random = new Random(42); public Instrument next() &#123; switch (random.nextInt(6)) &#123; default: case 0: return new Wind(); case 1: return new Percussion(); case 2: return new Stringed(); case 3: return new Brass(); case 4: return new Woodwind(); case 5: return new Piano(); &#125; &#125;&#125;public class Music3 &#123; public static void tune(Instrument i) &#123; i.play(Note.MIDDLE_C); &#125; public static void tuneAll(Instrument[] instruments) &#123; for (Instrument instrument: instruments) &#123; tune(instrument); &#125; &#125; public static void main(String[] args) &#123; Instrument[] instruments = new Instrument[10]; InstrumentGenerator instrumentGenerator = new InstrumentGenerator(); for (int i = 0;i &lt; 10; i++) &#123; instruments[i] = instrumentGenerator.next(); &#125; tuneAll(instruments); for (Instrument instrument: instruments) &#123; System.out.println(instrument); &#125; &#125;&#125;// Stringed.play() n = MIDDLE_C// Brass.play() n = MIDDLE_C// Wind.play() n = MIDDLE_C// Stringed.play() n = MIDDLE_C// Wind.play() n = MIDDLE_C// Percussion.play() n = MIDDLE_C// Piano.play() n = MIDDLE_C// Stringed.play() n = MIDDLE_C// Percussion.play() n = MIDDLE_C// Piano.play() n = MIDDLE_C// Stringed// Instrument// Instrument// Stringed// Instrument// Percussion// Piano// Stringed// Percussion// Piano 练习91234567891011121314151617181920212223242526272829303132333435363738394041424344package com.company.ch08;public class Rodent &#123; void eat() &#123; System.out.println(\"Rodent.eat()\"); &#125; public static void main(String[] args) &#123; Rodent[] rodents = new Rodent[] &#123; new Rodent(), new Mouse(), new Gerbil(), new Hamster(), &#125;; for (Rodent rodent: rodents) &#123; rodent.eat(); &#125; &#125;&#125;class Mouse extends Rodent &#123; @Override void eat() &#123; System.out.println(\"Mouse.eat()\"); &#125;&#125;class Gerbil extends Rodent &#123; @Override void eat() &#123; System.out.println(\"Gerbil.eat()\"); &#125;&#125;class Hamster extends Rodent &#123; @Override void eat() &#123; System.out.println(\"Hamster.eat()\"); &#125;&#125;// Rodent.eat()// Mouse.eat()// Gerbil.eat()// Hamster.eat() 练习101234567891011121314151617181920212223package com.company.ch08;class Base &#123; void func1() &#123; func2(); &#125; void func2() &#123; System.out.println(\"Base\"); &#125;&#125;public class Ex10 extends Base &#123; @Override void func2() &#123; System.out.println(\"Ex10\"); &#125; public static void main(String[] args) &#123; Base base = new Ex10(); base.func1(); &#125;&#125;// Ex10 因为func2既不是static也不是final，所以他是动态绑定的，因此基类的 func1 中调用 func2 方法也是调用到导出类的 func2。 练习11123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.company.ch08;class Meal &#123; Meal() &#123; System.out.println(\"Meal()\"); &#125;&#125;class Bread &#123; Bread() &#123; System.out.println(\"Bread()\"); &#125;&#125;class Cheese &#123; Cheese() &#123; System.out.println(\"Cheese()\"); &#125;&#125;class Lettuce &#123; Lettuce() &#123; System.out.println(\"Lettuce()\"); &#125;&#125;class Lunch extends Meal &#123; Lunch() &#123; System.out.println(\"Lunch()\"); &#125;&#125;class PortableLunch extends Lunch &#123; PortableLunch() &#123; System.out.println(\"PortableLunch()\"); &#125;&#125;class Pickle &#123; Pickle() &#123; System.out.println(\"Pickle\"); &#125;&#125;public class Sandwich extends PortableLunch &#123; private Bread b = new Bread(); private Cheese c = new Cheese(); private Lettuce l = new Lettuce(); private Pickle p = new Pickle(); public Sandwich() &#123; System.out.println(\"Sandwich()\"); &#125; public static void main(String[] args) &#123; new Sandwich(); &#125;&#125; 练习1212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.company.ch08;public class Rodent &#123; Rodent() &#123; System.out.println(\"Rodent\"); &#125; void eat() &#123; System.out.println(\"Rodent.eat()\"); &#125; public static void main(String[] args) &#123; Rodent[] rodents = new Rodent[] &#123; new Rodent(), new Mouse(), new Gerbil(), new Hamster(), &#125;; for (Rodent rodent: rodents) &#123; rodent.eat(); &#125; &#125;&#125;class Mouse extends Rodent &#123; Mouse() &#123; System.out.println(\"Mouse\"); &#125; @Override void eat() &#123; System.out.println(\"Mouse.eat()\"); &#125;&#125;class Gerbil extends Rodent &#123; Gerbil() &#123; System.out.println(\"Gerbil\"); &#125; @Override void eat() &#123; System.out.println(\"Gerbil.eat()\"); &#125;&#125;class Hamster extends Rodent &#123; Hamster() &#123; System.out.println(\"Hamster\"); &#125; @Override void eat() &#123; System.out.println(\"Hamster.eat()\"); &#125;&#125; 练习1312345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.company.ch08;class Shared &#123; private int refcount = 0; private static long counter = 0; private final long id = counter++; public Shared() &#123; System.out.println(\"Create \" + this); &#125; void addRef() &#123; refcount++; &#125; protected void dispose() &#123; if(--refcount == 0) System.out.println(\"Disposing \" + this); &#125; @Override public String toString() &#123; return \"Shared&#123;\" + \"id=\" + id + '&#125;'; &#125; @Override protected void finalize() throws Throwable &#123; System.out.println(\"finalize()\"); if (refcount != 0) &#123; System.out.println(\"refcount != 0\"); &#125; super.finalize(); &#125;&#125;class Composing &#123; private Shared shared; private static long counter = 0; private final long id = counter++; public Composing(Shared shared) &#123; System.out.println(\"Creating \" + this); this.shared = shared; this.shared.addRef(); &#125; protected void dispose() &#123; System.out.println(\"disposing \" + this); shared.dispose(); &#125; @Override public String toString() &#123; return \"Composing&#123;\" + \"id=\" + id + '&#125;'; &#125;&#125;public class ReferenceCounting &#123; public static void main(String[] args) &#123;// Shared shared = new Shared();// Composing[] composings = &#123;// new Composing(shared), new Composing(shared),// new Composing(shared), new Composing(shared),// new Composing(shared)// &#125;;//// for (Composing composing: composings) &#123;// composing.dispose();// &#125; new Composing(new Shared()); System.gc(); &#125;&#125; 练习14练习15123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.company.ch08;class Glyph &#123; void draw() &#123; System.out.println(\"Glyph.draw()\"); &#125; Glyph() &#123; System.out.println(\"Glyph() before draw()\"); draw(); System.out.println(\"Glyph() after draw()\"); &#125;&#125;class RoundGlyph extends Glyph &#123; private int radius = 1; RoundGlyph(int r) &#123; radius = r; System.out.println(\"RoundGlyph.RoundGlyph(), radius = \" + radius); &#125; @Override void draw() &#123; System.out.println(\"RoundGlyph.draw(), radius = \" + radius); &#125;&#125;class RectangularGlygh extends Glyph &#123; private int length; RectangularGlygh(int length) &#123; this.length = length; System.out.println(\"RectanguarGlygh length = \" + length); &#125; @Override void draw() &#123; System.out.println(\"RectanguarGlygh.draw() length = \" + length); &#125;&#125;public class PolyConstructors &#123; public static void main(String[] args) &#123; new RectangularGlygh(10); &#125;&#125;// Glyph() before draw()// RectanguarGlygh.draw() length = 0// Glyph() after draw()// RectanguarGlygh length = 10 练习161234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.company.ch08;class Status &#123; void func() &#123;&#125;&#125;class StatusA extends Status &#123; void func() &#123; System.out.println(\"Status A\"); &#125;&#125;class StatusB extends Status &#123; void func() &#123; System.out.println(\"Status B\"); &#125;&#125;class StatusC extends Status &#123; void func() &#123; System.out.println(\"Status C\"); &#125;&#125;class AlterStatus &#123; Status status = new StatusA(); void A() &#123; status = new StatusA(); &#125; void B() &#123; status = new StatusB(); &#125; void C() &#123; status = new StatusC(); &#125; void call() &#123; status.func(); &#125;&#125;public class Starship &#123; public static void main(String[] args) &#123; AlterStatus alterStatus = new AlterStatus(); alterStatus.call(); alterStatus.B(); alterStatus.call(); alterStatus.C(); alterStatus.call(); alterStatus.A(); alterStatus.call(); &#125;&#125;// Status A// Status B// Status C// Status A 练习17123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.company.ch08;public class Cycle &#123; void run() &#123; System.out.println(\"Cycle run\"); &#125; int wheels() &#123; return 0; &#125;&#125;class Unicycle extends Cycle &#123; @Override void run() &#123; System.out.println(\"Unicycle run\"); &#125; @Override int wheels() &#123; return 1; &#125; void balance() &#123;&#125;&#125;class Bicycle extends Cycle &#123; @Override void run() &#123; System.out.println(\"Bicycle run\"); &#125; @Override int wheels() &#123; return 2; &#125; void balance() &#123;&#125;&#125;class Tricycle extends Cycle &#123; @Override void run() &#123; System.out.println(\"Tricycle run\"); &#125; @Override int wheels() &#123; return 3; &#125;&#125;class Test &#123; static void ride(Cycle c) &#123; c.run(); &#125; public static void main(String[] args) &#123; Cycle[] cycles = new Cycle[]&#123;new Unicycle(), new Bicycle(), new Tricycle()&#125;;// for(Cycle cycle: cycles) &#123;// cycle.balance(); // 无法调用// &#125; Unicycle unicycle = (Unicycle)cycles[0]; Bicycle bicycle = (Bicycle)cycles[1]; Tricycle tricycle = (Tricycle)cycles[2]; unicycle.balance(); bicycle.balance();// tricycle.balance(); //无法调用 &#125;&#125;","categories":[{"name":"《Java编程思想》","slug":"《Java编程思想》","permalink":"http://blog.codeand.fun/categories/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.codeand.fun/tags/Java/"},{"name":"阅读笔记","slug":"阅读笔记","permalink":"http://blog.codeand.fun/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"name":"《Java编程思想》","slug":"《Java编程思想》","permalink":"http://blog.codeand.fun/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"},{"name":"后端","slug":"后端","permalink":"http://blog.codeand.fun/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"《 Java 编程思想》CH07 复用类","slug":"《-Java-编程思想》CH07-复用类","date":"2020-02-15T14:58:12.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2020/02/15/《-Java-编程思想》CH07-复用类/","link":"","permalink":"http://blog.codeand.fun/2020/02/15/%E3%80%8A-Java-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8BCH07-%E5%A4%8D%E7%94%A8%E7%B1%BB/","excerpt":"","text":"复用代码是 Java 众多引人注目的功能之一。 Java 可以通过创建类来复用代码，要在使用类的时候不破坏现有代码，有两种方式： 组合：在新的类中使用现有类的对象。 继承：按照现有类的类型来创建新类，无需改变现有类的形式，并为其添加新代码。 组合语法 使用组合技术只需要将对象引用置于新类中。 每个非基本类型的对象都有一个 toString() 方法，而且当编译器需要一个 String 而你传入一个对象时，toString() 会被调用。 类中的对象引用会被默认初始化为 null，如果你对其调用任何方法都会抛出异常，但是可以在不抛出异常的情况下，仍然可以打印一个 null 引用 类中对象引用的初始化位置： 在定义对象的地方 在类的构造器中 惰性初始化，即在要使用该对象的地方进行初始化 实例初始化 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Soap &#123; private String s; Soap() &#123; System.out.println(\"Soup()\"); s = \"Constructed\"; &#125; @Override public String toString() &#123; return s; &#125;&#125;/** * Bath */public class Bath &#123; private String s1 = \"happy\", // 在定义处初始化 s2; private Soap soap; private int i; public Bath() &#123; System.out.println(\"Inside Bath()\"); soap = new Soap(); // 在构造函数中初四花 &#125; @Override public String toString() &#123; if (s2 == null) &#123; s2 = \"Joy\"; // 惰性初始化 &#125; return s2; &#125; &#123; i = 2; // 实例初始化 &#125; public static void main(String[] args) &#123; Bath b = new Bath(); System.out.println(b); &#125;&#125; 继承语法 继承是 OOP 语言和 Java 语言不可缺少的部分，当创建一个类时，总是在继承，即使没有显式继承某个类，也会隐式地从 Object 类中继承。 继承由关键词 extends 指定，其形式如class Detergent extends Cleanser{}，基类的所有方法和成员都会自动导入到导出类中。 可以为每个类都创建一个 main 方法，这样可以使得每个类的单元测试变得简便。即使某个类只有包访问权限，其public main也可以通过 java className的方式访问到 为了继承，一般是将所有的数据成员都指定为 private，将所有的方法指定为 public。 我们对继承来的方法进行重写，重写之后可以通过 super 关键词访问基类版本的方法，如super.func(); Java 会自动在导出类的构造器中插入对基类构造器的调用，其总是在导出类构造器执行之前，即使是在定义处初始化的语句也会在基类构造器执行之后执行。 即使没有为导出类创建构造器，编译器也会在默认构造器中调用基类的构造器 如果没有默认的基类构造器，或者想要调用一个带有参数的基类构造器，就必须使用 super 关键词显式调用基类构造器，调用基类构造器必须是在你导出类构造器的第一条语句。 代理代理是指，我们将一个成员对象置于要构造的类中（像组合），但与此同时我们在新类中暴露该成员对象的所有或部分方法（想继承）。 IDEA自动创建代理的过程： 先在代理类中声明要代理的成员。 Alt + Insert快捷键，选中 Delegation 选中要代理的函数即可。 123456789101112131415161718192021222324252627282930313233343536373839404142class SpaceShipControls &#123; void up(int velocity) &#123;&#125; void down(int velocity) &#123;&#125; void left(int velocity) &#123;&#125; void right(int velocity) &#123;&#125; void back(int velocity) &#123;&#125; void turboBoost() &#123;&#125;&#125;public class SpaceShipDelegation &#123; SpaceShipControls spaceShipControls = new SpaceShipControls(); public void up(int velocity) &#123; spaceShipControls.up(velocity); &#125; public void down(int velocity) &#123; spaceShipControls.down(velocity); &#125; public void left(int velocity) &#123; spaceShipControls.left(velocity); &#125; public void right(int velocity) &#123; spaceShipControls.right(velocity); &#125; public void back(int velocity) &#123; spaceShipControls.back(velocity); &#125; public void turboBoost() &#123; spaceShipControls.turboBoost(); &#125; public static void main(String[] args) &#123; SpaceShipDelegation spaceShipDelegation = new SpaceShipDelegation(); spaceShipDelegation.left(1); &#125;&#125; 结合使用组合继承 可以结合组合和继承来创建复杂的类 编译器会强制你去初始化基类，并且要求在构造器最开始出就要这么做，但是它不会要求你对成员对象进行初始化，因此需要自己注意。 Java 中没有 C++ 中的析构函数，就像之前所说的一样，如果我们的类的确需要做一些类似的工作（如关闭文件），我们需要自己实现一个方法来实现，而当涉及到继承时，我们要确保以正确的顺序调用该函数，推荐和C++中析构函数的执行顺序一样编写该函数，即先清理导出类本身，再调用基类的清理函数。 清理函数需要放在 finally 子句中，以防异常的出现，导致清理函数未被执行，可参考练习12 如果 Java 的基类拥有某个已经被多次重载的方法名称时，在导出类中重新定义该方法的名称，不会屏蔽其在基类中的任何版本。这意味着，在导出类中，重载和重新定义（重写）容易混淆在一起，如果不看基类的定义是很难分辨某个方法是否正确的被重新定义了。我们可以使用@Override注解来标识某个方法我们希望其是重写而不是重载，如果一不小心重载了，则会出现编译错误来提醒我们。 在组合与继承之间选择 组合和继承都允许在新的类中放置子对象，组合是显式地这样做，而继承则是隐式地这样做。 组合技术通常用于想在新类中使用现有类的功能而非它的接口这种情况。有时，允许类的用户直接访问新类中组合成分是有意义的。 在继承时，使用某个现有类，开发一个它的特殊版本。通常，这意味着你在使用一个通用类，并为了某种特殊需要而将其特殊化。 向上转型 “为新的类提供方法”不是继承中最重要的部分，其重要的方面是用来表现新类和基类之间的关系。简单的说，我们可以认为“导出类是基类的一种类型”，即可以把导出类当成基类来使用 由于导出类转换为基类在继承图上是向上移动的，因为我们将其成为“向上转型” 向上转型是从一个较为专用的类向较为通用的类转变 虽然在教授OOP的过程中多次强调继承，但是我们应该慎用继承。判断是否要使用的继承的一个简单方法就是，判断我们是否要进行向上转型，如果要进行向上转型，则用继承，反之，则用组合。 12345678910111213class Instrument &#123; public void play() &#123;&#125; static void tune(Instrument i) &#123; i.play(); &#125;&#125;public class Wind extends Instrument &#123; public static void main(String[] args) &#123; Wind wind = new Wind(); Instrument.tune(wind); // 传递参数时，用了向上转型 &#125;&#125; final 关键字final 关键词的含义通常指“无法改变的”，使用这个关键词通常是因为设计和效率的原因。，final 可以用在数据、方法和类上。 final 数据 数据的恒定不变分为两种情况：编译时常量和在运行时初始化并并无法的改变的值。 在 Java 中，这类常量必须是基本数据类型，并且用关键词 final 表示，并在该常量定义时对其初始化，如final int value = 1。通常，编译时常量还是一个static数据，即static final int VALUE_ONE = 1。 编译器常量的命名规则是：全用大写字母，单词与单词之间用_隔开 即使一个变量是final,我们也无法确定其是编译时常量，因为初始化没有要求是字面量，即初始化可以通过调用函数实现，如final int value = rand.nextInt(20)。 同时一个final数值，如果其是static的，那么它可能是在类导入时初始化的，而他不是static的话，它是在实例化时初始化的。 对于基本变量，final 使数值恒定不变，但是对于对象引用，其只是要求对象引用不变，即不指向新的对象，而对象本身是可以被修改的。 Java 允许“空白 final”，即被声明为 final 但是又没有给定初值的域，虽然可以在定义时不给定初值，按时编译器会保证，final 域在使用前都必须被初始化，即如果没有在定义处给定 final 域的初值的话，就必须在每个构造器中对该 final 域进行赋值。 Java 允许在参数列表中以声明的方式将参数指明为 final，其含义为，在该函数中无法修改该变量： 参数类型为基本类型：可以读参数，但是不能修改 参数类型为对象类型：无法修改引用 final 方法 可以将一个方法定义成 final，这样可以防止任何继承类修改它的含义（即导出类无法覆盖实现） 在 Java 的早期实现中，对 final 方法的调用会被转为内嵌调用（C++ 中的 inline），但是现在不需要用这样的方式来优化代码了 类中的所有 private 方法都被隐式的指定为 final “覆盖”只有在方法是基类的接口的一部分时才会出现，即必须能将一个对象向上转型为它的基本类型并调用相同的方法，如果一个方法是 private，那么它就不是接口的一部分。 final 类当将一个类的整体定义为 final 时，就表明该类无法被继承，同时隐式地将所有方法都定义为 final。 初始化及类的加载 每个类的编译代码都存在与他自己独立的文件中。该文件只有在需要使用程序代码的时候才会被加载。 一般来说，只有在“类首次使用才加载”，即加载发生于第一次创建类的对象或第一次使用类中的静态域或静态方法。 在加载导出类是，Java 编译器会注意到它继承于某个基类，因此他会先去加载该基类。 12345678910111213141516171819202122232425262728293031323334353637package com.company.ch07;class Insert &#123; private int i = 9; protected int j; Insert() &#123; System.out.println(\"i = \" + i + \" j = \" + j); j = 39; &#125; private static int x1 = printInit(\"static Insert.x1 init\"); static int printInit(String s) &#123; System.out.println(s); return 47; &#125;&#125;public class Beetle extends Insert &#123; private int k = printInit(\"Beetle.k init\"); public Beetle() &#123; System.out.println(\"k = \" + k); System.out.println(\"j = \" + j); &#125; private static int x2 = printInit(\"static Beetle.x2 init\"); public static void main(String[] args) &#123; System.out.println(\"Beetle constructor\"); new Beetle(); &#125;&#125;// static Insert.x1 init// static Beetle.x2 init// Beetle constructor// i = 9 j = 0// Beetle.k init// k = 47// j = 39 练习练习112345678910111213141516171819202122232425262728class Demo &#123; public Demo() &#123; System.out.println(\"Demo\"); &#125; @Override public String toString() &#123; return \"toString()\"; &#125;&#125;/** * Ex1 */public class Ex1 &#123; Demo demo; @Override public String toString() &#123; if (demo == null) &#123; demo = new Demo(); &#125; return demo.toString(); &#125; public static void main(String[] args) &#123; Ex1 ex1 = new Ex1(); System.out.println(ex1); &#125;&#125; 练习2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Cleanser &#123; private String s = \"Cleanser\"; public void append(String a) &#123; s += a; &#125; public void dilute() &#123; append(\" dilute()\"); &#125; public void apply() &#123; append(\" apply()\"); &#125; public void scrub() &#123; append(\" scrub()\"); &#125; @Override public String toString() &#123; return s; &#125; public static void main(String[] args) &#123; Cleanser cleanser = new Cleanser(); cleanser.dilute(); cleanser.apply(); cleanser.scrub(); System.out.println(cleanser); &#125;&#125;/** * Detergent */public class Detergent extends Cleanser &#123; @Override public void scrub() &#123; append(\" Detergent.scrub()\"); super.scrub(); &#125; public void foam() &#123; append(\" foam()\");&#125; public static void main(String[] args) &#123; Detergent detergent = new Detergent(); detergent.dilute(); detergent.apply(); detergent.scrub(); detergent.foam(); System.out.println(detergent); Cleanser.main(args); &#125;&#125;class NewDetergent extends Detergent &#123; public void scrub() &#123; append(\"NewDetergent\"); super.scrub(); &#125; public void sterilize() &#123; append(\"sterilize\"); &#125; public static void main(String[] args) &#123; NewDetergent newDetergent = new NewDetergent(); newDetergent.dilute(); newDetergent.apply(); newDetergent.scrub(); newDetergent.foam(); newDetergent.sterilize(); System.out.println(newDetergent); Detergent.main(args); &#125;&#125;// Cleanser dilute() apply()NewDetergent Detergent.scrub() scrub() foam()sterilize// Cleanser dilute() apply() Detergent.scrub() scrub() foam()// Cleanser dilute() apply() scrub() 练习3 &amp; 练习412345678910111213141516171819202122232425262728class Art &#123; Art() &#123; System.out.println(\"Art\"); &#125;&#125;class Drawing extends Art &#123; Drawing() &#123; System.out.println(\"Drawing\"); &#125;&#125;/** * Cartoon */public class Cartoon extends Drawing&#123; // public Cartoon() &#123; // System.out.println(\"Cartoon\"); // &#125; public static void main(String[] args) &#123; new Cartoon(); &#125;&#125;// Art// Drawing 练习5123456789101112131415161718192021class A &#123; A() &#123; System.out.println(\"A\"); &#125;&#125;class B &#123; B() &#123; System.out.println(\"B\"); &#125;&#125;class C extends A &#123; B b = new B(); public static void main(String[] args) &#123; new C(); &#125;&#125;// A// B 练习61234567891011121314151617181920212223242526class Game &#123; Game(int i) &#123; System.out.println(\"Game\" + i); &#125;&#125;class BoardGame extends Game &#123; BoardGame(int i) &#123; super(i); System.out.println(\"BoardGame\"); &#125;&#125;/** * Chess */public class Chess extends BoardGame &#123; Chess() &#123; super(11); // 去掉这条语句，会报编译错误 System.out.println(\"Chess\"); &#125; public static void main(String[] args) &#123; new Chess(); &#125;&#125; 练习7123456789101112131415161718192021class A &#123; A(int i) &#123; System.out.println(\"A\"); &#125;&#125;class B &#123; B(int i) &#123; System.out.println(\"B\"); &#125;&#125;class C extends A &#123; B b = new B(1); C() &#123; super(2); &#125; public static void main(String[] args) &#123; new C(); &#125;&#125; 练习812345678910111213141516class Game &#123; Game(int i) &#123; System.out.println(\"Game\" + i); &#125;&#125;class BoardGame extends Game &#123; BoardGame() &#123; super(1); System.out.println(\"BoardGame Default\"); &#125; BoardGame(int i) &#123; super(i); System.out.println(\"BoardGame\"); &#125;&#125; 练习91234567891011121314151617181920212223242526272829303132333435363738394041class Component1 &#123; Component1() &#123; System.out.println(\"Component1\"); &#125;&#125;class Component2 &#123; Component2() &#123; System.out.println(\"Component2\"); &#125;&#125;class Component3 &#123; Component3() &#123; System.out.println(\"Component3\"); &#125;&#125;class Root &#123; Component1 c1 = new Component1(); Component2 c2 = new Component2(); Component3 c3 = new Component3(); Root() &#123; System.out.println(\"Root\"); &#125;&#125;class Stem extends Root &#123; Stem() &#123; System.out.println(\"Stem\"); &#125; public static void main(String[] args) &#123; new Stem(); &#125;&#125;// Component1// Component2// Component3// Root// Stem 练习1012345678910111213141516171819202122232425262728293031323334353637class Component1 &#123; Component1(int i) &#123; System.out.println(\"Component1\"); &#125;&#125;class Component2 &#123; Component2(int i) &#123; System.out.println(\"Component2\"); &#125;&#125;class Component3 &#123; Component3(int i) &#123; System.out.println(\"Component3\"); &#125;&#125;class Root &#123; Component1 c1 = new Component1(1); Component2 c2 = new Component2(2); Component3 c3 = new Component3(3); Root(int i) &#123; System.out.println(\"Root\"); &#125;&#125;class Stem extends Root &#123; Stem(int j) &#123; super(j); System.out.println(\"Stem\"); &#125; public static void main(String[] args) &#123; new Stem(2); &#125;&#125; 练习11123456789101112131415161718192021222324252627class DetergentDelegation &#123; Detergent detergent = new Detergent(); public void append(String a) &#123; detergent.append(a); &#125; public void dilute() &#123; detergent.dilute(); &#125; public void apply() &#123; detergent.apply(); &#125; public void scrub() &#123; detergent.scrub(); &#125; public void foam() &#123; detergent.foam(); &#125; public static void main(String[] args) &#123; Detergent.main(args); &#125;&#125; 练习1212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.company.ch07;class Component1 &#123; Component1(int i) &#123; System.out.println(\"Component1\"); &#125; void dispose() &#123; System.out.println(\"Component1 dispose\"); &#125;&#125;class Component2 &#123; Component2(int i) &#123; System.out.println(\"Component2\"); &#125; void dispose() &#123; System.out.println(\"Component2 dispose\"); &#125;&#125;class Component3 &#123; Component3(int i) &#123; System.out.println(\"Component3\"); &#125; void dispose() &#123; System.out.println(\"Component3 dispose\"); &#125;&#125;class Root &#123; Component1 c1 = new Component1(1); Component2 c2 = new Component2(2); Component3 c3 = new Component3(3); Root(int i) &#123; System.out.println(\"Root\"); &#125; void dispose() &#123; System.out.println(\"root dispose\"); c1.dispose(); c2.dispose(); c3.dispose(); &#125;&#125;class Stem extends Root &#123; Stem(int j) &#123; super(j); System.out.println(\"Stem\"); &#125; void dispose() &#123; System.out.println(\"Stem dispose\"); super.dispose(); &#125; public static void main(String[] args) &#123; Stem stem = new Stem(2); try &#123; // do something &#125; finally &#123; stem.dispose(); &#125; &#125;&#125;// Component1// Component2// Component3// Root// Stem// Stem dispose// root dispose// Component1 dispose// Component2 dispose// Component3 dispose 练习131234567891011121314151617181920212223242526272829303132333435363738class Plate &#123; Plate(int i) &#123; System.out.println(\"Plate\"); &#125; void func(int i) &#123; System.out.println(\"func int \" + i); &#125; void func(double d) &#123; System.out.println(\"func double \" + d); &#125; void func(String s) &#123; System.out.println(\"func string \" + s); &#125;&#125;class DinnerPlate extends Plate &#123; DinnerPlate(int i) &#123; super(i); System.out.println(\"DinnerPlate\"); &#125; void func(char c) &#123; System.out.println(\"func char \" + c); &#125; public static void main(String[] args) &#123; DinnerPlate dinnerPlate = new DinnerPlate(1); dinnerPlate.func('c'); dinnerPlate.func(\"hello\"); dinnerPlate.func(1); dinnerPlate.func(1.0); &#125;&#125;// Plate// DinnerPlate// func char c// func string hello// func int 1// func double 1.0 练习1412345678910111213141516171819202122232425262728293031323334353637383940414243package com.company.ch07;class Engine &#123; public void start() &#123;&#125; public void rev() &#123;&#125; public void stop() &#123;&#125; void service() &#123;&#125;&#125;class Wheel &#123; public void inflate(int psi) &#123;&#125;&#125;class Window &#123; public void rollup() &#123;&#125; public void rolldown() &#123;&#125;&#125;class Door &#123; public Window window = new Window(); public void open() &#123;&#125; public void close() &#123;&#125;&#125;public class Car &#123; public Engine engine = new Engine(); public Wheel[] wheels = new Wheel[4]; public Door left = new Door(), right = new Door(); public Car() &#123; for (int i = 0;i &lt; 4; i++) &#123; wheels[i] = new Wheel(); &#125; &#125; public static void main(String[] args) &#123; Car car = new Car(); car.left.window.rollup(); car.right.window.rolldown(); car.wheels[0].inflate(72); car.engine.service(); &#125;&#125; 练习1512345package com.company.ch05;public class Test &#123; protected void func() &#123;&#125;&#125; 123456789package com.company.ch07;import com.company.ch05.*;public class Ex15 extends Test&#123; public static void main(String[] args) &#123; Ex15 ex15 = new Ex15(); ex15.func(); &#125;&#125; 练习16123456789101112131415class Amphibian &#123; void func() &#123; &#125; static void test(Amphibian amphibian) &#123; amphibian.func(); &#125;&#125;public class Frog extends Amphibian &#123; public static void main(String[] args) &#123; Frog frog = new Frog(); Amphibian.test(frog); &#125;&#125; 练习171234567891011121314151617181920212223class Amphibian &#123; void func() &#123; System.out.println(\"Amphibian func\"); &#125; static void test(Amphibian amphibian) &#123; amphibian.func(); &#125;&#125;public class Frog extends Amphibian &#123; @Override void func() &#123; System.out.println(\"Frog func\"); &#125; public static void main(String[] args) &#123; Frog frog = new Frog(); Amphibian.test(frog); &#125;&#125;// Frog func 练习18123456789101112131415161718public class Ex18 &#123; static Random random = new Random(12); final int i = random.nextInt(12); static final int j = random.nextInt(12); public static void main(String[] args) &#123; Ex18 ex18 = new Ex18(); System.out.println(\"ex18.i = \" + ex18.i); System.out.println(\"ex18.j = \" + ex18.j); Ex18 ex181 = new Ex18(); System.out.println(\"ex181.i = \" + ex181.i); System.out.println(\"ex181.j = \" + ex181.j); &#125;&#125;// ex18.i = 8// ex18.j = 6// ex181.i = 4// ex181.j = 6 练习19123456789101112public class Ex19 &#123; final int k; Ex19() &#123; k = 1; // 必须赋值 // k = 2; // 会报错 &#125; public static void main(String[] args) &#123; Ex19 ex19 = new Ex19(); // ex19.k = 1; // 会报错 &#125;&#125; 练习20123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.company.ch07;class WithFinal &#123; private final void f() &#123; System.out.println(\"WithFinal.f()\"); &#125; private void g() &#123; System.out.println(\"WithFinal.g()\"); &#125;&#125;class OverridingPrivate extends WithFinal &#123;// @Override //加上注解后编译错误 private final void f() &#123; System.out.println(\"OverridingPrivate.f()\"); &#125;// @Override //加上注解后编译错误 private void g() &#123; System.out.println(\"OverridingPrivate.g()\"); &#125;&#125;class OverridingPrivate2 extends OverridingPrivate &#123;// @Override //加上注解后编译错误 public final void f() &#123; System.out.println(\"OverridingPrivate2.f()\"); &#125;// @Override //加上注解后编译错误 public void g() &#123; System.out.println(\"OverridingPrivate2.g()\"); &#125;&#125;public class FinalOverridingIllusion extends OverridingPrivate2 &#123; public static void main(String[] args) &#123; OverridingPrivate2 overridingPrivate2 = new OverridingPrivate2(); overridingPrivate2.f(); overridingPrivate2.g(); OverridingPrivate overridingPrivate = overridingPrivate2;// overridingPrivate.f(); 无法调用// overridingPrivate.g(); WithFinal withFinal = overridingPrivate;// withFinal.f(); 无法调用// withFinal.g(); &#125;&#125; 练习21123456789package com.company.ch07;class Final &#123; final void f() &#123;&#125;&#125;public class Ex21 extends Final &#123; void f() &#123;&#125; // 编译出错&#125; 练习2212345678package com.company.ch07;final class FinalClass &#123; &#125;public class Ex22 extends FinalClass &#123; //编译出错&#125; 练习231234567891011121314151617181920212223242526272829303132333435363738394041424344class Insert &#123; private int i = 9; protected int j; Insert() &#123; System.out.println(\"i = \" + i + \" j = \" + j); j = 39; &#125; private static int x1 = printInit(\"static Insert.x1 init\"); static int printInit(String s) &#123; System.out.println(s); return 47; &#125;&#125;public class Beetle extends Insert &#123; private int k = printInit(\"Beetle.k init\"); public Beetle() &#123; System.out.println(\"k = \" + k); System.out.println(\"j = \" + j); &#125; private static int x2 = printInit(\"static Beetle.x2 init\"); public static int x3 = 3; public static void main(String[] args) &#123; System.out.println(\"Beetle constructor\"); new Beetle(); &#125;&#125;class Ex23 &#123; public static void main(String[] args) &#123; new Beetle();// static Insert.x1 init// static Beetle.x2 init// i = 9 j = 0// Beetle.k init// k = 47// j = 39 // or // System.out.println(Beetle.x3);// static Insert.x1 init// static Beetle.x2 init// 3 &#125;&#125; 练习24123456789101112131415161718192021222324252627282930313233343536373839class Insert &#123; private int i = 9; protected int j; Insert() &#123; System.out.println(\"i = \" + i + \" j = \" + j); j = 39; &#125; private static int x1 = printInit(\"static Insert.x1 init\"); static int printInit(String s) &#123; System.out.println(s); return 47; &#125;&#125;public class Beetle extends Insert &#123; private int k = printInit(\"Beetle.k init\"); public Beetle() &#123; System.out.println(\"k = \" + k); System.out.println(\"j = \" + j); &#125; private static int x2 = printInit(\"static Beetle.x2 init\"); public static int x3 = 3; public static void main(String[] args) &#123; System.out.println(\"Beetle constructor\"); new Beetle(); &#125;&#125;class Ex24 extends Beetle &#123; public static void main(String[] args) &#123; new Ex24();// static Insert.x1 init// static Beetle.x2 init// i = 9 j = 0// Beetle.k init// k = 47// j = 39 &#125;&#125; 调用 Ex24 的main函数（静态方法），准备加载 Ex24，但是发现其继承与 Beetle 准备加载 Beetle，但是发现其继承与 Insert，因此先加载 Insert Insert 中的静态数据先初始化，所以会输出static Insert.x1 init Insert 加载并初始化完后，加载 Beetle 并对静态数据进行初始化，所以会输出static Beetle.x2 init 然后加载 Ex24，加载过程完成，调用 main 函数 new Ex24时，实例化的顺序为 Insert -&gt; Beetle -&gt; Ex24 所以先输出 Insert 构造函数中的 i = 9 j = 0，之所以 j 为0，是因为int默认值为0 然后在实例化 Beetle 时，先会执行 实例初始化，即private int k = printInit(&quot;Beetle.k init&quot;); 最后才是 Beetle 的构造函数。","categories":[{"name":"《Java编程思想》","slug":"《Java编程思想》","permalink":"http://blog.codeand.fun/categories/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.codeand.fun/tags/Java/"},{"name":"阅读笔记","slug":"阅读笔记","permalink":"http://blog.codeand.fun/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"name":"《Java编程思想》","slug":"《Java编程思想》","permalink":"http://blog.codeand.fun/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"},{"name":"后端","slug":"后端","permalink":"http://blog.codeand.fun/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"《 Java 编程思想》CH06 访问权限控制","slug":"《-Java-编程思想》CH06-访问权限控制","date":"2020-02-14T21:31:06.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2020/02/14/《-Java-编程思想》CH06-访问权限控制/","link":"","permalink":"http://blog.codeand.fun/2020/02/14/%E3%80%8A-Java-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8BCH06-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/","excerpt":"","text":"访问控制（或隐藏具体实现）与“最初的实现并不恰当”有关。 重构即重写代码，以使得它更可读，更容易理解，并因此而更具维护性。 在面向对象设计中需要考虑一个基本问题：“如何把变动的事物与保持不变的事物区分开来” 应该尽可能将一切方法都定为private，而仅向客户端程序员公开你愿意让他们使用的方法。 包：库单元 包内包含有一组类，它们在单一的名字空间之下被组织在一起 为了解决潜在的名字冲突问题，Java使用 package 对名称空间进行完全控制并为每一个类创建唯一的标识符组合。 每一个编译单元（.java 文件）只能有一个 public 类。 当编译一个 Java 文件时，.java 文件中的每一个类都会生成一个与其类名相同的 .class 文件 Java 可运行程序是一组可以打包并压缩为一个 Java 文档文件（JAR）的 .class 文件，Java解释器负责这些文件的查找、装载和解释。 类库实际上一组类文件。其中每个文件都有一个 public 类，以及任意数量的非 public 类。因此每个文件都有一个构件，如果希望他们都属于同一个群组，则可以使用关键词 package。 package 语句必须是文件中除了注释外的第一行代码。如packgae access;表示当前文件是 access 类库的一部分，标识符为access.ClassName; package 名称的第一部分应该是域名的逆序。 package 名称会被分解为一个目录路径，这个包的所有文件都应该放在该文件夹中，例如包名为fun.wuxiaobai24.access，则被解释成$CLASSPATH/fun/wuxiaobai24/access，其中$CLASSPATH为环境变量，CLASSPATH 可以指定多个目录。 在使用JAR文件时，需要在 CLASSPATH 中指明JAR文件的真实路径，如CLASSPATH = .;~/jar/access.jar 如果将两个包含相同名称的类库用*形式导入时，在使用重名的类时，需要指明是那个包中的，如fun.wuxiaobai24.access.ClassName c = new fun.wuxiaobai24.access.ClassName() 使用import static语句进行静态导入，将某个包中的所有静态方法导入，这样可以直接用静态方法名进行方法调用，而不用在前面加类名，如调用某个类中的 main() 方法时，静态导入可以直接main();，而普通的导入而需要ClassName.main(); Java 中 没有 C 中的条件编译，但是可以用 import 来间接实现某些功能。 Java 访问权限修饰词 包访问权限允许将包内所有相关的类组合在一起，以使得它们彼此之间可以相互访问作用。 继承而来的类可以访问public和protected，只有当两个类在同一个包中时才能访问包访问权限的成员。 对于OOP而言，提供访问器和变异器（getter/setter），以读取或改变数值是最优雅的方法，而是 JavaBean 的基本原理。 如果没有给文件指定包，Java 将这些文件视为该目录的默认包中，于是给该目录中所有其他的文件提供包访问权限。 不能因为在类中某个对象的引用是 private，就认为其他对象就不能拥有该对象。 protected 成员除了继承的子类可以访问外，它也有包访问权限，即同一个包下的类可以访问它。 private 可以用来实现单例子模式： 1234567class Soup &#123; private Soup() &#123;&#125; private static Soup soup = new Soup(); public static Soup access() &#123; return soup; &#125;&#125; 接口和实现访问权限的控制常被称为具体实现的隐藏。把数据和方法包装进类中，以及具体的实现的隐藏，常共同被称为封装。其结果是一个同时带有特征和行为的数据类型。 访问权限控制将权限的边界划在数据类型的内部的原因： 不用担心客户端程序员偶然地将内部机制当作他们可以使用的接口的一部分。 接口和具体实现的分离 类的访问权限为了控制类的访问权限，修饰词必须出现在关键词 class 之前，如public class ClassName。同时有一些额外的限制： 每个编译单元（文件）都只能有一个 public 类。每个编译单元都有单一的公共接口，同 public 类实现 public 类的名称必须与文件名相同，包括大小写。 编译单元（文件）中可以完全不带 public 类，此时可以随意对文件命名。 类的访问权限只有 public 和包访问权限。如果希望其他任何人对该类有访问权限，可以将所有的构造器都指定为 private，但是该类中 static 成员仍然可以创建和访问。","categories":[{"name":"《Java编程思想》","slug":"《Java编程思想》","permalink":"http://blog.codeand.fun/categories/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.codeand.fun/tags/Java/"},{"name":"阅读笔记","slug":"阅读笔记","permalink":"http://blog.codeand.fun/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"name":"《Java编程思想》","slug":"《Java编程思想》","permalink":"http://blog.codeand.fun/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"},{"name":"后端","slug":"后端","permalink":"http://blog.codeand.fun/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"Flutter 安装记录","slug":"Flutter-安装记录","date":"2020-02-10T17:42:33.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2020/02/10/Flutter-安装记录/","link":"","permalink":"http://blog.codeand.fun/2020/02/10/Flutter-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/","excerpt":"","text":"起因最近想开始写日记了，但是找了一圈发现好像好用又安全的App几乎没有，主要是怕不安全。很多App是不支持导出什么的,而且存在别人的服务器上总感觉不好，要是公司倒闭了，我们的日记岂不是全没有，就算有导出功能，要迁移到另一个App上好像也是很麻烦的样子。而那些支持保存到Webdev上基本是不加密的，也很危险啊。Whatever，我现在有点想做一个移动端的东西，也就是日记本。 调研了一圈，移动端基本上有三种选择： Java + Android React Native Flutter 三者之中，Java + Android 应该是最稳的，毕竟有点 Java 基础；React Native 应该是最理想的，因为很容易就迁移到网页上啊；Flutter 应该算是一个比较激进的做法了，比较新技术，有许多坑，不过现在应该还是算挺多人在用了。作为一个有志向的开发者，踩坑才是最好玩的事情啊。whatever，我觉得用 Flutter 来实现这个东西了。BTW，写这篇东西一方面是为了记录安装中遇到的坑，另一方面也是立Flag（捂脸）。 安装 Flutter我使用的环境是 Manjaro Linux，所以可以不按照官网上的方法下载包然后安装，直接： 1sudo pacman -S flutter 安装完后显示下面这个东西，只需要按照他这里说明的进行一些配置即可。有一点要注意的是，这些命令全部都需要 root 权限，即在命令前面加 sudo 即可。 基本上就安装成功了，可以按照flutter.cn中给出的安装教程一步步走即可。 国情带来的坑在第一次运行flutter doctor之前记得把镜像源配置好，这里可以参考： 12export FLUTTER_STORAGE_BASE_URL=https://mirrors.tuna.tsinghua.edu.cn/flutterexport PUB_HOSTED_URL=https://mirrors.tuna.tsinghua.edu.cn/dart-pub 然后Gradle也有一个镜像源需要配置： 一个是项目中android/gradle/build.gradle: 1234567891011121314151617181920212223242526buildscript &#123; ext.kotlin_version = '1.3.50' repositories &#123; // google() // jcenter() maven &#123; url 'https://maven.aliyun.com/repository/google' &#125; maven &#123; url 'https://maven.aliyun.com/repository/jcenter' &#125; maven &#123; url 'http://maven.aliyun.com/nexus/content/groups/public' &#125; &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:3.5.0' classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\" &#125;&#125;allprojects &#123; repositories &#123; // google() // jcenter() maven &#123; url 'https://maven.aliyun.com/repository/google' &#125; maven &#123; url 'https://maven.aliyun.com/repository/jcenter' &#125; maven &#123; url 'http://maven.aliyun.com/nexus/content/groups/public' &#125; &#125;&#125; 还是有/opt/flutter/packags/flutter_tools/gradle/flutter.gradle 12345678910buildscript &#123; repositories &#123; // google() // jcenter() maven &#123; url 'https://plugins.gradle.org/m2/' &#125; maven &#123; url 'http://maven.aliyun.com/nexus/content/repositories/google' &#125; maven &#123; url 'http://maven.aliyun.com/nexus/content/groups/public/' &#125; maven &#123; url 'http://maven.aliyun.com/nexus/content/repositories/jcenter'&#125; &#125;","categories":[{"name":"Flutter 学习","slug":"Flutter-学习","permalink":"http://blog.codeand.fun/categories/Flutter-%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://blog.codeand.fun/tags/Flutter/"},{"name":"踩坑记录","slug":"踩坑记录","permalink":"http://blog.codeand.fun/tags/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"}]},{"title":"《 Java 编程思想》CH05 初始化与清理","slug":"《-Java-编程思想》CH05-初始化与清理","date":"2020-02-09T11:24:03.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2020/02/09/《-Java-编程思想》CH05-初始化与清理/","link":"","permalink":"http://blog.codeand.fun/2020/02/09/%E3%80%8A-Java-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8BCH05-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/","excerpt":"","text":"用构造器确保初始化在 Java 中，通过提供构造器，类的设计者可确保每个对象都会得到初始化。Java 会保证初始化的进行。构造器采用与类相同的名称。 由于构造器的名称必须与类名完全相同，所以“每个方法首字母小写”的风格在这里不适用。 构造器方法可以有参数，这样可以在初始化对象时提供实际参数。 不接受任何参数的构造器叫做“默认构造器”。 构造器一种特殊类型的方法，它没有返回值 方法重载因为可以要用多种方式来创建并初始化一个对象，所以就需要多个构造器，而构造器的名称又需要和类名相同，所以必须允许方法名相同而形式参数不同的构造器存在，所以 Java 中有方法重载。 123456789101112131415161718192021class Rock &#123; Rock() &#123; // 默认构造器 &#125; Rock(int i) &#123; // 带参数的构造器 System.out.println(\"i=\" + i); &#125; void print() &#123; System.out.println(\"i = null\"); &#125; void print(int i) &#123; System.out.println(\"i = \" + i); &#125;&#125;// 初始化Rock r1 = new Rock(); // 调用默认构造器Rock r2 = new Rock(1); // 调用带参数的构造器r2.print();r2.print(1); 区分重载方法方法签名是由方法名和参数类型列表构成的，所以用参数类型列表区分重载方法。不能用返回值区分重载方法 设计基本类型的重载由于基本类型可能会从一个“较小”的类型自动提升为一个“较大”的类型，所以在重载方法中需要特别注意： 常数值当作int处理 实参的数据类型小于形参的数据类型时，会自动提升 对于 char 类型，如果找不到以 char 作为形参的方法的话，会把 char 类型提升成 int 类型 如果实参大于形参的话，需要显式的强制转换否则会报编译错误 默认构造器 默认构造器是一个没有形式参数的构造器，其作用是创建一个“默认对象” 如果类中没有构造器，编译器会自动创建一个默认构造器 如果类中已经有了一个构造器了，编译器则不会自动创建默认构造器 this 关键字由于同一类型的对象都可以调用相同的方法，为了在方法中区分不同的对象，会把对象的引用作为参数传递给方法，a.fun(1)在编译器内部会被翻译成ClassName.fun(a, 1)，我们可以通过this关键字在方法中访问到对象的引用。 在方法内部调用同个类的另一个方法不需要使用this,直接调用即可。 this 可以在方法内部作为参数传递给另一个方法，也可以作为返回值（可以构造出链式操作） 在构造器中调用构造器 可以利用 this 来实现在构造器中调用构造器，这样可以避免重复代码。 this 在一个构造器中只能调用一次构造器 必须将构造器置于最开始处，否则编译器会报错 1234567891011121314151617181920212223242526272829303132333435public class Flower &#123; int petalCount = 0; String s = \"initial value\"; Flower(int petals) &#123; petalCount = petals; System.out.println(\"int arg ,petalCount = \" + petalCount); &#125; Flower(String ss) &#123; s = ss; System.out.println(\"string arg ,s = \" + s); &#125; Flower(String s, int petals) &#123; this(petals); // this 只能调用一次构造器 this.s = s; System.out.println(\"string &amp; int arg, s = \" + s + \", petalCount = \" + petalCount); &#125; Flower() &#123; this(\"hello\", 24); &#125; public static void main(String[] args) &#123; Flower flower = new Flower(); System.out.println(\"flower.petalCount = \" + flower.petalCount); System.out.println(\"flower.s = \" + flower.s); &#125;&#125;// int arg ,petalCount = 24// string &amp; int arg, s = hello, petalCount = 24// flower.petalCount = 24// flower.s = hello static 的含义static 方法就是没有 this 的方法，在 static 中不能调用非静态方法，但是反过来可以。 清理：终结处理和垃圾回收 对象可能不会被垃圾回收 垃圾回收不等于“析构” Java 未提供“析构函数”或相似的概念，要做类似的清理工作，必须手动创建一下执行清理工作的普通方法 垃圾回收只与内存有关 对与垃圾回收有关的任何行为来说（尤其是 finalize() 方法），它们必须同内存及其回收相关 finalize() 的需求通常是用于一种特殊情况，即通过某种创建对象方式以外的方式为对象分配了存储空间，这种情况主要发生在使用了“本地方法”的情况下，本地方法是一种在 Java 中调用非 Java 代码的方式。如在非 Java 代码中调用了 malloc，为了释放内存，我们需要在 finalize() 中调用对应的本地方法进行 free。 finalize() 方法的执行机制：一旦垃圾回收器准备释放对象占用的存储空间，首先调用其 finalize() 方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。 你必须实施清理Java 中没有用于释放对象的 delete，因为垃圾回收器会自动帮你释放存储空间，因此 Java 中没有析构函数。但是垃圾回收不能完全代替析构函数，如果希望进行除释放存储空间之外的清理工作，我们需要明确调用某个 Java 方法。例如某个类打开了一个文件，垃圾回收不能自动帮我们关闭这个文件。为什么这个工作不能有 finalize() 方法来完成呢，原因其实在上面已经说明了，对象可能不会被垃圾回收，也就是说 finalize() 方法可能永远都不会被调用。 如果 JVM 没有面临内存耗尽的情况，它是不会浪费时间去执行垃圾回收以恢复内存的。 终结条件虽然我们不能用 finalize() 方法来进行“清理”，但是我们可以利用它验证某个对象的终结条件。还是刚才那个打开文件的例子，假设在文件没有关闭的时候，垃圾回收将对象回收了，这就会产生一些非常难找的 bug。而 finalize() 可以帮助我们发现这种 bug。 1234567891011121314151617181920212223242526class Book &#123; boolean checkedOut = false; Book(boolean checkOut) &#123; checkedOut = checkOut; &#125; void checkIn() &#123; checkedOut = false; &#125; protected void finalize() &#123; if (checkedOut) &#123; System.out.println(\"Error: checked out\"); &#125; // super.finalize(); &#125;&#125;public class TerminationCondition &#123; public static void main(String[] args) &#123; Book novel = new Book(true); novel.checkIn(); new Book(true); System.gc(); &#125;&#125;// Error: checked out 如上面这个例子，我们希望 Book 在被回收前已经 checkIn 了，所以我们在 finalize() 中写了一个条件语句来判断。 System.gc()强制 GC 应该总是假设基类的 finalize() 也需要做某些时间，所以我们应该在 finalize() 函数的末尾加入 super.finalize(); 垃圾回收器如何工作垃圾回收器会提高对象在堆上创建的速度，这是因为 Java 的堆的实现与 C++ 的不同，其更像是一个传送带，每分配一个对象，它就往前移动一格，所以“堆指针” 只是简单的移动到尚未分配的空间，这意味 Java 中在堆上的分配速度非常快。当然，如果只是简单的像传送带一样工作的话，Java 的堆会占用大量的虚拟内存，进而导致频繁的页面调度，并可能会导致内存资源耗尽，因此需要有垃圾回收器的介入。垃圾回收会一边回收空间一边对堆进行“紧凑”操作。 几种常见的垃圾回收机制： 引用计数：一种简单但比较慢的垃圾回收机制。 每个对象都有一个引用计数器，当引用连接对象时，引用计数加一，当引用离开作用域或被置 null 时，引用计数减一。 这种方法无法处理“循环引用”的情况。 停止-复制（stop-and-copy)： 其依据的思想是：对任何“活”的对象，一定能最终追溯到其存活在堆栈或静态存储区域之中。因此，可以从堆栈和静态存储区开始，遍历所有的引用，并递归查找该对象所包含的所有对象，即可找到所有“活”的对象。 该机制会先暂停程序的运行，然后将所有存活的对象从当前堆复制到另一个堆，然后更新引用 当对象被复制到新的堆中时，没复制的则相当于被回收了，同时可以实现“紧凑”的目标。 该机制会有以下两个缺点： 需要两个堆，进而需要维护比之前大一倍的空间 如果只有少量垃圾甚至没有垃圾，而这时如果进行垃圾回收的话，开销太大了。 标记-清扫（mark-and-sweep)： 与 stop-and-copy 机制依据的思想是一样的也是，用同样的方式找到“活”的对象 每当它找到一个“活”的对象，就会给该对象一个标记，这个过程中不会回收任何对象。只有当全部标记工作完成时，才会进行清理。 清理的过程中，没有被标记的对象被释放，但不会做任何复制动作。 为了避免存储空间的“碎片化”，JVM 需要做紧凑操作 JVM 中采用的垃圾回收机制： 一种结合的 stop-and-copy 和 mark-and-sweep 的自适应垃圾回收算法 内存分配以较大的“快”作为单位，较大的对象可以独占一个块。每个块都有相应的代数（generation count）来记录它是否存活。 垃圾回收会对上次回收操作之后新分配的快进行整理，这样有助于解决有大量短命对象的情况。 垃圾回收机制会定期进行完整的清理——大型对象仍然不会被复制（只是其代数会增加），而那些含有大量小型对象的快会被复制并整理。 当只有少量或没有垃圾产生时，则转为使用 mark-and-sweep 算法。 Java 中 JIT（Just-In-Time）技术： 这种技术可以把程序全部或部分翻译成本地机器码，而不是通过 JVM，进而提升程序的运行速度。 当需要装载某个类时（第一次创建这个类时），编译器会找到其.class 文件，然后将该类的字节码装入内存，此时有两种做法： JIT 直接编译所有代码，但这个做法会有两个缺点： 加载动作分散在整个程序中，累加起来要话更多时间 可能会增加可执行代码的长度，进而导致页面调度 惰性评估（lazy evaluation）：，即 JIT 只在必要时才编译，这样不会执行的代码就不会被 JIT 所编译。 成员初始化Java 尽力保证：所有变量在使用前都能得到适当的初始化。 局部变量没有默认初始值，如有在未初始化前使用它会报错编译错误，而类变量则有默认初始值。 指定初始化Java 允许在定义类成员变量的时候为其赋值进行初始化。非基本类型也可以，同时可以使用已经函数或已经初始化好的变量进行初始化，但要保证初始化顺序的正确。 12345678910111213141516public class InitialValues &#123; boolean t = false; char c = 'a'; byte b = 1; short s = 2; int i = func(s); long l = 4 + i; float f = (float)5.0; // 浮点数字面量是 double 类型的 double d = 6.0; String reference = new String(\"hello world\"); // 非基本类型也可以 int func(short s) &#123; return s*2; &#125;&#125; 构造器初始化 无法阻止自动初始化的进行，它将在构造器之前执行。 类变量的定义顺序决定了初始化的顺序 静态数据的默认值与类变量一致 对于静态变量，Java 可以将多个初始化语句组合成一个静态块，其和静态变量初始化一样在类加载时执行。顺序与定义时的顺序相同 对于非静态变量，Java 中也可以将多个初始化语句组成一个块，在实例初始化执行。 对于以上两种块，既可以可以把它当成一条初始化语句来看待。 12345678910111213141516171819202122232425262728public class InitialValues &#123; boolean t = false; char c = 'a'; byte b = 1; short s = 2; int i = 3; long l = 4; float f; double d; String reference; &#123; f = (float) 1.0; d = 2*f; reference = new String(\"hello\"); reference = reference + f + d; &#125; static &#123; System.out.println(\"hello\"); &#125; static int a; static &#123; System.out.println(\"A is \" + a); a = 2; &#125;&#125; 对象的创建过程： 第一次创建类或者访问其静态数据或方法，JVM 会加载其 .class 文件，此时执行所有静态初始化（按定义的顺序执行）。 当 new 该类时，首先会在堆上分配空间，因为堆在分配前被置零了，所以本类型的默认值都是 0，非基本类型的引用的默认值则是 null。 按顺序执行非静态的初始化 执行构造器 数组初始化数组是同类型的、用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。 定义方式： 12int[] a; //建议使用这种int a[]; //这样也可以， 但是不能指定数组的类型。`int a[3];` 这样是不允许的 int[] a;这样只是定义了一个数组的引用，我们可以使用new来创建一个数组，也可以直接初始化数组： 123456int[] a = new int[3]; // 使用 new 来创建一个数组，这时真实数据会分配在堆中，所以默认值都为“零”int[] b = &#123;1, 2, 3&#125;; // 直接初始化一个长度为3的数组Integer[] c = new Integer[3]; // 创建一个对象数组，保存引用，这时初始值都为 nullRandom rand = new Random(2);int len = rand.nextInt(20);int[] c = new int[len]; // 长度不一定要是一个字面值，可以是变量 数组初始化的坑点： 12345678910InitialValues initialValues = new InitialValues();initialValues.printInitialValues();String[] stringArray = &#123;\"hello\", \"world\"&#125;;// initialValues.printStringArrary(&#123;\"hello\", \"world\"&#125;); // 编译错误initialValues.printStringArrary(stringArray);initialValues.printStringArrary(new String[]&#123;\"hello\", \"world\"&#125;); //正确打开方式int[] intArray = &#123;1, 2, 3, 4&#125;;// initialValues.printIntArray(&#123;1, 2, 3, 4&#125;); // 编译错误initialValues.printIntArray(intArray);initialValues.printIntArray(new int[]&#123;1, 2, 3, 4&#125;); 可变参数列表在方法中，用ClassName... ArgName的形式可以定义可变参数列表，在方法中，ArgName 本质上是一个数组。在可变列表中可以使用任何类型，包括基础类型。这里传入基本类型时，没有依赖自动装包和解包，这意味着，ClassName 为 int 时，ArgName 是一个 int[]，而不是 Integer。在重载方法时，应该只在一个方法中使用可变参数列表 123456789101112131415161718192021static void printArray(Object... args) &#123; for(Object arg: args) &#123; System.out.print(arg + \" \"); &#125; System.out.println();&#125;static void f(int required, int... args) &#123; System.out.println(\"Required: \" + required); for(int i: args) &#123; System.out.print(i + \" \"); &#125; System.out.println();&#125;public static void main(String[] args) &#123; printArray(1, 2, 3, 4, 5); f(1); f(1, 2, 3); Integ&#125; 枚举类型 按照命名习惯，枚举值一般用全大写字母 为了使用 enum，需要创建一个该类型的引用 enum 会自动创建一些实用的函数，如toString()显示其名称，ordinal()表示声明顺序 enum 适合与 switch 一起使用 123456789101112131415enum EnumDemo &#123; HELLO, WORLD, &#125;;EnumDemo e1 = EnumDemo.HELLO;System.out.println(e1); // 自动调用toString()System.out.println(e1.ordinal());for(EnumDemo e: EnumDemo.values()) &#123; System.out.println(\"EnumDemo: \" + e + \" ordinal \" + e.ordinal());&#125;// HELLO// 0// EnumDemo: HELLO ordinal 0// EnumDemo: WORLD ordinal 1","categories":[{"name":"《Java编程思想》","slug":"《Java编程思想》","permalink":"http://blog.codeand.fun/categories/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.codeand.fun/tags/Java/"},{"name":"阅读笔记","slug":"阅读笔记","permalink":"http://blog.codeand.fun/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"name":"《Java编程思想》","slug":"《Java编程思想》","permalink":"http://blog.codeand.fun/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"},{"name":"后端","slug":"后端","permalink":"http://blog.codeand.fun/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"《 Java 编程思想》CH04 控制执行流程","slug":"《-Java-编程思想》CH04-控制执行流程","date":"2020-02-09T10:47:56.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2020/02/09/《-Java-编程思想》CH04-控制执行流程/","link":"","permalink":"http://blog.codeand.fun/2020/02/09/%E3%80%8A-Java-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8BCH04-%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/","excerpt":"","text":"Java 中控制流程基本与 C/C++ 类似，所以大部分相同的部分会选择跳过。 true 和 falseJava 不允许使用一个数字作为布尔值使用 if-else与 C/C++ 一样： if else if else 迭代与 C/C++ 一样： while do-while for 使用逗号操作符可以在 for 语句中定义多个变量（必须是同样类型）和执行多个语句： 123for(int i = 1, j = 1 + 1; i &lt; 10; i++, i++) &#123; System.out.println(\"i = \" + i + \",j = \" + j);&#125; Foreach 语法使用foreach语法可以方便的遍历数组或容器： 1234// f 为一个float的数组for(float x: f) &#123; System.out.println(x);&#125; returnreturn的两种用途： 指定方法的返回值 从方法的任何位置退出 返回值类型为 void 的方法可以没有 return，此时该方法的结尾处会有一个隐式的 return break &amp; continue &amp; gotoJava 中 break 和 continue 与 C/C++ 类似，但是 Java 中没有 goto，但可以用 break 和 continue 实现跳转。 标签： 标识符 + ，如label1:` 应该放在迭代语句之前，中间不能有任何语句 continue &amp; break 与标签一起使用： 一般的 continue 会退回到最内层循环的开头继续执行 带标签的 continue 会退回到标签的位置，并重新进行标签后面那个循环 一般 break 会跳出当前循环 带标签的 break 会跳出标签所指定的循环 123456789101112outer:for(;true;) &#123; // for1 inner: for(;true;) &#123; // for2 continue; //继续执行 for2 循环 continue inner; // 继续执行 for2 循环 continue outer; // 继续执行 for1 循环 break; // 跳出 for2 break inner; // 跳出 for2 break outer; // 跳出 for1 &#125;&#125; switch与 C++ 类似 123456switch(integral-selector) &#123; case integral-value1: statement; break; case integral-value2: statement; break; case integral-value3: statement; break; default: statement;&#125;","categories":[{"name":"《Java编程思想》","slug":"《Java编程思想》","permalink":"http://blog.codeand.fun/categories/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.codeand.fun/tags/Java/"},{"name":"阅读笔记","slug":"阅读笔记","permalink":"http://blog.codeand.fun/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"name":"《Java编程思想》","slug":"《Java编程思想》","permalink":"http://blog.codeand.fun/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"},{"name":"后端","slug":"后端","permalink":"http://blog.codeand.fun/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"《 Java 编程思想》CH03 操作符","slug":"《-Java-编程思想》CH03-操作符","date":"2020-02-08T17:57:48.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2020/02/08/《-Java-编程思想》CH03-操作符/","link":"","permalink":"http://blog.codeand.fun/2020/02/08/%E3%80%8A-Java-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8BCH03-%E6%93%8D%E4%BD%9C%E7%AC%A6/","excerpt":"","text":"在最底层，Java中的数据是通过操作符来操作的。 操作符 +,-,*,*，=与其他语言类似 几乎所有的操作符只能操作“基本类似”，而=，==，!=是例外 String 类支持+和+=操作符，表示拼接操作，在进行拼接的操作会尝试将非 String 的元素转换为 String（调用tostring()) 赋值操作符=的左边（左值）必须是一个明确的已命名的变量。 赋值在为对象“赋值”时，其实质是拷贝“引用”，需要注意“别名现象” 12345678910111213141516171819202122232425package com.company.ch03;class Tank &#123; int level;&#125;public class Assignment &#123; public static void main(String[] args) &#123; Tank tank1 = new Tank(); Tank tank2 = new Tank(); tank1.level = 12; tank2.level = 13; System.out.println(\"tank1 = \" + tank1.level); System.out.println(\"tank2 = \" + tank2.level); tank1 = tank2; tank1.level++; System.out.println(\"tank1 = \" + tank1.level); System.out.println(\"tank2 = \" + tank2.level); &#125;&#125;//tank1 = 12//tank2 = 13//tank1 = 14//tank2 = 14 方法调用中的别名问题12345678910111213141516171819package com.company.ch03;class Letter &#123; char c;&#125;public class PassObject &#123; static void f(Letter y) &#123; y.c = 'z'; &#125; public static void main(String[] args) &#123; Letter x = new Letter(); x.c = 'a'; System.out.println(\"x.c = \" + x.c); // a f(x); System.out.println(\"x.c = \" + x.c); // z &#125;&#125; 不管是那种别名问题，关键是要理解到拷贝的是引用，不是对象。 算数操作符 &amp; 自增与自减 &amp; 按位操作符 整数除法不会四舍五入，而是直接舍去小数位 其余与C++中的一样 关系操作符关系操作符与 C++ 也是类似，有一点比较特殊的是在 Java 中==和!=可以用在对象上，其比较的是引用，而不是对象内的值，如果要比较两个对象是否相等（语义上），通常调用equals函数来比较。 1234Integer n1 = new Integer(47);Integer n2 = new Integer(47);n1 == n2; // falsen1.equals(n2); // true equals默认是比较引用，所以在自己实现的类中需要覆盖equals方法才能进行语义上的比较 逻辑操作符&amp;&amp;,||和!操作只能用于布尔值，与C++不同，对一个非布尔值进行逻辑运算不会对该值强制转换，会报编译错误 Java中的逻辑操作符也有“短路”现象 直接常量 十六进制0x/0X前缀+0-9和a-f 八进制0前缀+0-8 后缀l/L表示long类型 后缀f/F表示float类型 后缀d/D表示double类型 指数记数法：1.39E-43表示$1.39 \\times e^{-43}$ 移位操作符 移位操作符只能用于处理整数类型 &gt;&gt;符号扩展，&gt;&gt;&gt;0扩展 对 char、byte、short 类型进行移位运算，在进行移位之前会先转回为 int 三元运算符 boolean-exp ? value0 : value1 字符串操作符 + 和+= 字符串中操作符 + 和+=表示“拼接”操作 如果一个表达式以字符串开头，那么其后续操作数都必须是字符串类型（不是则进行强制转换） 类型转换操作符类型转换（cast)是指，在适当的时候，Java 会将一种数据类型自动转换为另一种。 显式的类型转换如下： 123int i = 200;long l = (long)i;int j = (int)l; 类型转换： 窄式转换，需要显式指定（如 long 转 int） 扩展转换，无需显式指定（如 int 转 long） Java允许任何基本类型之间的类型转换，除了布尔值。 “类”数据类型不允许类型转换 截尾和舍入 当 float 或 double 转向整型时，总是对数字进行截尾 如果需要舍入，可以调用java.lang.Math.round() 提升一个表达式中出现的最大的数据类型决定了该表达式最终结果的数据类型，如 int 类型与 long 类型相加，得到一个 long 类型。 Java 没有 sizeof由于Java中所有基本数据类型的大小都是明确的，所以不需要sizeof。BTW，boolean 不是没有明确嘛。","categories":[{"name":"《Java编程思想》","slug":"《Java编程思想》","permalink":"http://blog.codeand.fun/categories/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.codeand.fun/tags/Java/"},{"name":"阅读笔记","slug":"阅读笔记","permalink":"http://blog.codeand.fun/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"name":"《Java编程思想》","slug":"《Java编程思想》","permalink":"http://blog.codeand.fun/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"},{"name":"后端","slug":"后端","permalink":"http://blog.codeand.fun/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"《 Java 编程思想》CH02 一切都是对象","slug":"《-Java-编程思想》CH02-一切都是对象","date":"2020-02-08T13:52:42.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2020/02/08/《-Java-编程思想》CH02-一切都是对象/","link":"","permalink":"http://blog.codeand.fun/2020/02/08/%E3%80%8A-Java-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8BCH02-%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"用引用操纵对象尽管Java中一切都看作为对象，但是操纵的标识符实际上对象的一个“引用”。 123String s; // 这里只是创建了一个引用，而不是一个对象String s = new String(\"abcd\"); // 使用`new`操作符来创建一个对象，并将其与一个引用相关联String s = \"abcd\"; // 字符串可以直接用带引号的文本初始化 必须由你创建所有对象使用new操作符创建一个对象 存储到什么位置由五个地方可以存储数据： 寄存器：由于寄存器数量有限，所有无法直接控制 堆栈（栈）：RAM中，存储在栈中的数据必须明确知道其生命周期，通常局部存放对象引用和局部基本类型的变量。 堆：存放所有的对象 常量存储：通常直接存放在代码内部，其永远不会改变 非RAM存储：数据存放在程序之外，不受程序的控制，如流对象（System.out）和持久化对象（存放在磁盘的文件）。 特例：基本类型一些比较小的，简单的类型，如果放在堆中往往效率不高，所以这些类型不需要使用new来创建，而是创建一个“自动”变量来直接存储“值”，并置于栈中。 Java 中所有基本类型所占据存储空间的大小都是明确的. 所有数值类型都有正负号 boolean类型所占存储空间的大小没有明确，仅定义为能够去字面值true或false 基本类型和其对应的包装类之间可以自动装包、自动解包 Java 提供了两个用于高精度计算的类：BigInteger和BigDecimal Java 中的数组 Java 确保数组会被初始化，且会进行范围检查 当创建一个数组对象时实际就是创建一个引用数组，并且每个引用都会被自动初始化为一个特定值null 也可以创建用来存放基本数据类型的数组，此时的初始化则是置零 永远不需要销毁对象作用域 作用域决定了在其内定义的变量的可见性和生命周期 在作用域里定义的变量只可用于作用域结束前 Java 中不允许“覆盖”变量的可见性 12345678910&#123; int x = 12; // x available &#123; int q = 96; // Both x &amp; q available int x = 96 // Illegal &#125; // only x available&#125; 对象的作用域 Java 对象不具备和基本类型一样的生命周期，由new创建的对象，只要你需要，其会一直保留下去。 Java 使用垃圾回收器来监视new创建的对象，辨别并释放那些不会再被引用的对象 创建新的数据类型：类使用class来创建一个新的类型： 1class ATypeName &#123; &#125; 字段和方法一旦定义了一个类，就可以在类中设置两种元素：字段（数据成员）和方法（成员函数）。字段可以是任何类型的对象或基础类型。每个对象都有存储其字段的空间，即普通字段不在对象间共享。 引用一个对象的成员的方式：objectReference.member 基本数据类型的变量只有是类的成员时，才确保其获得一个默认值，否则的话，与C++一样，该变量可能是任意值（其实就是在堆还是栈的问题嘛），不过这种情况下Java会报编译错误。 方法、参数和返回值方法的基本组成部分包括：名称、参数、返回值和方法体： 123ReturnType methodName ( /* Argument list */) &#123; /* Method body */&#125; 方法名和参数列表唯一地标识某个方法（合起来称为“方法签名”）注意：方法签名不包含返回值。 Java 中的方法只能作为类的一部分来创建，方法通常只有通过对象才能调用，且这个对象必须有这个方法。 参数列表方法的参数列表指定要传递给方法什么样的信息，这里采用的都是对象的类型，即包含指定的类型和名字，这里传递的实际上是引用，传递基础类型则通过自动包装来实现。 构建一个 Java 程序名字可见性为了防止不同类库中使用了相同的类名，Java 将反过来的域名作为唯一标识符（即包名），如我的域名为codeand.fun,则我的类库则使用fun.codeand.utils的形式。 包名使用小写 运用其他构件使用import导入想要的包： 12import java.util.ArrayList;import java.util.*; // 导入java.util下所有的类 java.lang默认导入到每一个Java文件中。 static 关键字当声明一个事物为static时，就意味着这个域或方法不会与包含它的类的任何对象实例关联在一起，可以理解为类数据和类方法。 12345678910class StaticTest &#123; static int i = 47; static void inc() &#123; i++; &#125;&#125;int j = StaticTest.i; // 47StaticTest st1 = new StaticTest();StaticTest.inc();StaticTest st2 = new StaticTest();// st1.i == st2.i == 48 // 所有i都指向同一个存储空间 你的第一个 Java 程序123456789// HelloDate.javaimport java.util.*;public class HelloDate &#123; public static void main(String[] args) &#123; System.out.println(\"Hello, it's\"); System.out.println(new Date()); &#125;&#125; 要创建一个独立运行的程序，那么该文件中必须存在某个类与该文件同名，且那个类必须又一个main方法，其形式如public static void main(String[] args)。 编译和运行12$ javac HelloDate.java // 编译，产生一个 HelloDate.class 文件$ java HelloDate // 运行 注释和嵌入式文档 多行注释：/* something */ 单行注释：// something 注释文档Java 中可以将代码与文档放到一个文件中，这样有利于文档的维护，为了实现这一目的，这里使用一种特殊的注释语法来标记文档，此外还有一个工具javadoc来提取注释。javadoc的输出是一个html 123456789101112131415161718192021222324252627# wuxiaobai24 @ wuxiaobai24-pc in ~/code/Java/ch2 [17:56:05] C:1$ javadoc HelloDate.java 正在加载源文件HelloDate.java...正在构造 Javadoc 信息...标准 Doclet 版本 1.8.0_242正在构建所有程序包和类的树...正在生成./HelloDate.html...正在生成./package-frame.html...正在生成./package-summary.html...正在生成./package-tree.html...正在生成./constant-values.html...正在构建所有程序包和类的索引...正在生成./overview-tree.html...正在生成./index-all.html...正在生成./deprecated-list.html...正在构建所有类的索引...正在生成./allclasses-frame.html...正在生成./allclasses-noframe.html...正在生成./index.html...正在生成./help-doc.html...# wuxiaobai24 @ wuxiaobai24-pc in ~/code/Java/ch2 [17:56:11] $ lsallclasses-frame.html HelloDate.class index-all.html package-list stylesheet.cssallclasses-noframe.html HelloDate.html index.html package-summary.htmlconstant-values.html HelloDate.java overview-tree.html package-tree.htmldeprecated-list.html help-doc.html package-frame.html script.js 注释语法所有 javadoc 命令都只能在由/**和*/组成的注释中 javadoc 的注释，只能为public和protected成员进行文档注释，而private和defaule成员的注释会被忽视掉 javadoc 主要有两种形式： 嵌入HTML 文档标签： 独立文档标签是一些以@字符开头的命令，且置于注释行的最前面（除了前导的 *） 行内文档标签则可以在 javadoc 注释中的任何位置，同样以@开头，但要在花括号内。 常用的标签有： @see：引用其他类，会生成一个超链接条目（不会校验该链接是否有效），超链接文本为“See Also” 123@see classname@see fully-qualified-classname@see fully-qualified-classname@method-name {@link package.class#member label}：与@see类似，不过是行内标签，使用“label”来处理作为超链接文本 {@docRoot}：该标签产生到文档根目录的相对路径 {@inheritDoc}：该标签从当前这个类最直接的基类继承相关文档到当前文档注释中 @version:版本信息 @author:作者信息 @since:指定JDK版本最低为多少 @param:表示参数含义，形式如@param parameter-name description @return:描述返回值，形式如@return description @throws:异常描述，该方法可能抛出的每个异常都需要说明，形式如@throws fully-qualified-class-name description @deprecated:指出一些旧特性已由改进的新特性所取代，不建议使用。调用一个标记为@deprecated的方法，编译器会发出警告。 12345678910111213141516171819202122232425262728293031// HelloDate.javaimport java.util.*;/** A class comment * Test comment * @author wuxiaobai24 * @version 0.1 */public class HelloDate &#123; /** a field comment */ public int i; /** * a &lt;strong&gt;protected&lt;/strong&gt; filed comment * &lt;ol&gt; * &lt;li&gt;one&lt;/li&gt; * &lt;li&gt;two&lt;/li&gt; * &lt;li&gt;three&lt;/li&gt; * &lt;/ol&gt; */ protected int p; /** a private field comment */ private int j; /** A method comment * @param args args comment */ public static void main(String[] args) &#123; System.out.println(\"Hello, it's\"); System.out.println(new Date()); &#125;&#125; 编码风格 驼峰式写法 标识符的第一个字符采用小写，其余用大写 练习练习1123456789101112// Ex1.javapublic class Ex1 &#123; public int i; public char c; public static void main(String[] args) &#123; Ex1 e = new Ex1(); System.out.println(e.i); System.out.println(e.c); &#125;&#125; 练习21234567// Ex2.javapublic class Ex2 &#123; public static void main(String[] args) &#123; System.out.println(\"Hello, World\"); &#125;&#125; 练习3 &amp; 练习4 &amp; 练习5123456789101112131415161718192021222324// Ex3.javaclass DataOnly &#123; int i; double d; boolean b;&#125;class ATypeName &#123;&#125;public class Ex3 &#123; public static void main(String[] args) &#123; ATypeName a = new ATypeName(); DataOnly d = new DataOnly(); d.i = 1; d.d = 2.0; d.b = false; System.out.println(d.i); System.out.println(d.d); System.out.println(d.b); &#125;&#125; 练习612345678910111213// Ex4.javapublic class Ex4 &#123; int storage(String s) &#123; return s.length() * 2; &#125; public static void main(String[] args) &#123; String s = new String(\"Hello\"); Ex4 e = new Ex4(); int len = e.storage(s); System.out.println(len); &#125;&#125; 练习7 &amp; 练习81234567891011121314151617181920// Ex7.javaclass StaticTest &#123; static int i = 47;&#125;class Incrementable &#123; static void increment() &#123; StaticTest.i++; &#125;&#125;public class Ex7 &#123; public static void main(String[] args) &#123; StaticTest st1 = new StaticTest(); Incrementable.increment(); StaticTest st2 = new StaticTest(); System.out.println(st1.i); System.out.println(st2.i); System.out.println(StaticTest.i); &#125;&#125; 练习91234567891011// Ex9.javapublic class Ex9 &#123; public static void main(String[] args) &#123; int i = 24; Integer bi = i; System.out.println(i); System.out.println(bi); // .... &#125;&#125; 练习101234567891011// Ex10.javapublic class Ex10 &#123; public static void main(String[] args) &#123; if (args.length == 3) &#123; System.out.println(args[0]); System.out.println(args[1]); System.out.println(args[2]); &#125; &#125;&#125; 练习111234567891011121314151617// Ex11.javaclass AllTheColorsOfTheRainbow &#123; int anIntegerRepresentingColors; void changeTheHueOfTheColor(int newHue) &#123; anIntegerRepresentingColors = newHue; &#125;&#125;public class Ex11 &#123; public static void main(String[] args) &#123; AllTheColorsOfTheRainbow allTheColorsOfTheRainbow = new AllTheColorsOfTheRainbow(); allTheColorsOfTheRainbow.changeTheHueOfTheColor(1); System.out.println(allTheColorsOfTheRainbow.anIntegerRepresentingColors); &#125;&#125;","categories":[{"name":"《Java编程思想》","slug":"《Java编程思想》","permalink":"http://blog.codeand.fun/categories/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.codeand.fun/tags/Java/"},{"name":"阅读笔记","slug":"阅读笔记","permalink":"http://blog.codeand.fun/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"name":"《Java编程思想》","slug":"《Java编程思想》","permalink":"http://blog.codeand.fun/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"},{"name":"后端","slug":"后端","permalink":"http://blog.codeand.fun/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"《 Java 编程思想》CH01 对象的概念","slug":"《-Java-编程思想》CH01-对象的概念","date":"2020-02-06T23:52:38.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2020/02/06/《-Java-编程思想》CH01-对象的概念/","link":"","permalink":"http://blog.codeand.fun/2020/02/06/%E3%80%8A-Java-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8BCH01-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5/","excerpt":"","text":"《 Java 编程思想》CH01 对象的概念@(后端开发)[Java, 阅读笔记] [TOC] 抽象过程所有编程语言都提供抽象机制，人们所能解决的问题的复杂性直接取决于抽象的类型和质量。 OOP 允许根据问题来描述问题，而不是根据运行解决方案的计算机来描述问题。 纯粹的面向对象程序设计方法： 万物皆对象 程序是对象的集合 每个对象都有自己的由其他对象所构成的存储 每个对象都拥有类型 某一个特定类型的所有对象都可以接收同样的信息 对象具有状态、行为和标识 每个对象都有一个接口所有的对象都是唯一的，但同时也是具有相同特性和行为的对象所归属的类的一部分。 类描述了具有相同特性（数据元素）和行为（功能）的对象集合，所以一个类实际上就是一个数据类型。 面向对象程序设计的挑战之一，就是在问题空间的元素和解空间的对象之间创建一对一的映射。 每个对象都只能满足某些请求，这些请求由对象的接口（interface）所定义，决定接口的便是类型。 接口确定了某一个特定对象所能发出的请求，但是，在程序中必须有满足这些请求的代码，这些代码与隐藏的数据一起构成了实现（implement） 每个对象都提供服务当正在试图开发或理解一个程序设计，最好的方法之一就是将对象想象成“服务提供者” 高内聚是软件设计的基本质量要求之一：这意味着一个软件构件的各个方面“组合的好” 被隐藏的具体实现将程序开发人员按照角色分为类创建者和客户端程序员： 客户端程序员的目标是收集各种用来实现快速应用开发的类。 类创建者的目标是构建类，这种类只向客户端程序员暴露必需的部分，而隐藏其他部分。 将实现隐藏起来可以减少程序的 bug，即访问控制，访问控制存在的原因： 让客户端程序员无法触及他们不应该触及的部分。 允许库设计者可以改变类内部的工作方式而不担心会影响到客户端程序员。 Java 中的四种访问权限： public：任何人都是可用的 private：除了类型创建者和类型的内部方法之外任何人都不能访问 protected：与 private 类似，差别在与继承于该类的派生类可以访问protected 成员 default：包访问权限，同一个包中其他类可以访问。 复用具体实现代码复用是面向对象程序设计语言所提供的最了不起的优点之一 组合（“has-a”关系）：新的类可以由任意数量、类型的其他对象以任意可以实现新的类中想要的功能的方式组成。如果组合是动态发生的，那么它通常被称为“聚合” *在建立新类时，应该首先考虑组合，而不是继承，因为它更加简单灵活。 继承两个类型可以有相同的特性和行为，但是其中一个类型可能比另一个含有更多的特性。继承使用基类型和派生类型的概念表示了这种类型之间的相似性。 一个基类型包含所有派生类所共享的特性和行为，可以创建一个基类型来表示系统中某些对象的核心概念，从基类型中派生出其他类型，来表示该核心可以被不同的方式实现。 通过继承而产生的类型等价性是理解面向对象程序设计方法内涵的重要门槛。 基类与派生类的相似性：所有可以发送给基类对象的消息同时也可以发送给派生类对象。产生基类与派生类的差异性的两种形式： 在派生类添加新方法 在派生类中改变现有基类的方法，即覆盖 “是一个”与“像是一个” “是一个”（is-a）：只是覆盖，没有添加新的方法。 “像是一个”（is-like-a）：添加了新的方法。 伴随多态的可互换对象在处理类型的层次结构时，把一个对象不当做它所属的特性类型来对待，而是将其当做其基类的对象来对待，这一可以编写出不依赖于特定类型的代码。 为了实现泛型，面向对象程序设计语言使用了后期绑定的概念，当向对象发送消息时，被调用的代码直到运行时才能确定。编译器确保被调用方法的存在，并对调用参数和返回值执行类型检查，但是并不知道将被执行的确切代码。 Java 使用了一小段特殊的代码来代替绝对地址调用。 在某些语言中（如C++），必须明确声明希望某个方法具备后期绑定，而 Java 中，动态绑定是默认行为，不需要额外添加关键字来实现多态。 单根继承结构 所有的类都最终继承自单一的基类，Java 中 这个类为 Object。 在单根继承结构中的所有对象都具有一个公用接口，所以它们归根到底都是相同的基本类型。 单根继承结构使得垃圾回收的实现变得容易得多。 容器 不同容器提供了不同类型的接口和外部行为 不同容器对于某些操作具有不同的效率 参数化类型容器是通过向下转型实现的，容器知道元素转型前的类型，则可以实现容器，这种解决方法即参数化类型，即泛型。 对象的创建和生命期 Java 完全采用动态内存分配方式，每当想要创建新对象时，就要使用 new 关键字来构建此对象的动态实例。 Java 提供了“垃圾回收”机制，它可以自动发现对象何时不再被使用，进而销毁它。 异常处理大多数错误机制的主要问题在于，它们都依赖于程序员自身的警惕性，这种警惕性来源于一种共同的约定，而不是编程语言所强制的。这种机制容易被忽视。 被抛出的异常不像方法返回的错误值和方法设置的用来表示错误条件的标志位那样可以被忽略。异常不能被忽视，所以它保证一定会在某处得到处理。 异常处理不是面向对象的特性。","categories":[{"name":"《Java编程思想》","slug":"《Java编程思想》","permalink":"http://blog.codeand.fun/categories/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.codeand.fun/tags/Java/"},{"name":"阅读笔记","slug":"阅读笔记","permalink":"http://blog.codeand.fun/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"name":"《Java编程思想》","slug":"《Java编程思想》","permalink":"http://blog.codeand.fun/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"},{"name":"后端","slug":"后端","permalink":"http://blog.codeand.fun/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"Delete Leaves With a Given Value Medium","slug":"Delete-Leaves-With-a-Given-ValueMedium","date":"2020-02-02T15:03:20.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2020/02/02/Delete-Leaves-With-a-Given-ValueMedium/","link":"","permalink":"http://blog.codeand.fun/2020/02/02/Delete-Leaves-With-a-Given-ValueMedium/","excerpt":"","text":"第63天。 水题。 今天的题目是Delete Leaves With a Given Value Medium: 太水了，不解释了。 123456789TreeNode* removeLeafNodes(TreeNode* root, int target) &#123; if (root == nullptr) return nullptr; root-&gt;left = removeLeafNodes(root-&gt;left, target); root-&gt;right = removeLeafNodes(root-&gt;right, target); if (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; target == root-&gt;val) return nullptr; else return root;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Deepest Leaves Sum","slug":"Deepest-Leaves-Sum","date":"2020-01-31T17:08:45.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2020/01/31/Deepest-Leaves-Sum/","link":"","permalink":"http://blog.codeand.fun/2020/01/31/Deepest-Leaves-Sum/","excerpt":"","text":"第62天。 今天的题目是Deepest Leaves Sum: 比较简单的题目，只要用层次遍历即可，计算每一层的和，然后把最后一层返回即可。也可以用后序遍历来完成，不过要维护每个子树的高度。 12345678910111213141516int deepestLeavesSum(TreeNode* root) &#123; if (root == nullptr) return 0; queue&lt;TreeNode *&gt; q; q.push(root); int sum = 0; while(!q.empty()) &#123; sum = 0; for(int i = 0, size = q.size(); i &lt; size; i++) &#123; root = q.front(); q.pop(); sum += root-&gt;val; if (root-&gt;left) q.push(root-&gt;left); if (root-&gt;right) q.push(root-&gt;right); &#125; &#125; return sum;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Jump Game III","slug":"Jump-Game-III","date":"2020-01-28T12:35:04.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2020/01/28/Jump-Game-III/","link":"","permalink":"http://blog.codeand.fun/2020/01/28/Jump-Game-III/","excerpt":"","text":"第61天。 今天的题目是Jump Game III: 用广度优先遍历出来即可，为了防止死循环，所以我们需要一个visited数组来记录某个位置的元素是否已经访问过来（即是否压入了队列中）： 123456789101112131415161718192021bool canReach(vector&lt;int&gt;&amp; arr, int start) &#123; queue&lt;int&gt; q; vector&lt;int&gt; visited(arr.size(), false); q.push(start); visited[start] = true; while(!q.empty()) &#123; for(int i = 0, size = q.size(); i &lt; size; i++) &#123; start = q.front(); q.pop(); if (arr[start] == 0) return true; if (start - arr[start] &gt;= 0 &amp;&amp; visited[start - arr[start]] == false) &#123; q.push(start - arr[start]); visited[start - arr[start]] = true; &#125; if (start + arr[start] &lt; arr.size() &amp;&amp; visited[start + arr[start]] == false) &#123; q.push(start + arr[start]); visited[start + arr[start]] = true; &#125; &#125; &#125; return false;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Top K Frequent Elements","slug":"Top-K-Frequent-Elements","date":"2020-01-27T21:58:53.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2020/01/27/Top-K-Frequent-Elements/","link":"","permalink":"http://blog.codeand.fun/2020/01/27/Top-K-Frequent-Elements/","excerpt":"","text":"第60天。hhh，一回家就没做了。在家无聊到开始找活干了。 今天的题目是347. Top K Frequent Elements : 挺简单的题目，先统计元素出现的次数，然后根据元素出现的次数来进行排序，然后取出现次数最多的前K个即可。 1234567891011121314151617vector&lt;int&gt; topKFrequent1(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; res(k); unordered_map&lt;int, int&gt; imap; for(int i = 0, n = nums.size(); i &lt; n; i++) &#123; imap[nums[i]]++; &#125; vector&lt;pair&lt;int, int&gt;&gt; temp(imap.begin(), imap.end()); auto f = [](const pair&lt;int, int&gt; &amp;p1, const pair&lt;int, int&gt; &amp;p2) &#123; return p1.second &gt; p2.second; &#125;; sort(temp.begin(), temp.end(), f); for(int i = 0;i &lt; k; i++) &#123; res[i] = temp[i].first; &#125; return res; &#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Evaluate Division","slug":"Evaluate-Division","date":"2020-01-13T15:33:54.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2020/01/13/Evaluate-Division/","link":"","permalink":"http://blog.codeand.fun/2020/01/13/Evaluate-Division/","excerpt":"","text":"第59天，有好几天没做了，太咸鱼了我。 今天的题目是Evaluate Division: 一道写起来比较麻烦，但是总体来看还是比较简单的。就是分为两步走即可： 利用equations和value构造一个图 然后通过在图上遍历的方式计算得到queries的值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657vector&lt;double&gt; calcEquation(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries) &#123; vector&lt;double&gt; res(queries.size()); // calc elem set unordered_map&lt;string, int&gt; smap; int index = 0; for(auto &amp;vec: equations) &#123; auto it = smap.find(vec[0]); if (it == smap.end()) smap[vec[0]] = index++; it = smap.find(vec[1]); if (it == smap.end()) smap[vec[1]] = index++; &#125; // for(auto p: smap) cout &lt;&lt; p.second &lt;&lt; endl; // build graph vector&lt;vector&lt;double&gt;&gt; graph(index, vector&lt;double&gt;(index, -1.0)); for(int k = 0, size = equations.size(); k &lt; size; k++) &#123; int i = smap[equations[k][0]], j = smap[equations[k][1]]; graph[i][j] = values[k]; graph[j][i] = 1 / values[k]; &#125; for(int k = 0, size = queries.size(); k &lt; size; k++) &#123; auto it1 = smap.find(queries[k][0]); auto it2 = smap.find(queries[k][1]); if (it1 == smap.end() || it2 == smap.end()) &#123; res[k] = -1.0; continue; &#125; if (queries[k][0] == queries[k][1]) &#123; res[k] = 1.0; continue; &#125; int i = it1-&gt;second, j = it2-&gt;second; vector&lt;bool&gt; visited(index, false); if (dfs(graph, visited,i, j, res[k]) == false) &#123; res[k] = -1.0; &#125; &#125; return res;&#125;bool dfs(vector&lt;vector&lt;double&gt;&gt; &amp;graph, vector&lt;bool&gt; &amp;visited, int s, int e, double &amp;res) &#123; if (s == e) &#123; res = 1.0; return true; &#125; visited[s] = true; for(int i = 0;i &lt; graph.size(); i++) &#123; double temp; if (visited[i] == false &amp;&amp; graph[s][i] &gt; 0 &amp;&amp; dfs(graph, visited, i, e, temp)) &#123; res = temp * graph[s][i]; return true; &#125; &#125; return false;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Construct Binary Tree from Inorder and Postorder Traversal","slug":"Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal","date":"2020-01-07T09:29:42.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2020/01/07/Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/","link":"","permalink":"http://blog.codeand.fun/2020/01/07/Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/","excerpt":"","text":"第58天。 今天的题目是Construct Binary Tree from Inorder and Postorder Traversal: 一道很久之前嫌麻烦没做的题目，因为之前做过从中序遍历和先序遍历中重构二叉树了，所以从中序遍历和后序遍历重构二叉树就之前换一下取值的位置而已： 123456789101112131415161718TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; return buildTree(inorder, postorder, 0, inorder.size() - 1, 0, postorder.size() - 1);&#125;int search(vector&lt;int&gt; &amp;inorder, int beg, int end, int val) &#123; while(beg &lt;= end &amp;&amp; inorder[beg] != val) beg++; return beg;&#125;TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder, int ibeg, int iend, int pbeg, int pend) &#123; if (ibeg &gt; iend || pbeg &gt; pend) return nullptr; if (ibeg == iend || pbeg == pend) return new TreeNode(postorder[pend]); int val = postorder[pend]; int mid = search(inorder, ibeg, iend, val); TreeNode *node = new TreeNode(val); int leftsize = mid - ibeg; node-&gt;left = buildTree(inorder, postorder, ibeg, mid-1, pbeg, pbeg + leftsize-1); node-&gt;right = buildTree(inorder, postorder, mid + 1, iend, pbeg + leftsize, pend-1); return node;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Asteroid Collision","slug":"Asteroid-Collision","date":"2020-01-06T10:46:09.000Z","updated":"2020-04-02T14:43:48.831Z","comments":true,"path":"2020/01/06/Asteroid-Collision/","link":"","permalink":"http://blog.codeand.fun/2020/01/06/Asteroid-Collision/","excerpt":"","text":"第57天。 今天的题目是Asteroid Collision: 用栈去模拟整个过程，因为STL中的栈没法直接顺序迭代出来，所以我们用vector模拟一个栈出来使用。 不难发现，最终的结果一定是小于 0 的值在前面，而大于 0 的值在后面，所以我们只用栈维护大于 0 的值。而小于 0 的值如果前面没有 大于 0 的值的话（即已经确定没有碰撞后），直接将其放入答案中。又因为我们是用vector进行的模拟，所以可以在维护栈顶指针的时候也维护一个栈底指针来实现： 12345678910111213141516171819202122232425262728vector&lt;int&gt; asteroidCollision(vector&lt;int&gt;&amp; asteroids) &#123; int size = asteroids.size(); if (size == 0) return vector&lt;int&gt;(); vector&lt;int&gt; st(size); int top, beg; for(beg = 0;beg &lt; size &amp;&amp; asteroids[beg] &lt; 0; beg++) st[beg] = asteroids[beg]; top = beg; for(int i = beg; i &lt; size;i++) &#123; int a = asteroids[i]; if (top == beg) &#123; st[top++] = a; if (a &lt; 0) beg++; &#125; else if (a &gt; 0) st[top++] = a; else if (st[top-1] == -a) top--; else if (st[top-1] &gt; -a) /* do nothing */; else &#123; while(top != beg &amp;&amp; st[top-1] &lt; -a) top--; if (top != beg &amp;&amp; st[top-1] == -a) top--; else if (top == beg) &#123; st[top] = a; top = beg = beg + 1; &#125; &#125; &#125; return vector&lt;int&gt;(st.begin(), st.begin() + top);&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Flip Equivalent Binary Trees","slug":"Flip-Equivalent-Binary-Trees","date":"2020-01-05T21:16:03.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2020/01/05/Flip-Equivalent-Binary-Trees/","link":"","permalink":"http://blog.codeand.fun/2020/01/05/Flip-Equivalent-Binary-Trees/","excerpt":"","text":"第56天。 今天的题目是Flip Equivalent Binary Trees: 简单题，先序遍历判断当前节点的值是否相等，如果不相等则返回false，如果相等的话，判断两个子树是否filpEquiv： 1234567bool flipEquiv(TreeNode* root1, TreeNode* root2) &#123; if (!root1 &amp;&amp; !root2) return true; else if (root1 &amp;&amp; root2 &amp;&amp; root1-&gt;val == root2-&gt;val) &#123; return (flipEquiv(root1-&gt;left, root2-&gt;left) &amp;&amp; flipEquiv(root1-&gt;right, root2-&gt;right)) || (flipEquiv(root1-&gt;left, root2-&gt;right) &amp;&amp; flipEquiv(root1-&gt;right, root2-&gt;left)); &#125; else return false;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Maximum Difference Between Node and Ancestor","slug":"Maximum-Difference-Between-Node-and-Ancestor","date":"2020-01-04T21:04:02.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2020/01/04/Maximum-Difference-Between-Node-and-Ancestor/","link":"","permalink":"http://blog.codeand.fun/2020/01/04/Maximum-Difference-Between-Node-and-Ancestor/","excerpt":"","text":"第55天 今天的题目是Maximum Difference Between Node and Ancestor: 我们做一次后序遍历，维护一个子树的最大值和最小值，用当前节点的值与最大最小值求距离，并返回距离的最大值即可。 1234567891011121314151617181920212223242526int maxAncestorDiff(TreeNode* root) &#123; if (root == nullptr) return -1; int minVal, maxVal; return maxAncestorDiff(root, minVal, maxVal);&#125;int maxAncestorDiff1(TreeNode *root, int &amp;minVal, int &amp;maxVal) &#123; if (root == nullptr) return -1; minVal = maxVal = root-&gt;val; int d = -1, leftMin, leftMax, rightMin, rightMax; if (root-&gt;left) &#123; int r = maxAncestorDiff(root-&gt;left, leftMin, leftMax); d = max(r, max(abs(root-&gt;val - leftMin), abs(root-&gt;val - leftMax))); minVal = min(minVal, leftMin); maxVal = max(maxVal, leftMax); &#125; if (root-&gt;right) &#123; int r = maxAncestorDiff(root-&gt;right, rightMin, rightMax); d = max(d,max(r, max(abs(root-&gt;val - rightMax), abs(root-&gt;val - rightMin)))); minVal = min(minVal, rightMin); maxVal = max(maxVal, rightMax); &#125; if (!root-&gt;left &amp;&amp; !root-&gt;right) return -1; return d;&#125; 这样做可能有点过于复杂了，我们可以把后序遍历转成先序遍历来，同样也需要维护最大值和最小值，不过因为是先序遍历，所以比较简单 123456789101112131415int maxAncestorDiff(TreeNode* root) &#123; if (root == nullptr) return -1; int minVal, maxVal; minVal = maxVal = root-&gt;val; return maxAncestorDiff(root, minVal, maxVal);&#125;int maxAncestorDiff(TreeNode *root, int maxVal, int minVal) &#123; if (root == nullptr) return maxVal - minVal; maxVal = max(maxVal, root-&gt;val); minVal = min(minVal, root-&gt;val); // cout &lt;&lt; maxVal &lt;&lt; \" \" &lt;&lt; minVal &lt;&lt; endl; return max(maxAncestorDiff(root-&gt;left, maxVal, minVal), maxAncestorDiff(root-&gt;right, maxVal, minVal));&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"All Elements in Two Binary Search Trees","slug":"All-Elements-in-Two-Binary-Search-Trees","date":"2020-01-03T11:17:32.000Z","updated":"2020-04-02T14:43:48.831Z","comments":true,"path":"2020/01/03/All-Elements-in-Two-Binary-Search-Trees/","link":"","permalink":"http://blog.codeand.fun/2020/01/03/All-Elements-in-Two-Binary-Search-Trees/","excerpt":"","text":"第54天。 今天的题目是All Elements in Two Binary Search Trees: 先用先序遍历拿到每棵树上的值，因为是二叉搜索树，所以先序得到的就是有序的值，所以做一次归并即可： 12345678910111213141516171819202122232425262728293031323334353637vector&lt;int&gt; getAllElements(TreeNode* root1, TreeNode* root2) &#123; vector&lt;int&gt; left; vector&lt;int&gt; right; getAllElements(root1, left); getAllElements(root2, right); int len = left.size() + right.size(); if (len == 0) return vector&lt;int&gt;(); vector&lt;int&gt; vec(len); int i = 0, j = 0, k = 0; while(i &lt; left.size() &amp;&amp; j &lt; right.size()) &#123; if (left[i] &lt; right[j]) vec[k++] = left[i++]; else vec[k++] = right[j++]; &#125; while(i &lt; left.size()) vec[k++] = left[i++]; while(j &lt; right.size()) vec[k++] = right[j++]; return vec; &#125;void getAllElements(TreeNode *root, vector&lt;int&gt; &amp;vec) &#123; if (root == nullptr) return ; stack&lt;TreeNode *&gt; st; while(root || !st.empty()) &#123; while(root) &#123; st.push(root); root = root-&gt;left; &#125; if (!st.empty()) &#123; root = st.top(); st.pop(); vec.push_back(root-&gt;val); root = root-&gt;right; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Implement Rand10() Using Rand7()","slug":"Implement-Rand10-Using-Rand7","date":"2020-01-02T14:52:19.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2020/01/02/Implement-Rand10-Using-Rand7/","link":"","permalink":"http://blog.codeand.fun/2020/01/02/Implement-Rand10-Using-Rand7/","excerpt":"","text":"第53天。 今天的题目是Implement Rand10() Using Rand7() 如果我们是用Rand10()去实现Rand7()的话就简单，因为 10 比 7 大，所以： 12345int rand7() &#123; int r; while((r = rand10) &gt; 7); return r;&#125; 但是题目是用Rand7()去实现Rand10，所以我们需要转换一下。 由于1/10 = 1/2 * 1/5，所以我们可以用rand5()和rand2()来实现rand10()，而rand5()和rand2()又可以用rand7()来实现，所以： 123456789101112131415int rand10() &#123; return rand5() + 5 * (rand2() - 1);&#125;int rand2() &#123; int r; while((r = rand7()) &gt; 2) &#123; &#125; return r;&#125;int rand5() &#123; int r; while((r = rand7()) &gt; 5) &#123; &#125; return r;&#125; 其期望为7/2 + 7/5，所以调用rand7()的次数会比较大，我们可以用rand7()去实现rand49()，由于49 = 7 * 7，所以我们只需要调用两次rand7()即可实现出rand49()然后用rand49()去实现一个rand40()，而rand40() % 10 + 1即实现了rand10(): 12345678int rand10() &#123; int r; while((r = rand49()) &gt; 40); return r % 10 + 1;&#125;int rand49() &#123; return (rand7()-1)*7 + rand7();&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Count Servers that Communicate","slug":"Count-Servers-that-Communicate","date":"2019-12-29T21:24:31.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/12/29/Count-Servers-that-Communicate/","link":"","permalink":"http://blog.codeand.fun/2019/12/29/Count-Servers-that-Communicate/","excerpt":"","text":"第52天，有点浪的一天。survey一点没动的我。 今天的题目是Count Servers that Communicate。 水题，只要遍历一次计算每一行和每一列之和，然后再遍历判断是否为1，且所在行或列不止一个节点即可。 1234567891011121314151617181920212223242526int countServers(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(); if (m == 0) return 0; int n = grid[0].size(); if (n == 0) return 0; vector&lt;int&gt; a(m, 0); vector&lt;int&gt; b(n, 0); for(int i = 0;i &lt; m; i++) &#123; for(int j = 0;j &lt; n; j++) &#123; if (grid[i][j]) &#123; a[i]++; b[j]++; &#125; &#125; &#125; int res = 0; for(int i = 0;i &lt; m; i++) &#123; for(int j = 0;j &lt; n; j++) &#123; if (grid[i][j] &amp;&amp; (a[i] &gt; 1 || b[j] &gt; 1)) res++; &#125; &#125; return res; &#125; 还看到一种做法，先遍历一遍，每一行都记录下值为1的grid的个数，如果个数大于一，则表示这些点都是能通信的点，如果等于一，则将该点位置记录下来。 然后将对所有记录下来的点判断一次是否其所在列的点的个数大于2。 1234567891011121314151617181920212223242526272829303132int countServers(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(); if (m == 0) return 0; int n = grid[0].size(); if (n == 0) return 0; vector&lt;int&gt; vec; int res = 0; for(int i = 0;i &lt; m; i++) &#123; vector&lt;int&gt; temp; for(int j = 0;j &lt; n; j++) &#123; if (grid[i][j]) temp.push_back(j); &#125; if (temp.size() &gt; 1) res += temp.size(); else if (temp.size() == 1) &#123; vec.push_back(temp[0]); &#125; &#125; for(auto &amp;j: vec) &#123; int count = 0; for(int i = 0;i &lt; m; i++) &#123; if (grid[i][j]) count++; if (count &gt; 1) &#123; res += 1; break; &#125; &#125; &#125; return res;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Satisfiability of Equality Equations","slug":"Satisfiability-of-Equality-Equations","date":"2019-12-28T17:04:19.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2019/12/28/Satisfiability-of-Equality-Equations/","link":"","permalink":"http://blog.codeand.fun/2019/12/28/Satisfiability-of-Equality-Equations/","excerpt":"","text":"第51天，考完期末了，hhh。虽然还有一门恶心的Survey没写。 今天的题目是Satisfiability of Equality Equations: 一道并查集的题目，先遍历一次==的式子，建立并查集，然后再遍历一次!=的式子，判断!=两边的字符是否属于不同的两个集合即可。 1234567891011121314151617181920212223bool equationsPossible(vector&lt;string&gt;&amp; equations) &#123; vector&lt;int&gt; imap(26); for(int i = 0;i &lt; 26; i++) imap[i] = i; for(auto &amp;e: equations) &#123; if (e[1] == '!') continue; int i1 = e[0] - 'a', i2 = e[3] - 'a'; while(imap[i1] != i1) i1 = imap[i1]; while(imap[i2] != i2) i2 = imap[i2]; imap[i1] = i2; &#125; for(auto &amp;e: equations) &#123; if (e[1] == '=') continue; int i1 = e[0] - 'a', i2 = e[3] - 'a'; while(imap[i1] != i1) i1 = imap[i1]; while(imap[i2] != i2) i2 = imap[i2]; if (i1 == i2) &#123; return false; &#125; &#125; return true;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Binary Tree Coloring Game","slug":"Binary-Tree-Coloring-Game","date":"2019-12-27T17:02:35.000Z","updated":"2020-04-02T14:43:48.831Z","comments":true,"path":"2019/12/27/Binary-Tree-Coloring-Game/","link":"","permalink":"http://blog.codeand.fun/2019/12/27/Binary-Tree-Coloring-Game/","excerpt":"","text":"第50天。 今天的题目是Binary Tree Coloring Game 挺唬人的题目，搞清楚题意的话，还是挺简单的。 大概的意思是，现在有一个树，然后已经有个人将其中一个节点上色成红色，问你，现在按顺序涂颜色，最后你能不能赢。这个的规则有两个： 除了第一个颜色可以随便找节点上色外，其他的都只能对自己临近的节点上色。 有颜色的节点不能再次上色 所以节点上完色后，节点多的人获胜 因为是在树上，所以给第二个以及之后的节点上色的话，只有三种选择，向父节点、向左节点、向右节点。 所以我们只要判断对手上色的第一个节点，三个方向中，是否存在一个方向的节点比剩余节点都要多。 123456789101112131415161718192021222324252627bool btreeGameWinningMove(TreeNode* root, int n, int x) &#123; if (!root) return false; TreeNode *node = search(root, x); int leftNum = getNodeNum(node-&gt;left); int rightNum = getNodeNum(node-&gt;right); int upNum = n - 1 - leftNum - rightNum; int maxNum = max(max(leftNum, rightNum), upNum); // cout &lt;&lt; leftNum &lt;&lt; endl; // cout &lt;&lt; rightNum &lt;&lt; endl; // cout &lt;&lt; upNum &lt;&lt; endl; // cout &lt;&lt; maxNum &lt;&lt; endl; return maxNum &gt; (n - maxNum);&#125;int getNodeNum(TreeNode *root) &#123; if (!root) return 0; return 1 + getNodeNum(root-&gt;left) + getNodeNum(root-&gt;right);&#125;TreeNode *search(TreeNode *root, int x) &#123; if (!root || root-&gt;val == x) return root; TreeNode *node = search(root-&gt;left, x); if (node) return node; return search(root-&gt;right, x);&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Maximum Level Sum of a Binary Tree","slug":"Maximum-Level-Sum-of-a-Binary-Tree","date":"2019-12-26T23:07:45.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/12/26/Maximum-Level-Sum-of-a-Binary-Tree/","link":"","permalink":"http://blog.codeand.fun/2019/12/26/Maximum-Level-Sum-of-a-Binary-Tree/","excerpt":"","text":"第49天。 今天的题目是Maximum Level Sum of a Binary Tree: 送分题，直接用层次便利计算每一层的元素之和，然后去最大即可。 123456789101112131415161718192021222324252627int maxLevelSum(TreeNode* root) &#123; if (!root) return -1; int max_level = -1, max_sum = INT_MIN; queue&lt;TreeNode *&gt; q; q.push(root); int cur_level = 1, cur_sum; while(!q.empty()) &#123; cur_sum = 0; for(int i = 0, size = q.size(); i &lt; size; i++) &#123; root = q.front(); q.pop(); cur_sum += root-&gt;val; if (root-&gt;left) q.push(root-&gt;left); if (root-&gt;right) q.push(root-&gt;right); &#125; if (cur_sum &gt; max_sum) &#123; max_sum = cur_sum; max_level = cur_level; &#125; cur_level++; &#125; return max_level;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Maximum Length of Repeated Subarray & Edit Distance","slug":"Maximum-Length-of-Repeated-Subarray","date":"2019-12-24T10:41:32.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/12/24/Maximum-Length-of-Repeated-Subarray/","link":"","permalink":"http://blog.codeand.fun/2019/12/24/Maximum-Length-of-Repeated-Subarray/","excerpt":"","text":"第48天。 今天的题目是Maximum Length of Repeated Subarray: 一道DP的题目，有点像LCS。 我们假定dp[i, j]为以A[i]结尾和以B[j]结尾的最长重合子数组的长度，则： $$dp[i, j] = \\left{ \\begin{aligned} 0 &amp;, &amp; A[i] \\neq B[i] \\ dp[i-1, j-1] + 1 &amp;, &amp; A[i] = B[i] \\end{aligned}\\right.$$ 然后我们只需要对dp求最大值即可得到最长重复子数组的长度： 123456789101112131415int findLength(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123; int n = A.size(); if (n == 0) return 0; vector&lt;int&gt; dp(n+1, 0); int res = 0; for(int i = 1;i &lt;= n; i++) &#123; for(int j = n;j &gt;= 1; j--) &#123; dp[j] = (A[i-1] == B[j-1]) ? (dp[j-1] + 1) : 0; res = max(dp[j], res); &#125; &#125; return res;&#125; 来多一道Edit Distance: 一道hard的题目，一次直接AC了。也是DP的题目，这道题让人觉得麻烦的是，它支持三种操作： 插入 删除 替换 一开始会觉得，插入和删除有点难区分，后来想了想，好像他们的代价是一样的，所以我们可以只用删除，不用插入，所以我们可以来解决这个问题： dp[i, j]为word1[0..i]和word2[0..j]的编辑距离： 如果word1[i] == word2[j]的话，dp[i,j] = dp[i-1, j-1]，即不需要做任何编辑 如果word1[i] != word2[j]的话，我们可以尝试删除或替换两种操作 删除word1[i] 删除word2[i] 替换word1[i]或word2[i] 则dp[i, j] = min(dp[i-1, j], dp[i, j-1], dp[i-1, j-1]) 边界条件就是，当i==0时，dp[i, j] = j,当j==0时，dp[i, j] = i。 所以我们可以写出动规方程： $$dp[i, j] = \\left{ \\begin{aligned} i &amp;, &amp; i = 0 \\ j &amp;, &amp; j = 0 \\ dp[i-1, j-1] &amp;, &amp; word1[i] = word2[j] \\ min(dp[i-1, j], dp[i, j-1], dp[i-1, j-1]) &amp;, &amp; A[i] \\neq B[i] \\end{aligned}\\right.$$ 因此，代码如下： 12345678910111213141516171819int minDistance(string word1, string word2) &#123; int n1 = word1.size(), n2 = word2.size(); vector&lt;int&gt; dp(n2 + 1); for(int j = 0;j &lt;= n2; j++) &#123; dp[j] = j; &#125; int prev; for(int i = 1; i &lt;= n1; i++) &#123; prev = dp[0]; dp[0] = i; for(int j = 1;j &lt;= n2; j++) &#123; swap(dp[j], prev); if (word1[i-1] != word2[j-1]) &#123; dp[j] = min(min(dp[j-1], dp[j]), prev) + 1; &#125; &#125; &#125; return dp[n2];&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Flipping an Image","slug":"Flipping-an-Image","date":"2019-12-23T09:52:11.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/12/23/Flipping-an-Image/","link":"","permalink":"http://blog.codeand.fun/2019/12/23/Flipping-an-Image/","excerpt":"","text":"第47天 今天的题目是Flipping an Image: 考试周，做一道Easy题。 1234567891011vector&lt;vector&lt;int&gt;&gt; flipAndInvertImage(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123; int t; for(auto &amp;v: A) &#123; for(int i = 0, j = v.size() - 1;i &lt;= j; i++, j--) &#123; t = (v[j]==1) ? 0 : 1; v[j] = (v[i]==1) ? 0 : 1; v[i] = t; &#125; &#125; return A;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Interval List Intersections","slug":"Interval-List-Intersections","date":"2019-12-22T10:31:30.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/12/22/Interval-List-Intersections/","link":"","permalink":"http://blog.codeand.fun/2019/12/22/Interval-List-Intersections/","excerpt":"","text":"第46天。 今天的题目是Interval List Intersections: 挺简单的题目，用两个指针控制就好了： 1234567891011121314151617vector&lt;vector&lt;int&gt;&gt; intervalIntersection(vector&lt;vector&lt;int&gt;&gt;&amp; A, vector&lt;vector&lt;int&gt;&gt;&amp; B) &#123; vector&lt;vector&lt;int&gt;&gt; res; int i = 0, j = 0; while(i &lt; A.size() &amp;&amp; j &lt; B.size()) &#123; // check A[i] and B[j] int left = max(A[i][0], B[j][0]), right = min(A[i][1], B[j][1]); if (left &lt;= right) res.push_back(&#123;left, right&#125;); // update i and j if (A[i][1] &gt; B[j][1]) j++; else if (A[i][1] &lt; B[j][1]) i++; else &#123; i++; j++; &#125; &#125; return res;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Binary Search Tree to Greater Sum Tree","slug":"Binary-Search-Tree-to-Greater-Sum-Tree","date":"2019-12-21T10:26:41.000Z","updated":"2020-04-02T14:43:48.831Z","comments":true,"path":"2019/12/21/Binary-Search-Tree-to-Greater-Sum-Tree/","link":"","permalink":"http://blog.codeand.fun/2019/12/21/Binary-Search-Tree-to-Greater-Sum-Tree/","excerpt":"","text":"第45天。 今天的题目是Binary Search Tree to Greater Sum Tree: 感觉这道题的题意很奇怪，不清不楚的，不过看Example还是看的出他问的是什么的，挺简单的题目： 1234567891011121314TreeNode* bstToGst(TreeNode* root) &#123; if (root == nullptr) return root; int sum = 0; return bstToGst(root, sum);&#125;TreeNode* bstToGst(TreeNode* root, int &amp;sum) &#123; if (root == nullptr) return root; // TreeNode *node = new TreeNode(root-&gt;val); root-&gt;right = bstToGst(root-&gt;right, sum); root-&gt;val = sum = root-&gt;val + sum; root-&gt;left = bstToGst(root-&gt;left, sum); return root;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Find Eventual Safe States","slug":"Find-Eventual-Safe-States","date":"2019-12-20T12:53:23.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/12/20/Find-Eventual-Safe-States/","link":"","permalink":"http://blog.codeand.fun/2019/12/20/Find-Eventual-Safe-States/","excerpt":"","text":"第44天。 今天的题目是Find Eventual Safe States: 最开始的想法是，从安全的节点开始在图中进行扩散，当一个节点所有边都指向一个安全的节点时，那它也是一个安全的节点，但是这样复杂度挺高的，所以虽然能过： 12345678910111213141516171819202122232425262728293031323334bool check(vector&lt;vector&lt;int&gt;&gt;&amp; graph, vector&lt;bool&gt; &amp;color, int i) &#123; for(auto &amp;j: graph[i]) &#123; if (!color[j]) return false; &#125; return true;&#125;vector&lt;int&gt; eventualSafeNodes(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123; int size = graph.size(); vector&lt;int&gt; res; if (size == 0) return res; vector&lt;bool&gt; color(size, false); bool change = false; for(int i = 0;i &lt; size; i++) if (graph[i].size() == 0) &#123; color[i] = true; change = true; &#125; while(change) &#123; change = false; for(int i = 0;i &lt; size; i++) &#123; if (color[i] == false &amp;&amp; check(graph, color, i)) &#123; color[i] = true; change = true; &#125; &#125; &#125; for(int i = 0;i &lt; size; i++) &#123; if (color[i]) res.push_back(i); &#125; return res;&#125; 后来发现好像可以用深度优先来做，主要的想法是，一个环中所有的节点都是不安全的，我们把不安全的节点都筛选出来，即可得到所有安全的节点。因此就把问题变成了找到图中所有在环中的节点。在DFS时，维护一个状态，这个状态可能为： 0：未访问（初始状态） 1：访问中 2：访问完成（安全状态） 3：在环中（不安全状态） 先把所有节点的状态都初始化为0,当对第 i 个节点调用 dfs 时，则将其转换为1,然后遍历该节点所有能走的边，如果下一个节点的状态为0，则对其调用dfs，如果下一个节点的状态为1或2，则该节点出现在环中，将状态转换为3，并直接返回为3。当 i 节点对 j 节点调用 dfs 后，返回值如果为3的话，则 i 节点状态也变为 3, 并直接返回3。 如果第 i 个节点对所有路径都调用了 dfs 后，没有遇到返回值为 3 的情况，则该节点为安全的，所以将其状态转换为 2。 代码如下： 1234567891011121314151617181920212223242526272829303132vector&lt;int&gt; eventualSafeNodes(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123; int size = graph.size(); vector&lt;int&gt; res; if (size == 0) return res; vector&lt;int&gt; color(size, 0); // 0 mean unvisit for(int i = 0;i &lt; size; i++) &#123; if (color[i] == 0) dfs(graph, color, i); &#125; for(int i = 0;i &lt; size; i++) &#123; if (color[i] == 2) res.push_back(i); &#125; return res; &#125;int dfs(vector&lt;vector&lt;int&gt;&gt; &amp;graph, vector&lt;int&gt; &amp;color, int node) &#123; // cout &lt;&lt; \"visit\" &lt;&lt; node &lt;&lt; endl; color[node] = 1; // in dfs for(int j = 0;j &lt; graph[node].size(); j++) &#123; int i = graph[node][j]; if ( (color[i] == 0 &amp;&amp; dfs(graph, color, i) == 3) || color[i] == 1 || color[i] == 3 ) &#123; color[node] = 3; return 3; &#125; &#125; color[node] = 2;// safe node return color[node];&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Flatten a Multilevel Doubly Linked List","slug":"Flatten-a-Multilevel-Doubly-Linked-List","date":"2019-12-19T10:11:29.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/12/19/Flatten-a-Multilevel-Doubly-Linked-List/","link":"","permalink":"http://blog.codeand.fun/2019/12/19/Flatten-a-Multilevel-Doubly-Linked-List/","excerpt":"","text":"第43天。 今天的题目是Flatten a Multilevel Doubly Linked List: 蛮好玩的一道题。 本来想用递归做的，但是发现好像需要一层一层的返回最后一个指针，觉得有点麻烦，就直接用栈做了。 这个栈是用来保存上一层的指针的，而且看起来每一层最多一个节点有child，所以我们可以这样做： 遍历当前层，如果有孩子，则把当前节点压入栈中，并跳到下一层去遍历 如果遍历完当前层，则从栈中取出parent，然后进行flatten,为了避免没有必要的重复遍历，当前层最后一个节点压入栈中,这样下一次遍历时，就从上一层中第一个未被遍历的节点开始了。 代码如下： 12345678910111213141516171819202122232425Node* flatten(Node* head) &#123; if (head == nullptr) return nullptr; stack&lt;Node*&gt; st; st.push(head); // if (head-&gt;child) st.push(head-&gt;child); while(!st.empty()) &#123; Node *p = st.top(); st.pop(); while(!p-&gt;child &amp;&amp; p-&gt;next) &#123; p = p-&gt;next; &#125; if (p-&gt;child) &#123; st.push(p); st.push(p-&gt;child); &#125; else if (!st.empty()) &#123; Node *parent = st.top(); st.pop(); p-&gt;next = parent-&gt;next; if (p-&gt;next) p-&gt;next-&gt;prev = p; parent-&gt;next = parent-&gt;child; parent-&gt;next-&gt;prev = parent; parent-&gt;child = nullptr; st.push(p); &#125; &#125; return head;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Find Largest Value in Each Tree Row","slug":"Find-Largest-Value-in-Each-Tree-Row","date":"2019-12-18T11:08:25.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/12/18/Find-Largest-Value-in-Each-Tree-Row/","link":"","permalink":"http://blog.codeand.fun/2019/12/18/Find-Largest-Value-in-Each-Tree-Row/","excerpt":"","text":"第42天。 今天的题目是Find Largest Value in Each Tree Row: 水题，用队列做树的层次遍历即可： 12345678910111213141516171819vector&lt;int&gt; largestValues(TreeNode* root) &#123; vector&lt;int&gt; res; if (root == nullptr) return res; queue&lt;TreeNode *&gt; q; q.push(root); while(!q.empty()) &#123; int max_v = INT_MIN; for(int i = 0, size = q.size(); i &lt; size; i++) &#123; root = q.front(); q.pop(); max_v = max(max_v, root-&gt;val); if (root-&gt;left) q.push(root-&gt;left); if (root-&gt;right) q.push(root-&gt;right); &#125; res.push_back(max_v); &#125; return res;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Validate Stack Sequences","slug":"Validate-Stack-Sequences","date":"2019-12-17T11:52:17.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2019/12/17/Validate-Stack-Sequences/","link":"","permalink":"http://blog.codeand.fun/2019/12/17/Validate-Stack-Sequences/","excerpt":"","text":"第41天。 今天的题目是Validate Stack Sequences: 简单题，直接模拟就好了： 1234567891011121314151617bool validateStackSequences(vector&lt;int&gt;&amp; pushed, vector&lt;int&gt;&amp; popped) &#123; stack&lt;int&gt; st; int i = 0; for(auto &amp;t: popped) &#123; if (!st.empty() &amp;&amp; st.top() == t) &#123; st.pop(); &#125; else &#123; while(i &lt; pushed.size() &amp;&amp; pushed[i] != t) &#123; st.push(pushed[i]); i++; &#125; if (pushed.size() == i) return false; i++; &#125; &#125; return true;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Network Delay Time","slug":"Network-Delay-Time","date":"2019-12-16T14:22:11.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/12/16/Network-Delay-Time/","link":"","permalink":"http://blog.codeand.fun/2019/12/16/Network-Delay-Time/","excerpt":"","text":"第40天。 今天的题目是Network Delay Time: 一道图的题目，比较常规，用Dijkstra求单源最短路，然后取距离最远的那个即可得到Network Delay Time: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int minDisNode(vector&lt;bool&gt; &amp;visited, vector&lt;int&gt; &amp;dis) &#123; int min_v = INT_MAX, min_i = -1;; for(int j = 0;j &lt; dis.size();j++) &#123; if (!visited[j] &amp;&amp; dis[j] &lt; min_v) &#123; min_v = dis[j]; min_i = j; &#125; &#125; return min_i;&#125;int networkDelayTime(vector&lt;vector&lt;int&gt;&gt;&amp; times, int N, int K) &#123; if (times.size() == 0 || N==0 || K &lt;= 0) return -1; //build graph; vector&lt;vector&lt;int&gt;&gt; graph(N, vector&lt;int&gt;(N, INT_MAX)); for(auto &amp;t: times) &#123; graph[t[0]-1][t[1]-1] = t[2]; &#125; K--; vector&lt;int&gt; dis(N, INT_MAX); vector&lt;bool&gt; visited(N, false); visited[K] = true; for(int i = 0;i &lt; dis.size(); i++) &#123; dis[i] = graph[K][i]; &#125; dis[K] = 0; for(int i = 1;i &lt; N; i++) &#123; // find a unvisited node which dis is min int j = minDisNode(visited, dis); if (j == -1) return -1; visited[j] = true; for(int k = 0;k &lt; dis.size(); k++) &#123; if (graph[j][k] != INT_MAX) &#123; dis[k] = min(dis[k], dis[j] + graph[j][k]); &#125; &#125; &#125; int res = 0; for(int i = 0;i &lt; N;i++) &#123; if (dis[i] != INT_MAX) res = max(res, dis[i]); &#125; return res;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Largest Sum of Averages","slug":"Largest-Sum-of-Averages","date":"2019-12-15T11:19:51.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/12/15/Largest-Sum-of-Averages/","link":"","permalink":"http://blog.codeand.fun/2019/12/15/Largest-Sum-of-Averages/","excerpt":"","text":"第39天。 今天的题目是Largest Sum of Averages: 一道动态规划的题目，有点想切钢管的问题。 动规方程如下： $$dp[i, j] = \\left{ \\begin{aligned} \\sum_{z=0}^j A[z] &amp; &amp; i = 1\\ \\underset{ {i-1 \\leq t \\leq n-1} }{max} { dp[i-1, t] + \\frac {\\sum_{z=t+1}^n A[z]} {n-t+1} } &amp; &amp; others \\end{aligned}\\right.$$ 12345678910111213141516171819202122double largestSumOfAverages(vector&lt;int&gt;&amp; A, int K) &#123; // vector&lt;vector&lt;double&gt;&gt; dp(K + 1, vector&lt;double&gt;(A.size(), 0)); vector&lt;double&gt; dp(A.size(), 0); double sum = 0; int count; for(int j = 0;j &lt; A.size(); j++) &#123; sum += A[j]; dp[j] = sum / (j + 1); &#125; for(int i = 1;i &lt; K; i++) &#123; for(int j = A.size() - 1;j &gt;= i; j--) &#123; sum = 0; count = 0; for(int t = j;t &gt;= i; t--) &#123; sum += A[t]; count++; dp[j] = max(dp[j], dp[t-1] + sum/count); &#125; &#125; &#125; return dp[A.size()-1];&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Unique Substrings in Wraparound String","slug":"Unique-Substrings-in-Wraparound-String","date":"2019-12-14T10:53:43.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2019/12/14/Unique-Substrings-in-Wraparound-String/","link":"","permalink":"http://blog.codeand.fun/2019/12/14/Unique-Substrings-in-Wraparound-String/","excerpt":"","text":"第38天。 今天的题目是Unique Substrings in Wraparound String: 这道题麻烦的地方在于，子串需要去除重复。我们把问题转换一下，即以字符 c 结尾的子串的个数。不难发现，最长长度和子串个数是相同的。这样的话，我们可以在遍历时维护一个变量len来保存，以当前字符结尾的子串的长度，通过判断当前字符与上一个字符是否在s中相邻，来确定以当期字符结尾的子串的个数。同时，为了去除重复，我们可以用一个长度为26的字典来保存每个以字符 c 结尾的子串的最长长度。最后，我们只需要对字典进行一次求和即可。 123456789101112131415161718192021int findSubstringInWraproundString(string p) &#123; if (p.size() == 0) return 0; vector&lt;int&gt; dict(26, 0); int len = 1; int prev = p[0] - 'a'; dict[prev] = 1; for(int i = 1;i &lt; p.size();i++) &#123; int temp = p[i] - 'a'; if ((prev + 1) % 26 == temp) &#123; dict[temp] = max(++len, dict[temp]); &#125; else &#123; len = 1; dict[temp] = max(dict[temp], 1); &#125; prev = temp; &#125; // sum int res = 0; for(auto i: dict) res += i; return res;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Redundant Connection","slug":"Redundant-Connection","date":"2019-12-13T11:31:41.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/12/13/Redundant-Connection/","link":"","permalink":"http://blog.codeand.fun/2019/12/13/Redundant-Connection/","excerpt":"","text":"第37天。 今天的题目是Redundant Connection: 这道题用并查集可以解决掉，具体思路如下： 首先初始化一个并查集，然后遍历输入edges，使用并查集查找两个节点所在的集合，如果两个节点在同一个节点中，那么往图里面加入这条边就会出现环，即无法构成树，因此这条边就是我们要求的边；如果不在集合，那么就将这条边插入到图中（即合并两个集合）。具体实现如下： 12345678910111213141516int root(vector&lt;int&gt; &amp;ids, int i) &#123; while(ids[i] != i) i = ids[i]; return i;&#125;vector&lt;int&gt; findRedundantConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123; if (edges.size() == 0) return vector&lt;int&gt;(); vector&lt;int&gt; ids(edges.size()); for(int i = 0;i &lt; ids.size(); i++) ids[i] = i; for(auto &amp;e: edges) &#123; int n1 = root(ids, e[0]-1), n2 = root(ids, e[1]-1); if (n1 == n2) return e; ids[n1] = n2; &#125; return *edges.rbegin();&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Print FooBar Alternately","slug":"Print-FooBar-Alternately","date":"2019-12-12T10:40:17.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/12/12/Print-FooBar-Alternately/","link":"","permalink":"http://blog.codeand.fun/2019/12/12/Print-FooBar-Alternately/","excerpt":"","text":"第36天。 今天的题目是Print FooBar Alternately: 一道简单的并发的题目，交替输出Foo和Bar，就是要并发的两个线程，按顺序交替执行，我们可以用两个mutxe去实现： 123456789101112131415161718192021222324252627282930class FooBar &#123;private: int n; mutex m1, m2;public: FooBar(int n) &#123; this-&gt;n = n; m2.lock(); &#125; void foo(function&lt;void()&gt; printFoo) &#123; for (int i = 0; i &lt; n; i++) &#123; m1.lock(); // printFoo() outputs \"foo\". Do not change or remove this line. printFoo(); m2.unlock(); &#125; &#125; void bar(function&lt;void()&gt; printBar) &#123; for (int i = 0; i &lt; n; i++) &#123; m2.lock(); // printBar() outputs \"bar\". Do not change or remove this line. printBar(); m1.unlock(); &#125; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Binary Tree Pruning","slug":"Binary-Tree-Pruning","date":"2019-12-11T10:47:58.000Z","updated":"2020-04-02T14:43:48.831Z","comments":true,"path":"2019/12/11/Binary-Tree-Pruning/","link":"","permalink":"http://blog.codeand.fun/2019/12/11/Binary-Tree-Pruning/","excerpt":"","text":"第35天。 今天的题目是Binary Tree Pruning: 简单题，用先序遍历做就好了，而且不需要使用flag或count等额外的变量来判断是否要删除当前节点。 大概逻辑如下： 先序遍历时，用left = pruneTree(left)的方式去调用，在遍历完子树后，当前节点的子树都是只包含1的树了，我们可以通过判断指针是否为空来确定子树中是否有1，进而判断出是否要删除当前节点，所以我们不需要维护额外的变量来判断。 12345678TreeNode* pruneTree(TreeNode* root) &#123; if (root == nullptr) return nullptr; root-&gt;left = pruneTree(root-&gt;left); root-&gt;right = pruneTree(root-&gt;right); if (root-&gt;left || root-&gt;right || root-&gt;val == 1) return root; delete root; return nullptr;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Friend Circles","slug":"Friend-Circles","date":"2019-12-10T13:34:41.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/12/10/Friend-Circles/","link":"","permalink":"http://blog.codeand.fun/2019/12/10/Friend-Circles/","excerpt":"","text":"第34天。 今天的题目是Friend Circles: 一道图论的题目，求连通分量的个数。这道题之前考研复试面试时遇到过。 用并查集去做会比较快，但是需要对并查集做一定修改。 简单来说，并查集的数组全初始化为0，然后在遍历到M[i][j]==true时进行union操作. 遍历完后，arr中值为-1的元素的个数就是连通分量的个数： 123456789101112131415161718192021222324252627282930vector&lt;int&gt; arr;int root(vector&lt;int&gt; &amp;arr, int i) &#123; int root = i; while(arr[root] != -1) root = arr[root]; return root;&#125;void unionFunc(int i, int j) &#123; i = root(arr, i); j = root(arr, j); if (i == j) return; arr[j] = i;&#125;int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123; if (M.size() == 0) return 0; int size = M.size(); arr = vector&lt;int&gt;(size, -1); for(int i = 0;i &lt; size; i++) &#123; for(int j = i+1;j &lt; size; j++) &#123; if (M[i][j]) &#123; unionFunc(i, j); &#125; &#125; &#125; int res = 0; for(int i = 0;i &lt; size; i++) res += (arr[i] == -1); return res;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Minimum ASCII Delete Sum for Two Strings","slug":"Minimum-ASCII-Delete-Sum-for-Two-Strings","date":"2019-12-09T17:17:49.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/12/09/Minimum-ASCII-Delete-Sum-for-Two-Strings/","link":"","permalink":"http://blog.codeand.fun/2019/12/09/Minimum-ASCII-Delete-Sum-for-Two-Strings/","excerpt":"","text":"第33天。 今天的题目是Minimum ASCII Delete Sum for Two Strings: 一道动态规划的问题，而且挺常规的。这道题的动规方程如下： $$dp[i, j] = \\left{\\begin{aligned} \\sum_{k=0}^{j} s2[k] &amp; ,&amp; i == 0 \\ \\sum_{k=0}^{i} s1[k] &amp; ,&amp; j == 0 \\ dp[i-1, j-1] &amp; ,&amp; s1[i] == s2[j] \\ min{dp[i-1][j] + s1[i], dp[i][j-1] + s2[j] } &amp; ,&amp; s1[i] == s2[j]\\end{aligned}\\right.$$ 其中d[i, j]表示字符串s1[0, i)和字符串s2[0, j)的最小删除ASCII之和。根据动规方程可以写出如下代码： 123456789101112131415161718192021222324int minimumDeleteSum(string s1, string s2) &#123; vector&lt;int&gt; dp(s2.size() + 1); dp[0] = 0; for(int i = 1;i &lt; dp.size(); i++) &#123; dp[i] = dp[i-1] + s2[i-1]; &#125; int prev; for(int i = 0;i &lt; s1.size(); i++) &#123; prev = dp[0]; dp[0] += s1[i]; for(int j = 1;j &lt;= s2.size(); j++) &#123; if (s1[i] == s2[j-1]) &#123; swap(prev, dp[j]); &#125; else &#123; prev = dp[j]; dp[j] = min(dp[j] + s1[i], dp[j-1] + s2[j-1]); &#125; &#125; &#125; return dp[s2.size()];&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Rotate Function","slug":"Rotate-Function","date":"2019-12-08T11:04:58.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2019/12/08/Rotate-Function/","link":"","permalink":"http://blog.codeand.fun/2019/12/08/Rotate-Function/","excerpt":"","text":"第32天。 今天的题目是Rotate Function。 这道题是一道数学题，直接求解的话显然复杂度很高，然后这道题也没法把大问题化简到小问题，所以用常规的分治、动规和贪心去想这道题的话，是没法找到答案的。 为了解决这道题，我们先把 $F(k)$ 的写出来： $$F(k) = 0 * B_k[0] + 1 * B_k[1] + … + (n - 1) * B_k[n-1]$$ 然后我们通过题意可以知道 $B_k[i] = A[(i+k) % n]$ ，所以： $$\\begin{aligned}F(k) &amp;= 0 * B_k[0] + 1 * B_k[1] + … + (n - 1) * B_k[n-1] \\ &amp;= 0 * A[(0+k) % n] + A[(1+k) % n] + … + (n - 1) * A[(n-1+k) % n] \\ &amp;= \\sum_{i=0}^{n-1} i * A[(i+k) % n]\\end{aligned}$$ 我们可以尝试把 $(i + k) % n$ 中的 取模运算去掉： $$ \\begin{aligned}F(k) &amp;= \\sum_{i=0}^{n-1} i * A[(i+k) % n] \\ &amp;= \\sum_{i=1}^{n-k-1} i * A[i+k] + \\sum_{i=n-k}^{n-1} i * A[i + k -n] \\\\end{aligned} $$ 我们把 $j = i - k$ 代入 $\\sum_{i=1}^{n-k-1} i * A[i+k]$ 和 $j = i + k -n$ 代入 $\\sum_{i=n-k}^{n-1} i * A[i + k -n]$ : $$\\begin{aligned}F(k) &amp;= \\sum_{j=k}^{n-1} (j - k) * A[j] + \\sum_{j=0}^{k-1} (j + n -k) * A[j] \\ &amp; = \\sum_{j=0}^{n-1} j * A[j] + n * \\sum_{j=0}^{k-1} A[j] - k * \\sum_{j=0}^{n-1} A[j]\\end{aligned}$$ 上面的公式中 $\\sum_{j=0}^{n-1} j * A[j]$ 和 $\\sum_{j=0}^{n-1} A[j]$ 都是常数，因此我们可以可以用 $O(n)$ 的时间复杂度解决这道题： 123456789101112131415int maxRotateFunction(vector&lt;int&gt;&amp; A) &#123; if (A.size() == 0) return 0; long long s1 = 0, s2 = 0; for(int i = 0, size = A.size(); i &lt; size; i++) &#123; s1 += A[i]; s2 += i*A[i]; &#125; long long res = LONG_MIN; long long t = 0; for(int k = 0, n = A.size();k &lt; n; k++) &#123; t += A[k]; res = max(res,n * t - (k+1) * s1); &#125; return res + s2;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Longest Word in Dictionary through Deleting","slug":"Longest-Word-in-Dictionary-through-Deleting","date":"2019-12-07T09:10:19.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/12/07/Longest-Word-in-Dictionary-through-Deleting/","link":"","permalink":"http://blog.codeand.fun/2019/12/07/Longest-Word-in-Dictionary-through-Deleting/","excerpt":"","text":"第31天。 今天的题目是Longest Word in Dictionary through Deleting: 很常规的题目。 因为题目要求返回的是最长的字符串，同时如果有多个解的话，就返回字典序最小的那个，所以我们先按要求进行一次排序。然后在 check 一下是否符合即可。代码如下： 12345678910111213141516171819202122bool check(const string &amp;s, const string &amp;t) &#123; int index = 0, i; for(i = 0; i &lt; t.size(); ++i) &#123; while(index &lt; s.size() &amp;&amp; s[index] != t[i]) index++; if (index == s.size()) break; else index++; &#125; return i == t.size();&#125;string findLongestWord(string s, vector&lt;string&gt;&amp; d) &#123; sort(d.begin(), d.end(),[](const string &amp;s1, const string &amp;s2) &#123; if (s1.size() != s2.size()) return s1.size() &gt; s2.size(); else return s1 &lt; s2; &#125;); for(int i = 0;i &lt; d.size(); i++) &#123; if (check(s, d[i])) return d[i]; &#125; return \"\";&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Partition Labels","slug":"Partition-Labels","date":"2019-12-06T10:33:53.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/12/06/Partition-Labels/","link":"","permalink":"http://blog.codeand.fun/2019/12/06/Partition-Labels/","excerpt":"","text":"第30天，一个月了。 今天的题目是Partition Labels: 这道题的解法如下： 先遍历一次字符串统计字符出现的次数保存在c1上，然后在遍历一次字符串，这次遍历时同样进行统计字符出现次数保存在c2上，并维护一个变量cnum，这个变量cnum表示当前出现过但是未出现完全的字符的种类数。当出现cnum为 0 时，就表示完成了一次划分。代码如下： 123456789101112131415161718192021vector&lt;int&gt; partitionLabels(string S) &#123; vector&lt;int&gt; c1(26, 0); for(int i = 0, size = S.size(); i &lt; size; i++) &#123; c1[S[i] - 'a']++; &#125; vector&lt;int&gt; c2(26, 0); vector&lt;int&gt; res; int temp = 1, cnum = 0; for(int i = 0, size = S.size(); i &lt; size; i++, temp++) &#123; int index = S[i] - 'a'; if (c2[index] == 0) &#123; cnum++; &#125; if (++c2[index]== c1[index] &amp;&amp; --cnum == 0) &#123; res.push_back(temp); temp = 0; &#125; &#125; return res;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Add and Search Word - Data structure design","slug":"Add-and-Search-Word-Data-structure-design","date":"2019-12-05T12:48:24.000Z","updated":"2020-04-02T14:43:48.831Z","comments":true,"path":"2019/12/05/Add-and-Search-Word-Data-structure-design/","link":"","permalink":"http://blog.codeand.fun/2019/12/05/Add-and-Search-Word-Data-structure-design/","excerpt":"","text":"第29天。 今天的题目是Add and Search Word - Data structure design: 一道字典树的题目，如果知道字典树是怎样的话，应该不难做。不过这道题直接套字典树是不行的，因为它需要支持 . 字符来标识任意字符，所以我们在Search的时候需要做一定的修改。简单的来说就是原本用一个指针进行搜索，现在需要一个队列来维护多个指针进行搜索，恩，仅此而已。代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class TrieNode&#123; public: char c; vector&lt;TrieNode*&gt; childs; bool flag; TrieNode(char _c):c(_c),childs(26, nullptr),flag(false) &#123; &#125; TrieNode *addChild(char c) &#123; if (childs[c - 'a']) return childs[c - 'a']; else return childs[c - 'a'] = new TrieNode(c); &#125;&#125;;class WordDictionary &#123; TrieNode *root;public: /** Initialize your data structure here. */ WordDictionary():root(new TrieNode('?')) &#123; &#125; /** Adds a word into the data structure. */ void addWord(string word) &#123; //cout &lt;&lt; \"Add \" &lt;&lt; word &lt;&lt; endl; TrieNode *p = root; for(auto c: word) &#123; p = p-&gt;addChild(c); &#125; p-&gt;flag = true; &#125; /** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */ bool search(string word) &#123; // cout &lt;&lt; \"Search \" &lt;&lt; word &lt;&lt; endl; queue&lt;TrieNode *&gt; q; q.push(root); for(auto c: word) &#123; if (q.empty()) return false; // cout &lt;&lt; c &lt;&lt; \" \"; if (c == '.') &#123; for(int i = 0,size = q.size();i &lt; size; i++) &#123; TrieNode *p = q.front(); q.pop(); for(int j = 0;j &lt; 26;j++) &#123; if (p-&gt;childs[j]) q.push(p-&gt;childs[j]); &#125; &#125; &#125; else &#123; for(int i = 0,size = q.size();i &lt; size; i++) &#123; TrieNode *p = q.front(); q.pop(); if (p-&gt;childs[c - 'a']) q.push(p-&gt;childs[c - 'a']); &#125; &#125; &#125; while(!q.empty()) &#123; if (q.front()-&gt;flag) return true; q.pop(); &#125; return false; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Best Sightseeing Pair","slug":"Best-Sightseeing-Pair","date":"2019-12-04T18:58:44.000Z","updated":"2020-04-02T14:43:48.831Z","comments":true,"path":"2019/12/04/Best-Sightseeing-Pair/","link":"","permalink":"http://blog.codeand.fun/2019/12/04/Best-Sightseeing-Pair/","excerpt":"","text":"第28天。 今天的题目是Best Sightseeing Pair: 这道题的关键就是什么时候移动 i 这个下标，我们观察一下这个公式：A[i] + A[j] + i - j，转化一下就成了(A[i] + i) + (A[j] - j)，因此如果存在两个i，即i1和i2的话，当A[i1] + i1 &gt; A[i2] + i2成立时，我们就可以用 i2去替代原来的i1。至于j的话，我们只需要从头到尾遍历一遍即可，同时在穷举j的时候，可以顺便穷举出i： 123456789101112int maxScoreSightseeingPair(vector&lt;int&gt;&amp; A) &#123; int size = A.size(); int res = 0; if (size == 0) return res; for(int i = 0, j = 1;j &lt; size; j++) &#123; res = max(res, A[i] + A[j] + i - j); if (A[j] + j &gt; A[i] + i) i = j; &#125; return res;&#125; 我们把式子重写成A[j] + (A[i] + i - j)，随着j++，i - j会减一，如果不改变 i的话，(A[i] + i - j)相比于之前就只是减一而已，如果要改变的话，A[i] + i - j = A[j] - 1,则我们可以将循环简化成： 123456789101112int maxScoreSightseeingPair(vector&lt;int&gt;&amp; A) &#123; int size &#x3D; A.size(); int res &#x3D; 0; if (size &#x3D;&#x3D; 0) return res; int cur &#x3D; 0; for(int j &#x3D; 0;j &lt; size; j++) &#123; res &#x3D; max(res, cur + A[j]); cur &#x3D; max(cur, A[j]) - 1; &#125; return res;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Longest Palindromic Subsequence","slug":"Longest-Palindromic-Subsequence","date":"2019-12-03T12:12:04.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/12/03/Longest-Palindromic-Subsequence/","link":"","permalink":"http://blog.codeand.fun/2019/12/03/Longest-Palindromic-Subsequence/","excerpt":"","text":"第27天。 今天的题目是Longest Palindromic Subsequence： 一道动态规划的问题，我们假定dp[i, j]是字符串S[i:j]最长回文串的长度。那么我们可以写出如下动规方程： $$dp[i, j] = \\left{\\begin{aligned}dp[i-1, j-1] + 2 &amp; &amp;,s[i] = s[j] \\max{d[i-1,j], dp[i, j-1]} &amp; &amp;,s[i] \\neq s[j]\\end{aligned}\\right.$$ 有了动规方程后，这个问题就简单多了： 123456789101112131415int longestPalindromeSubseq1(string s) &#123; int size = s.size(); vector&lt;vector&lt;int&gt;&gt; dp(size, vector&lt;int&gt;(size, 0)); for(int i = size - 1;i &gt;= 0; i--) &#123; dp[i][i] = 1; for(int j = i + 1;j &lt; size;j++) &#123; if (s[i] == s[j]) &#123; dp[i][j] = dp[i+1][j-1] + 2; &#125; else &#123; dp[i][j] = max(dp[i+1][j], dp[i][j-1]); &#125; &#125; &#125; return dp[0][size-1];&#125; 为了减少空间复杂度，我们可以这样优化： 123456789101112131415161718192021int longestPalindromeSubseq(string s) &#123; int size = s.size(); vector&lt;int&gt; dp1(size, 0), dp2(size, 0); for(int i = size - 1;i &gt;= 0; i--) &#123; dp2[i] = 1; dp1[i] = 0; for(int j = i + 1;j &lt; size;j++) &#123; if (s[i] == s[j]) &#123; // dp[i][j] = dp[i+1][j-1] + 2; dp2[j] = dp1[j-1] + 2; &#125; else &#123; // dp[i][j] = max(dp[i+1][j], dp[i][j-1]); dp2[j] = max(dp1[j], dp2[j-1]); &#125; &#125; swap(dp1, dp2); &#125; return dp1[size-1];&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Global and Local Inversions","slug":"Global-and-Local-Inversions","date":"2019-12-02T10:11:09.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/12/02/Global-and-Local-Inversions/","link":"","permalink":"http://blog.codeand.fun/2019/12/02/Global-and-Local-Inversions/","excerpt":"","text":"第26天 今天的题目是Global and Local Inversions： 看上去挺复杂的题目，但是我们可以从题目中知道，输入的数组是一个 [0,1,...,N-1] 的一个排列，所以A中的元素是有限定的， 多举几个例子就可以发现如果一个排列要满足 local inversion 和 global inversion 个数相同的话，必须满足： A[i] == i A[i] == i+1 &amp;&amp; A[i+1] == i 所以我们就可以写出这段代码： 12345678910bool isIdealPermutation(vector&lt;int&gt;&amp; A) &#123; int minLimit = INT_MIN; for(int i = 0, size = A.size() - 1; i &lt; size; i++) &#123; if (A[i] == i) ; else if (A[i] == i + 1 &amp;&amp; A[i+1] == i) &#123; i++; &#125; else return false; &#125; return true;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Insert into a binary search tree","slug":"Insert-into-a-binary-search-tree","date":"2019-12-01T10:41:18.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/12/01/Insert-into-a-binary-search-tree/","link":"","permalink":"http://blog.codeand.fun/2019/12/01/Insert-into-a-binary-search-tree/","excerpt":"","text":"第25天。 今天的题目是Insert into a binary search tree: 看名字就知道是水题，就是在BST中插入一个节点罢了，所以只需要递归查找到插入的位置，然后 new 一个 TreeNode即可： 12345678TreeNode* insertIntoBST(TreeNode* root, int val) &#123; if (root == nullptr) &#123; return new TreeNode(val); &#125; else if (root-&gt;val &gt; val) root-&gt;left = insertIntoBST(root-&gt;left, val); else if (root-&gt;val &lt; val) root-&gt;right = insertIntoBST(root-&gt;right, val); return root;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Shifting Letters","slug":"Shifting-Letters","date":"2019-11-30T15:05:17.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2019/11/30/Shifting-Letters/","link":"","permalink":"http://blog.codeand.fun/2019/11/30/Shifting-Letters/","excerpt":"","text":"第25天。我决定以后不贴题目了。 今天的题目是Shifting Letters。 混进 Medium 的 Easy 题目，简单的取模和循环就能解决的问题。 代码如下： 123456789string shiftingLetters(string S, vector&lt;int&gt;&amp; shifts) &#123; int temp = 0; for(int i = shifts.size() - 1 ; i &gt;= 0; --i) &#123; temp = (shifts[i] + temp) % 26; S[i] = ((S[i] - 'a') + temp) % 26 + 'a'; // cout &lt;&lt; shifts[i] &lt;&lt; endl; &#125; return S;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Delete Node in a BST","slug":"Delete-Node-in-a-BST","date":"2019-11-28T10:06:14.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/11/28/Delete-Node-in-a-BST/","link":"","permalink":"http://blog.codeand.fun/2019/11/28/Delete-Node-in-a-BST/","excerpt":"","text":"第24天。 今天的题目是 Delete Node in a BST : Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST. Basically, the deletion can be divided into two stages: Search for a node to remove. If the node is found, delete the node. Note: Time complexity should be O(height of tree). Example: 1234567891011121314151617181920212223242526root &#x3D; [5,3,6,2,4,null,7]key &#x3D; 3 5 &#x2F; \\ 3 6 &#x2F; \\ \\2 4 7Given key to delete is 3. So we find the node with value 3 and delete it.One valid answer is [5,4,6,2,null,null,7], shown in the following BST. 5 &#x2F; \\ 4 6 &#x2F; \\2 7Another valid answer is [5,2,6,null,4,null,7]. 5 &#x2F; \\ 2 6 \\ \\ 4 7 水题，只要先在BST上做搜索，然后删除就好了，因为只是BST，所以可以不考虑平衡的问题： left和right都为空：直接删除，返回nullptr即可 left和right都不为空：默认采用把右子树的节点拉上来的方式，即把左子树插入到右子树中，然后再返回right即可。 left和right有一个不为空，则返回不为空的子树即可。 则代码如下： 123456789101112131415161718192021222324TreeNode* deleteNode(TreeNode *node) &#123; auto left = node-&gt;left, right = node-&gt;right; delete node; if (left &amp;&amp; right) &#123; auto temp = right; while(temp-&gt;left) &#123; temp = temp-&gt;left; &#125; temp-&gt;left = left; return right; &#125; return (left ? left : (right ? right : nullptr));&#125;TreeNode* deleteNode(TreeNode* root, int key) &#123; if (root == nullptr) return nullptr; else if (root-&gt;val == key) &#123; return deleteNode(root); &#125; else if (key &gt; root-&gt;val) &#123; root-&gt;right = deleteNode(root-&gt;right, key); &#125; else root-&gt;left = deleteNode(root-&gt;left, key); return root;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Longest Common Subsequence","slug":"Longest-Common-Subsequence","date":"2019-11-27T22:57:33.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/11/27/Longest-Common-Subsequence/","link":"","permalink":"http://blog.codeand.fun/2019/11/27/Longest-Common-Subsequence/","excerpt":"","text":"第23天。 今天的题目是 Longest Common Subsequence : Given two strings text1 and text2, return the length of their longest common subsequence. A subsequence of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, “ace” is a subsequence of “abcde” while “aec” is not). A common subsequence of two strings is a subsequence that is common to both strings. If there is no common subsequence, return 0. Example 1: 123Input: text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; Output: 3 Explanation: The longest common subsequence is &quot;ace&quot; and its length is 3. Example 2: 123Input: text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;abc&quot;Output: 3Explanation: The longest common subsequence is &quot;abc&quot; and its length is 3. Example 3: 123Input: text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;def&quot;Output: 0Explanation: There is no such common subsequence, so the result is 0. Constraints: 1 &lt;= text1.length &lt;= 1000 1 &lt;= text2.length &lt;= 1000 The input strings consist of lowercase English characters only. 这是一道比较经典的动态规划问题吧，它的动规方程为：$$\\begin{equation}LCS(i,j) = \\left{\\begin{array}{rcl} &amp; LCS[i-1, j-1] + 1 &amp; ,{s1[i] = s2[j]} \\&amp; max(LCS[i, j-1], LCS[i-1, j]) &amp; ,{s1[i] \\neq s2[j]} \\end{array}\\right.\\end{equation}$$根据动规方程我们可以写出如下代码： 12345678910111213int longestCommonSubsequence(string text1, string text2) &#123; vector&lt;vector&lt;int&gt;&gt; dp(text1.size() + 1, vector&lt;int&gt;(text2.size() + 1, 0)); for(int i = 1;i &lt; dp.size(); i++) &#123; for(int j = 1;j &lt; dp[0].size(); j++) &#123; if (text1[i-1] == text2[j-1]) &#123; dp[i][j] = dp[i-1][j-1] + 1; &#125; else &#123; dp[i][j] = max(dp[i-1][j], dp[i][j-1]); &#125; &#125; &#125; return dp[text1.size()][text2.size()];&#125; 这里的空间复杂度可以继续进行优化，因为LCS[i,j]只与当前行和上一行有关系，所以可以优化成两个数组来做： 12345678910111213141516171819int longestCommonSubsequence(string text1, string text2) &#123; int n = text1.size() + 1, m = text2.size() + 1; vector&lt;int&gt; dp1(m, 0); vector&lt;int&gt; dp2(m); for(int i = 1;i &lt; n; i++) &#123; dp1[0] = 0; for(int j = 1;j &lt; m; j++) &#123; if (text1[i-1] == text2[j-1]) &#123; dp2[j] = dp1[j-1] + 1; &#125; else &#123; dp2[j] = max(dp1[j], dp2[j-1]); &#125; &#125; swap(dp1, dp2); &#125; return dp1[m-1];&#125; 再进一步的话，我们可以发现dp[i][j]只与 dp[i-1][j-1]，dp[i-1][j]，dp[i][j-1] 相关，如果我们只用一个数组的话，dp[i][j]与dp[i-1][j]其实存在同一个位置，而dp[i][j-1]是在同一行，所以我们只需要维护一个prev变量来保存dp[i-1][j-1]的值即可： 1234567891011121314int longestCommonSubsequence(string text1, string text2) &#123; int n = text1.size(), m = text2.size() + 1; vector&lt;int&gt; dp(m, 0); for(int i = 0;i &lt; n; i++) &#123; int prev = 0; for(int j = 1;j &lt; m; j++) &#123; int temp = prev; prev = dp[j]; dp[j] = (text1[i] == text2[j-1]) ? (temp + 1) : (max(dp[j], dp[j-1])); &#125; &#125; return dp[m-1];&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Possible Bipartition","slug":"Possible-Bipartition","date":"2019-11-26T16:13:42.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/11/26/Possible-Bipartition/","link":"","permalink":"http://blog.codeand.fun/2019/11/26/Possible-Bipartition/","excerpt":"","text":"第22天 今天的题目是 Possible Bipartition ： Given a set of N people (numbered 1, 2, ..., N), we would like to split everyone into two groups of any size. Each person may dislike some other people, and they should not go into the same group. Formally, if dislikes[i] = [a, b], it means it is not allowed to put the people numbered a and b into the same group. Return true if and only if it is possible to split everyone into two groups in this way. Example 1: 123Input: N &#x3D; 4, dislikes &#x3D; [[1,2],[1,3],[2,4]]Output: trueExplanation: group1 [1,4], group2 [2,3] Example 2: 12Input: N &#x3D; 3, dislikes &#x3D; [[1,2],[1,3],[2,3]]Output: false Example 3: 12Input: N &#x3D; 5, dislikes &#x3D; [[1,2],[2,3],[3,4],[4,5],[1,5]]Output: false Note: 1 &lt;= N &lt;= 2000 0 &lt;= dislikes.length &lt;= 10000 1 &lt;= dislikes[i][j] &lt;= N dislikes[i][0] &lt; dislikes[i][1] There does not exist i != j for which dislikes[i] == dislikes[j]. 又是一道图的题目，而且和昨天的题目思路是一样的，先遍历染色，然后再判断是否满足即可。 这里有些不同的是，这道题给出的输入是边的列表，然后我们需要手动建个图。同时，这道题还可以用在遍历时判断是否已经不符合了，进而可以提前退出。代码如下： 12345678910111213141516171819202122232425262728bool possibleBipartition(int N, vector&lt;vector&lt;int&gt;&gt;&amp; dislikes) &#123; vector&lt;vector&lt;int&gt;&gt; graph(N); for(int i = 0;i &lt; dislikes.size(); i++) &#123; graph[dislikes[i][0]-1].push_back(dislikes[i][1]-1); graph[dislikes[i][1]-1].push_back(dislikes[i][0]-1); &#125; char color = 'b'; vector&lt;char&gt; visited(N, 'w'); for(int i = 0;i &lt; N;i++) &#123; if (visited[i] == 'w' &amp;&amp; dfs(graph, visited ,i, color) == false) &#123; return false; &#125; &#125; return true;&#125;bool dfs(vector&lt;vector&lt;int&gt;&gt; &amp;graph, vector&lt;char&gt; &amp;visited, int index, char color) &#123; visited[index] = color; for(int i = 0;i &lt; graph[index].size(); i++) &#123; int j = graph[index][i]; if ((visited[j] == 'w' &amp;&amp; !dfs(graph, visited, j, ~color)) || visited[j] == color)&#123; return false; &#125; &#125; return true;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Is Graph Bipartite?","slug":"Is-Graph-Bipartite","date":"2019-11-25T10:20:49.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/11/25/Is-Graph-Bipartite/","link":"","permalink":"http://blog.codeand.fun/2019/11/25/Is-Graph-Bipartite/","excerpt":"","text":"第21天。 今天的题目是 Is Graph Bipartite? ： Given an undirected graph, return true if and only if it is bipartite. Recall that a graph is bipartite if we can split it’s set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B. The graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists. Each node is an integer between 0 and graph.length - 1. There are no self edges or parallel edges: graph[i] does not contain i, and it doesn’t contain any element twice. 1234567891011121314151617181920Example 1:Input: [[1,3], [0,2], [1,3], [0,2]]Output: trueExplanation: The graph looks like this:0----1| || |3----2We can divide the vertices into two groups: &#123;0, 2&#125; and &#123;1, 3&#125;.Example 2:Input: [[1,2,3], [0,2], [0,1,3], [0,2]]Output: falseExplanation: The graph looks like this:0----1| \\ || \\ |3----2We cannot find a way to divide the set of nodes into two independent subsets. Note: graph will have length in range [1, 100]. graph[i] will contain integers in range [0, graph.length - 1]. graph[i] will not contain i or duplicate values. The graph is undirected: if any element j is in graph[i], then i will be in graph[j]. 这是一道关于图的问题，题目的意思很简单，就是要判断一个图是不是一个二部图，所谓的二部图，就是一个图可以把所有节点划分到两个不相交的两个集合，这两个集合内部没有边相连。 我们可以对图进行一次遍历，遍历的时候对节点进行着色，着色的规律是这样的，当从一个节点跳到另一个节点的时候，我们就切换一次颜色（共有三种颜色，其中一种表示没有访问，即白色）。因为遍历完了之后，整个图的节点就被划分成两部分了，接下来我们只需要判断所有节点的邻居是否和它是不同色的即可。代码如下： 123456789101112131415161718192021222324252627282930char color;bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123; int size = graph.size(); vector&lt;char&gt; flags(size, 'w'); // w g b color = 'b'; for(int i = 0;i &lt; size;i++) &#123; if (flags[i] == 'w') &#123; dfs(graph, flags, i); &#125; &#125; for(int i = 0;i &lt; size;i++) &#123; for(auto j: graph[i]) &#123; if (flags[i] == flags[j]) return false; &#125; &#125; return true;&#125;void dfs(vector&lt;vector&lt;int&gt;&gt; &amp;graph, vector&lt;char&gt; &amp;flags, int index) &#123; flags[index] = color; for(auto j: graph[index]) &#123; if (flags[j] == 'w') &#123; color = ~color; dfs(graph, flags, j); color = ~color; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Minimum Moves to Equal Array Elements II","slug":"Minimum-Moves-to-Equal-Array-Elements-II","date":"2019-11-24T10:53:34.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/11/24/Minimum-Moves-to-Equal-Array-Elements-II/","link":"","permalink":"http://blog.codeand.fun/2019/11/24/Minimum-Moves-to-Equal-Array-Elements-II/","excerpt":"","text":"第20天。 今天的题目是 Minimum Moves to Equal Array Elements II ： Given a non-empty integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1. You may assume the array’s length is at most 10,000. Example: 12345678910Input:[1,2,3]Output:2Explanation:Only two moves are needed (remember each move increments or decrements one element):[1,2,3] &#x3D;&gt; [2,2,3] &#x3D;&gt; [2,2,2] 这道题需要一些数学推导，它的目标就是： $$min_k { \\sum_{i=1}^n |n_i - n_k| }$$其中 $n_i$ 表示数组排序后中第 $i$ 个元素。 我们将式子展开可以得到：$$min_k { \\sum_{i=1}^n |n_i - n_k| } = min_k { \\sum_{i=1}^k (n_k-n_i) + \\sum_{i=k+1}^n(n_i-n_k) } \\ = min_k { \\sum_{i=1}^k n_k - \\sum_{i=1}^k n_i + \\sum_{i=k+1}^n n_i - \\sum_{i=k+1}^n n_k } \\ = min_k { \\sum_{i=k+1}^n n_i - \\sum_{i=1}^k n_i + (2k - n)n_k }$$因此，我们可以写出如下代码： 1234567891011121314151617int minMoves2(vector&lt;int&gt;&amp; nums) &#123; long long res = LONG_MAX; sort(nums.begin(), nums.end()); long long rightSum = 0; for(auto i: nums) rightSum += i; long long leftSum = 0; int n = nums.size(); for(int i = 0;i &lt; n; ++i) &#123; res = min(res, rightSum - leftSum + (2*i - n) * (long long)nums[i]); rightSum -= nums[i]; leftSum += nums[i]; // cout &lt;&lt; res &lt;&lt; endl; &#125; return res;&#125; 这样还不是最优解，然而最优解我没看懂（捂脸），为什么用中位数求就是对的呢？： 123456789101112131415161718192021222324252627int minMoves2(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); int mid; if (nums.size() % 2 == 0)&#123; mid = (nums[nums.size()/2] + nums[(nums.size()/2) - 1])/2; &#125;else&#123; mid = nums[nums.size()/2]; &#125; int result = 0; for (int i = 0; i &lt; nums.size(); i++)&#123; result += abs(nums[i] - mid); &#125; return result; &#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"N-ary Tree Level Order Traversal","slug":"N-ary-Tree-Level-Order-Traversal","date":"2019-11-23T10:09:08.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/11/23/N-ary-Tree-Level-Order-Traversal/","link":"","permalink":"http://blog.codeand.fun/2019/11/23/N-ary-Tree-Level-Order-Traversal/","excerpt":"","text":"第19天。 今天的题目是 N-ary Tree Level Order Traversal : Given an n-ary tree, return the level order traversal of its nodes’ values. Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples). Example 1: 12Input: root &#x3D; [1,null,3,2,4,null,5,6]Output: [[1],[3,2,4],[5,6]] Example 2: 12Input: root &#x3D; [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]Output: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]] Constraints: The height of the n-ary tree is less than or equal to 1000 The total number of nodes is between [0, 10^4] 一道水题，简单的BFS或DFS即可，除了是一个多叉树外，和另外一道题基本是一样的。 123456789101112class Node &#123;public: int val; vector&lt;Node*&gt; children; Node() &#123;&#125; Node(int _val, vector&lt;Node*&gt; _children) &#123; val = _val; children = _children; &#125;&#125;; 所以，我们既可以用队列去做层次遍历(BFS)，也可以用递归来实现DFS，然后按当前节点所在的高度插入到对于的数组即可： DFS 12345678910111213vector&lt;vector&lt;int&gt;&gt; res;vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) &#123; dfsWithHeight(root, 0); return res;&#125;void dfsWithHeight(Node *root, int h) &#123; if (root == nullptr) return; if (h == res.size()) res.push_back(vector&lt;int&gt;()); res[h].push_back(root-&gt;val); for(int i = 0;i &lt; root-&gt;children.size(); i++) &#123; dfsWithHeight(root-&gt;children[i], h + 1); &#125;&#125; BFS 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152vector&lt;vector&lt;int&gt;&gt; levelOrder2(Node* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if (root == nullptr) &#123; return res; &#125; vector&lt;int&gt; vec; queue&lt;Node *&gt; q; q.push(root); q.push(nullptr); while(q.size() != 1) &#123; vec.clear(); root = q.front(); while(root) &#123; q.pop(); vec.push_back(root-&gt;val); // cout &lt;&lt; root-&gt;val &lt;&lt; endl; for(int i = 0;i &lt; root-&gt;children.size(); i++) &#123; q.push(root-&gt;children[i]); &#125; root = q.front(); &#125; q.pop(); q.push(nullptr); res.push_back(vec); &#125; return res;&#125;vector&lt;vector&lt;int&gt;&gt; levelOrder1(Node* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if (root == nullptr) &#123; return res; &#125; vector&lt;int&gt; vec; vector&lt;Node *&gt; nodes; vector&lt;Node *&gt; nextLevelNodes; nodes.push_back(root); while(!nodes.empty()) &#123; vec.clear(); nextLevelNodes.clear(); for(int i = 0;i &lt; nodes.size(); i++) &#123; vec.push_back(nodes[i]-&gt;val); for(int j = 0;j &lt; nodes[i]-&gt;children.size(); j++) &#123; nextLevelNodes.push_back(nodes[i]-&gt;children[j]); &#125; &#125; swap(nodes, nextLevelNodes); res.push_back(vec); &#125; return res;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"All Possible Full Binary Trees","slug":"All-Possible-Full-Binary-Trees","date":"2019-11-22T13:54:54.000Z","updated":"2020-04-02T14:43:48.831Z","comments":true,"path":"2019/11/22/All-Possible-Full-Binary-Trees/","link":"","permalink":"http://blog.codeand.fun/2019/11/22/All-Possible-Full-Binary-Trees/","excerpt":"","text":"第18天。 今天的题目是 All Possible Full Binary Trees : A full binary tree is a binary tree where each node has exactly 0 or 2 children. Return a list of all possible full binary trees with N nodes. Each element of the answer is the root node of one possible tree. Each node of each tree in the answer must have node.val = 0. You may return the final list of trees in any order. Example 1: 123Input: 7Output: [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]Explanation: Note: 1 &lt;= N &lt;= 20 这道题就是一个穷举的问题，我们知道完全二叉树的节点个数一定是奇数，所以可以先把N为偶数的输入先处理掉，然后就是怎么穷举的问题了。显然，一个完全二叉树的子树一定也是完全二叉树，所以我们可以以1,3,5...,N-2的方式穷举出出左子树中节点的个数i，已知左子树节点个数，那么右子树节点的个数就为N-i-1,我们先把左子树和右子树的可能都算出来，然后就再计算它们两两组合的所有可能即可得到所有节点个数为N的完全二叉树的情况。总的来说，就是一个大问题化简成小问题的思路。所以我们可以写出如下代码： 1234567891011121314151617181920212223242526272829303132TreeNode *copyTree(TreeNode *root) &#123; if (root == nullptr) return nullptr; TreeNode *res = new TreeNode(0); res-&gt;left = copyTree(root-&gt;left); res-&gt;right = copyTree(root-&gt;right); return res;&#125;vector&lt;TreeNode*&gt; allPossibleFBT(int N) &#123; vector&lt;TreeNode*&gt; res; if (N % 2 == 0) return res; vector&lt;vector&lt;TreeNode*&gt;&gt; dp(N+1); dp[1].push_back(new TreeNode(0)); for(int i = 1;i &lt; dp.size();i+=2) &#123; // dp[i]; for(int j = 1;j &lt; i;j+=2) &#123; vector&lt;TreeNode*&gt; &amp;left = dp[j]; vector&lt;TreeNode*&gt; &amp;right = dp[(i-j-1)]; for(auto &amp;l: left) &#123; for(auto &amp;r: right) &#123; TreeNode *node = new TreeNode(0); node-&gt;left = copyTree(l); node-&gt;right = copyTree(r); dp[i].push_back(node); &#125; &#125; &#125; &#125; return dp[N];&#125; 然后你会发现好像可以用一个数组来存在已经求解出来的结果，如果再一次求，我们可以直接返回了： 1234567891011121314151617181920212223242526vector&lt;TreeNode*&gt; &amp;allPossibleFBT(int N, vector&lt;vector&lt;TreeNode*&gt;&gt; &amp;cache) &#123; if (cache[N].size() != 0) return cache[N]; for(int i = 1;i &lt; N;i++) &#123; vector&lt;TreeNode*&gt; &amp;left = allPossibleFBT(i, cache); vector&lt;TreeNode*&gt; &amp;right = allPossibleFBT(N - i - 1, cache); for(auto l: left) &#123; for(auto r: right) &#123; TreeNode *node = new TreeNode(0); node-&gt;left = l; node-&gt;right = r; cache[N].push_back(node); &#125; &#125; &#125; return cache[N];&#125;vector&lt;TreeNode*&gt; allPossibleFBT(int N) &#123; vector&lt;TreeNode*&gt; res; if (N % 2 == 0) return &#123;&#125;; vector&lt;vector&lt;TreeNode*&gt;&gt; cache(21); cache[1].push_back(new TreeNode(0)); return allPossibleFBT(N, cache);&#125; 如果熟悉动态规划的话，就会发现可以自顶向下的求解方式转成自底向上的求解方式，这里我们就不需要用递归去求解： 12345678910111213141516171819202122vector&lt;TreeNode*&gt; allPossibleFBT(int N) &#123; vector&lt;TreeNode*&gt; res; if (N % 2 == 0) return res; vector&lt;vector&lt;TreeNode*&gt;&gt; dp(N+1); dp[1].push_back(new TreeNode(0)); for(int i = 1;i &lt; dp.size();i+=2) &#123; // dp[i]; for(int j = 1;j &lt; i;j+=2) &#123; for(auto l: dp[j]) &#123; for(auto r: dp[i-j-1]) &#123; TreeNode *node = new TreeNode(0); node-&gt;left = copyTree(l); node-&gt;right = copyTree(r); dp[i].push_back(node); &#125; &#125; &#125; &#125; return dp[N];&#125; 最后，这份代码在LeetCode大概只能超过50%，如果要进一步，只有把copyTree去掉，直接赋值。这种方式是可行的，但是感觉只是在刷题时的一种技巧而已： 12345678910111213141516171819202122vector&lt;TreeNode*&gt; allPossibleFBT(int N) &#123; vector&lt;TreeNode*&gt; res; if (N % 2 == 0) return res; vector&lt;vector&lt;TreeNode*&gt;&gt; dp(N+1); dp[1].push_back(new TreeNode(0)); for(int i = 1;i &lt; dp.size();i+=2) &#123; // dp[i]; for(int j = 1;j &lt; i;j+=2) &#123; for(auto l: dp[j]) &#123; for(auto r: dp[i-j-1]) &#123; TreeNode *node = new TreeNode(0); node-&gt;left = l;//copyTree(l); node-&gt;right = r;//copyTree(r); dp[i].push_back(node); &#125; &#125; &#125; &#125; return dp[N];&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Kth Smallest Element in a BST","slug":"Kth-Smallest-Element-in-a-BST","date":"2019-11-21T09:28:38.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/11/21/Kth-Smallest-Element-in-a-BST/","link":"","permalink":"http://blog.codeand.fun/2019/11/21/Kth-Smallest-Element-in-a-BST/","excerpt":"","text":"第17天，又是一道之前没做出来的题目，然而好像并不难啊。 今天的题目是 Kth Smallest Element in a BST : Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. Note:You may assume k is always valid, 1 ≤ k ≤ BST’s total elements. Example 1: 1234567Input: root &#x3D; [3,1,4,null,2], k &#x3D; 1 3 &#x2F; \\ 1 4 \\ 2Output: 1 Example 2: 123456789Input: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3 5 &#x2F; \\ 3 6 &#x2F; \\ 2 4 &#x2F; 1Output: 3 Follow up:What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine? 题意很简单就是求BST中第k小的数字，然后BST本身就包含一定的顺序信息，利用BST中序遍历是有序的性质，我们可以很快的把这道题写出来： 123456789101112131415161718int res;int kthSmallest(TreeNode* root, int k) &#123; res = 0; kthSmallestR(root, k); return res;&#125;bool kthSmallestR(TreeNode *root, int &amp;k) &#123; // cout &lt;&lt; root &lt;&lt; endl; if (root == nullptr) return false; if (kthSmallestR(root-&gt;left, k)) return true; // cout &lt;&lt; root-&gt;val &lt;&lt; endl; if ((--k) == 0) &#123; res = root-&gt;val; return true; &#125; return kthSmallestR(root-&gt;right, k);&#125; 然后我们可以写出非递归版本的： 123456789101112131415161718int kthSmallest(TreeNode* root, int k) &#123; stack&lt;TreeNode *&gt; st; while(root || !st.empty()) &#123; while(root) &#123; st.push(root); root = root-&gt;left; &#125; if (st.empty()) break; root = st.top(); st.pop(); if (--k == 0) break; root = root-&gt;right; &#125; if(root) return root-&gt;val; else return -1;&#125; BTW，这道题的测试有点不稳定，同一个代码会测试出不同的时间。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Triangle","slug":"Triangle","date":"2019-11-20T12:15:06.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2019/11/20/Triangle/","link":"","permalink":"http://blog.codeand.fun/2019/11/20/Triangle/","excerpt":"","text":"第16天。 今天的题目是 Triangle ： Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example, given the following triangle 123456[ [2], [3,4], [6,5,7], [4,1,8,3]] The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note: Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle. 一道很常规的动态规划问题。 虽然例子中画出来的数组看起来很难确定路径，但是如果把它规整一下就可以得到： 123423 46 5 74 1 8 3 因此对于位置(i,j)来说，到达它的路径一定经过上一层的(i-1, j)和(i-1,j-1)（注意其实triangle中必须保证0&lt;=j&lt;=i，那个位置才会有值)。 所以我们可以写出动态规划方程： $$dp[i, j]=min{dp[i-1, j], dp[i-1, j-1] } + triangle[i][j]$$ 其中dp[i,j]表示从顶端出发到达第i层第j个位置的最短路径的距离。其中dp[0,0]=triangle[0]以及dp[i,j]=INT_MAX,i&lt;j，根据动态规划方程我们可以很容易的写出代码，同时为了使得空间复杂度为O(n)，我们可以只使用一个长度为n的数组来保存，之所以能做到是因为d[i, *]只依赖于d[i-1, *]，进一步的说，它只依赖于d[i-1, *-1]和d[i-1, *]，所以可以很容易改成一个用一个一维数组实现： 1234567891011121314151617int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; int n = triangle.size(); if (n == 0) return 0; vector&lt;int&gt; dp(n, INT_MAX); dp[0] = triangle[0][0]; for(int i = 1;i &lt; n;i++) &#123; for(int j = i;j &gt;= 0;j--) &#123; dp[j] = min(dp[j], j&gt;0?dp[j-1]:INT_MAX) + triangle[i][j]; // cout &lt;&lt; dp[j] &lt;&lt; \" \"; &#125; // cout &lt;&lt; endl; &#125; int res = INT_MAX; for(int i = 0;i &lt; n;i++) res = min(res, dp[i]); return res;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Advantage Shuffle","slug":"Advantage-Shuffle","date":"2019-11-19T12:22:52.000Z","updated":"2020-04-02T14:43:48.831Z","comments":true,"path":"2019/11/19/Advantage-Shuffle/","link":"","permalink":"http://blog.codeand.fun/2019/11/19/Advantage-Shuffle/","excerpt":"","text":"第15天。emmm，这就半个月了？？ 今天的题目是 Advantage Shuffle : Given two arrays A and B of equal size, the advantage of A with respect to B is the number of indices i for which A[i] &gt; B[i]. Return any permutation of A that maximizes its advantage with respect to B. Example 1: 12Input: A &#x3D; [2,7,11,15], B &#x3D; [1,10,4,11]Output: [2,11,7,15] Example 2: 12Input: A &#x3D; [12,24,8,32], B &#x3D; [13,25,32,11]Output: [24,32,8,12] Note: 1 &lt;= A.length = B.length &lt;= 10000 0 &lt;= A[i] &lt;= 10^9 0 &lt;= B[i] &lt;= 10^9 这道题就是个贪心的思路，确保每个位置上，A[i]的值要么是A中第一个比B[i]大，要么是最小能用的值，这就涉及到了怎么找到第一个比B[i]大的值的问题了，我们可以二叉查找树来实现，这里用STL中的multiset即可： 123456789101112vector&lt;int&gt; advantageCount1(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123; multiset&lt;int&gt; S(A.begin(), A.end()); for(int i = 0;i &lt; B.size(); i++) &#123; auto it = S.upper_bound(B[i]); if (it == S.end()) &#123; it = S.begin(); &#125; A[i] = *it; S.erase(it); &#125; return A;&#125; 这个方法虽然可以AC，但是时间效率不高，所以我们可以用排序的方法来代替二叉查找树，我们按B从大到小的顺序来填A的值，这样如果A中当前能用的最大值比B[i]要大，那么A[i]为A中当前能用的最大值，否则为A中当前能用的最小值。 12345678910111213141516171819vector&lt;int&gt; advantageCount(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123; vector&lt;int&gt; res(A.size()); vector&lt;pair&lt;int, int&gt;&gt; val2index(A.size()); for(int i = 0;i &lt; val2index.size(); i++) val2index[i] = make_pair(B[i], i); sort(A.begin(), A.end()); sort(val2index.begin(), val2index.end()); int first = 0, last = A.size() - 1; for(int i = A.size() - 1;i &gt;= 0;i--) &#123; if (val2index[i].first &gt;= A[last]) &#123; res[val2index[i].second] = A[first++]; &#125; else &#123; res[val2index[i].second] = A[last--]; &#125; &#125; return res;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Delete Nodes And Return Forest","slug":"Delete-Nodes-And-Return-Forest","date":"2019-11-18T10:07:28.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/11/18/Delete-Nodes-And-Return-Forest/","link":"","permalink":"http://blog.codeand.fun/2019/11/18/Delete-Nodes-And-Return-Forest/","excerpt":"","text":"第14天。 今天的题目是Delete Nodes And Return Forest： Given the root of a binary tree, each node in the tree has a distinct value. After deleting all nodes with a value in to_delete, we are left with a forest (a disjoint union of trees). Return the roots of the trees in the remaining forest. You may return the result in any order. Example 1: 12Input: root &#x3D; [1,2,3,4,5,6,7], to_delete &#x3D; [3,5]Output: [[1,2,null,4],[6],[7]] Constraints: The number of nodes in the given tree is at most 1000. Each node has a distinct value between 1 and 1000. to_delete.length &lt;= 1000 to_delete contains distinct values between 1 and 1000. 这道题的题意很简单，就是要通过删节点来把分割树，关键的问题是，删除一个节点既需要对子节点进行处理，还要在父节点中删除对应的指针，为了方便，我们这里采用后续遍历的方法来实现： 先递归调用函数，使得子树中的节点已经完成遍历和删除，然后通过返回值来判断该子节点是否需要删除，如果需要删除，则将对于的指针置空。然后在判断当前节点是否需要删除，就将非空的子节点插入到返回数组中（全局变量）。 还有一点就是，因为节点的值在1-1000间，所以我们可以用一个长度为1000的数组来加快对要删除节点的判断。 代码如下： 123456789101112131415161718192021222324252627282930313233vector&lt;TreeNode *&gt; res;vector&lt;TreeNode*&gt; delNodes(TreeNode* root, vector&lt;int&gt;&amp; to_delete) &#123; if (root == nullptr) return res; vector&lt;bool&gt; delmap(1001, false); for(int i = 0;i &lt; to_delete.size(); i++) &#123; delmap[to_delete[i]] = true; &#125; if (!toDelNodes(root, delmap)) &#123; res.push_back(root); &#125; return res;&#125;bool toDelNodes(TreeNode *root, vector&lt;bool&gt;&amp; delmap) &#123; if (root == nullptr) return false; if (toDelNodes(root-&gt;left, delmap)) &#123; root-&gt;left = nullptr; &#125; if (toDelNodes(root-&gt;right, delmap)) &#123; root-&gt;right = nullptr; &#125; if (delmap[root-&gt;val]) &#123; if (root-&gt;left) res.push_back(root-&gt;left); if (root-&gt;right) res.push_back(root-&gt;right); return true; &#125; return false; &#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Boats to Save People","slug":"Boats-to-Save-People","date":"2019-11-17T10:24:21.000Z","updated":"2020-04-02T14:43:48.831Z","comments":true,"path":"2019/11/17/Boats-to-Save-People/","link":"","permalink":"http://blog.codeand.fun/2019/11/17/Boats-to-Save-People/","excerpt":"","text":"第13天。 今天的题目是 Boats to Save People : The i-th person has weight people[i], and each boat can carry a maximum weight of limit. Each boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most limit. Return the minimum number of boats to carry every given person. (It is guaranteed each person can be carried by a boat.) Example 1: 123Input: people &#x3D; [1,2], limit &#x3D; 3Output: 1Explanation: 1 boat (1, 2) Example 2: 123Input: people &#x3D; [3,2,2,1], limit &#x3D; 3Output: 3Explanation: 3 boats (1, 2), (2) and (3) Example 3: 123Input: people &#x3D; [3,5,3,4], limit &#x3D; 5Output: 4Explanation: 4 boats (3), (3), (4), (5) Note: 1 &lt;= people.length &lt;= 50000 1 &lt;= people[i] &lt;= limit &lt;= 30000 一道贪心的题目，仔细分析下题目就会发现，如果一个weight比较大的人要坐船，一定是和weight小的人坐船，才能保证做的船数最少。因此，只要先排序，然后在双指针判断是否能做两个人即可： 123456789101112131415int numRescueBoats1(vector&lt;int&gt;&amp; people, int limit) &#123; sort(people.begin(), people.end()); int res = 0; int i = 0, j = people.size() -1; while(i &lt;= j) &#123; res += 1; if (limit &gt;= people[i] + people[j]) &#123; i++; &#125; j--; &#125; return res;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Diagonal Traverse","slug":"Diagonal-Traverse","date":"2019-11-16T10:16:52.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/11/16/Diagonal-Traverse/","link":"","permalink":"http://blog.codeand.fun/2019/11/16/Diagonal-Traverse/","excerpt":"","text":"第12天。 今天的题目是Diagonal Traverse： Given a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image. Example: 12345678910Input:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]Output: [1,2,4,7,5,3,6,8,9]Explanation: Note: The total number of elements of the given matrix will not exceed 10,000. 这道题好像是之前没做出来的。 题意很好理解，这道题的关键就在于如何处理在边界时的移动。 首先，常规的移动就分为两种： 向右上移动 向左下移动 实现常规移动，这里就不赘述了。 然后就是在边界时如何移动了，经过观察移动的情况，我们可以总结出： 边界时，只有向右移动和向下移动两种情况 在向右上移动时遇到边界，优先向右移动 在向左下移动时遇到边界，优先向左移动 根据上面的结论，我们就可以写出代码了： 12345678910111213141516171819202122232425262728293031323334353637383940bool nextRightUp(int &amp;i, int &amp;j, int &amp;m, int &amp;n) &#123; if (i - 1 &gt;= 0 &amp;&amp; j + 1 &lt; n) &#123; // move right up i--; j++; return true; &#125; else if (j + 1 &lt; n) &#123; // move right j++; return false; &#125; else if (i + 1 &lt; m)&#123; // move down i++; return false; &#125; return false; // mean in the last elem&#125;bool nextLeftDown(int &amp;i, int &amp;j, int &amp;m, int &amp;n) &#123; if (i + 1 &lt; m &amp;&amp; j -1 &gt;= 0) &#123; // move right up i++; j--; return true; &#125; else if (i + 1 &lt; m) &#123; // move down i++; return false; &#125; else if (j + 1 &lt; n) &#123; // move right j++; return false; &#125; return false; &#125;vector&lt;int&gt; findDiagonalOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int m = matrix.size(); vector&lt;int&gt; res; if (m == 0) return res; int n = matrix[0].size(); int i = 0, j = 0; bool up = true; for(int k = 0;k &lt; m*n;k++) &#123; res.push_back(matrix[i][j]); if (up) &#123; up = nextRightUp(i, j, m, n); &#125; else &#123; up = !nextLeftDown(i, j, m, n); &#125; &#125; return res;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Keys and Rooms","slug":"Keys-and-Rooms","date":"2019-11-15T20:42:32.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/11/15/Keys-and-Rooms/","link":"","permalink":"http://blog.codeand.fun/2019/11/15/Keys-and-Rooms/","excerpt":"","text":"第11天。 今天的题目是Keys and Rooms： There are N rooms and you start in room 0. Each room has a distinct number in 0, 1, 2, ..., N-1, and each room may have some keys to access the next room. Formally, each room i has a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1, ..., N-1] where N = rooms.length. A key rooms[i][j] = v opens the room with number v. Initially, all the rooms start locked (except for room 0). You can walk back and forth between rooms freely. Return true if and only if you can enter every room. Example 1: 1234567Input: [[1],[2],[3],[]]Output: trueExplanation: We start in room 0, and pick up key 1.We then go to room 1, and pick up key 2.We then go to room 2, and pick up key 3.We then go to room 3. Since we were able to go to every room, we return true. Example 2: 123Input: [[1,3],[3,0,1],[2],[0]]Output: falseExplanation: We can&#39;t enter the room with number 2. Note: 1 &lt;= rooms.length &lt;= 1000 0 &lt;= rooms[i].length &lt;= 1000 The number of keys in all rooms combined is at most 3000. 很简单的一道题，仔细分析一下题目的话，就会发现这个输入其实构成一张图，rooms[i]表示从第i个节点出发走向的节点列表。然后这个问题就转变成，从0号节点出发，能不能遍历完所有节点的问题了，这个问题直接无脑dfs就好了，实现代码如下： 12345678910111213141516171819bool canVisitAllRooms(vector&lt;vector&lt;int&gt;&gt;&amp; rooms) &#123; vector&lt;bool&gt; visited(rooms.size(), false); dfs(rooms, visited, 0); for(int i = 0;i &lt; visited.size(); ++i) &#123; if (visited[i] == false) &#123; return false; &#125; &#125; return true;&#125;void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; rooms, vector&lt;bool&gt; &amp;visited, int index = 0) &#123; visited[index] = true; for(int i = 0;i &lt; rooms[index].size(); ++i) &#123; if (visited[rooms[index][i]] == false) &#123; dfs(rooms, visited, rooms[index][i]); &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Populating Next Right Pointers in Each Node II","slug":"Populating-Next-Right-Pointers-in-Each-Node-II","date":"2019-11-14T22:53:14.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/11/14/Populating-Next-Right-Pointers-in-Each-Node-II/","link":"","permalink":"http://blog.codeand.fun/2019/11/14/Populating-Next-Right-Pointers-in-Each-Node-II/","excerpt":"","text":"第10天了。 今天的题目是 117. Populating Next Right Pointers in Each Node II ： Given a binary tree 123456struct Node &#123; int val; Node *left; Node *right; Node *next;&#125; Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Example: 12345Input: &#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;val&quot;:3&#125;,&quot;val&quot;:1&#125;Output: &#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;5&quot;&#125;,&quot;val&quot;:3&#125;,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;4&quot;&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;6&quot;&#125;,&quot;val&quot;:1&#125;Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. Note: You may only use constant extra space. Recursive approach is fine, implicit stack space does not count as extra space for this problem. 这是一道之前没做出来的问题，最开始想出来的解法也和之前差不多，大概的想法是递归求解时返回子树的最左和最右节点，然后通过一些判断来相连，但是这个问题主要是没法处理两个子树高度不一样的问题。 后面尝试用分治的方法来做，主要的想法是，假设我现在已经有了连接好的左子树和右子树，现在只需要将两个子树连接起来即可。而连接方法就是一层一层的去连接两个子树： 1234567891011121314151617181920212223242526272829303132Node *nextLayer(Node *root) &#123; while(root) &#123; if (root-&gt;left) return root-&gt;left; if (root-&gt;right) return root-&gt;right; root = root-&gt;next; &#125; return nullptr;&#125;void connectLeftRight(Node *left, Node *right) &#123; // level 1 Node *pl, *pr; while(left &amp;&amp; right) &#123; pl = left; pr = right; // next layer left = nextLayer(left); right = nextLayer(right); // connect left and right tree in this layer while(pl-&gt;next) pl = pl-&gt;next; pl-&gt;next = pr; &#125;&#125;Node* connect1(Node* root) &#123; if (root == nullptr) return nullptr; Node *left = connect1(root-&gt;left); Node *right = connect1(root-&gt;right); connectLeftRight(left, right); return root;&#125; 这个方法的时间复杂度大概是O(h^2)，其中h是树的高度。 后面又发现一种方法，这种方法大概的思路是连接孩子，然后在递归求解。这样会保证在求解到root节点时，root节点的next是已知的，同时在连接孩子时，需要利用到右子树的next指针，所以需要先求解右子树再求解左子树。 12345678910111213141516171819202122232425262728void connectChild(Node *root) &#123; if (root == nullptr) return; if (root-&gt;left) &#123; if (root-&gt;right) root-&gt;left-&gt;next = root-&gt;right; else root-&gt;left-&gt;next = helper(root-&gt;next); &#125; if (root-&gt;right) &#123; root-&gt;right-&gt;next = helper(root-&gt;next); &#125;&#125;Node *helper(Node *root) &#123; if (root == nullptr) return nullptr; else if (root-&gt;left) return root-&gt;left; else if (root-&gt;right) return root-&gt;right; else return helper(root-&gt;next);&#125;Node* connect2(Node* root) &#123; if (root ==nullptr) return nullptr; connectChild(root); // 先求右边的。 connect2(root-&gt;right); connect3(root-&gt;left); return root;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Next Greater Element III","slug":"Next-Greater-Element-III","date":"2019-11-13T22:47:20.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/11/13/Next-Greater-Element-III/","link":"","permalink":"http://blog.codeand.fun/2019/11/13/Next-Greater-Element-III/","excerpt":"","text":"第9天了。 今天的题目是 Next Greater Element III : Given a positive 32-bit integer n, you need to find the smallest 32-bit integer which has exactly the same digits existing in the integer n and is greater in value than n. If no such positive 32-bit integer exists, you need to return -1. Example 1: 12Input: 12Output: 21 Example 2: 12Input: 21Output: -1 这道题我的解法是： 先将数字转换成数组，由于是除法和取余解析出来的数组，所以整个数组是倒过来的，即123得到[3,2,1] 从前向后遍历找到第一个逆序（即vec[i-1] &gt; vec[i)的情况。 从vec[0: i]找到第一个小于等于vec[i]的元素vec[j]。 交换vec[i]和vec[j]，然后将vec[0: i]逆序。 将vec转换回数字，最后判断一下是否溢出即可。 12345678910111213141516171819202122232425262728int nextGreaterElement(int n) &#123; long res = 0; vector&lt;int&gt; vec; while(n) &#123; vec.push_back(n % 10); n /= 10; &#125; int i, j; for(i = 1;i &lt; vec.size() &amp;&amp; vec[i-1] &lt;= vec[i] ;++i) &#123; &#125; if (i == vec.size()) return -1; for(j = 0;vec[i] &gt;= vec[j];++j) &#123; &#125; swap(vec[i], vec[j]); for(j = 0, i = i - 1; j &lt; i; j++, i--) &#123; swap(vec[i], vec[j]); &#125; for(i = vec.size() -1;i &gt;= 0; i--) &#123; res = res * 10 + vec[i]; &#125; if (res &gt; INT_MAX) return -1; return res;&#125; 其实写到这里基本上发现，这道题就是找全排列中的下一个元素，而这个功能，在C++中提供了一个好用的函数：next_permutation，所以我们可以先用to_string转换成字符数组，然后用next_permutation来解这道题： 123456789int nextGreaterElement(int n) &#123; string s = to_string(n); if (next_permutation(s.begin(), s.end())) &#123; long temp = atol(s.c_str()); if (temp &lt;= INT_MAX) return temp; else return -1; &#125; return -1;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Replace Words","slug":"Replace-Words","date":"2019-11-12T13:35:18.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2019/11/12/Replace-Words/","link":"","permalink":"http://blog.codeand.fun/2019/11/12/Replace-Words/","excerpt":"","text":"第8天。 今天的题目是 Replace Words In English, we have a concept called root, which can be followed by some other words to form another longer word - let’s call this word successor. For example, the root an, followed by other, which can form another word another. Now, given a dictionary consisting of many roots and a sentence. You need to replace all the successor in the sentence with the root forming it. If a successor has many roots can form it, replace it with the root with the shortest length. You need to output the sentence after the replacement. Example 1: 123Input: dict &#x3D; [&quot;cat&quot;, &quot;bat&quot;, &quot;rat&quot;]sentence &#x3D; &quot;the cattle was rattled by the battery&quot;Output: &quot;the cat was rat by the bat&quot; Note: The input will only have lower-case letters. 1 &lt;= dict words number &lt;= 1000 1 &lt;= sentence words number &lt;= 1000 1 &lt;= root length &lt;= 100 1 &lt;= sentence words length &lt;= 1000 看到题目给出了一个字符串字典，然后要根据单词中是否包含字典中的前缀来生成结果，想都不用想，就是用前缀树/字典树来做，关于前缀树的介绍可以看 https://oi-wiki.org/string/trie/ 。 首先先根据字典建立字典树，然后根据空格分隔单词，然后检查是否有前缀，如果没有前缀就将原始的单词插入结果中，如果有，则将前缀插入。由于在进行检查时，每次从一个节点跳到其子节点时都会检查者是否是一个在词典出现的前缀，所以所求的前缀一定是最短的。 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859struct Node &#123; struct Node* childs[26]; bool isLeaf; Node():isLeaf(false)&#123; for(int i = 0;i &lt; 26;i++) childs[i] = nullptr; &#125; ~Node() &#123; for(int i = 0;i &lt; 26;i++) if (childs[i]) delete childs[i]; &#125;&#125;;void insert(struct Node *root, string &amp;s) &#123; for(int i = 0, size = s.size(); i &lt; size; i++) &#123; int index = s[i] - 'a'; if (root-&gt;childs[index] == nullptr) root-&gt;childs[index] = new Node; root = root-&gt;childs[index]; &#125; root-&gt;isLeaf = true;&#125;int getMinLen(struct Node *root, string &amp;sentence, int beg, int end) &#123; for(int i = beg;i &lt; end; i++) &#123; int index = sentence[i] - 'a'; if (root-&gt;childs[index] == nullptr) return end; root = root-&gt;childs[index]; if (root-&gt;isLeaf) return i + 1; &#125; return end;&#125;string replaceWords(vector&lt;string&gt;&amp; dict, string sentence) &#123; // sort(dict.begin(), dict.end()); // build dict tree struct Node *root = new Node(); for(int i = 0;i &lt; dict.size(); ++i) &#123; insert(root, dict[i]); &#125; struct Node * p = root; // parse sentence string res, word; int beg = 0; for(int i = 0, size = sentence.size(); i &lt; size; i++) &#123; if (sentence[i] == ' ') &#123; int end = getMinLen(root, sentence, beg, i); for(int j = beg;j &lt; end; j++) res.push_back(sentence[j]); res.push_back(' '); beg = i + 1; word = \"\"; &#125; &#125; int end = getMinLen(root, sentence, beg, sentence.size()); for(int j = beg;j &lt; end; j++) res.push_back(sentence[j]); delete root; return res;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Sort Characters By Frequency","slug":"Sort-Characters-By-Frequency","date":"2019-11-11T12:23:34.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2019/11/11/Sort-Characters-By-Frequency/","link":"","permalink":"http://blog.codeand.fun/2019/11/11/Sort-Characters-By-Frequency/","excerpt":"","text":"第7天了 今天的题目是 Sort Characters By Frequency : Given a string, sort it in decreasing order based on the frequency of characters. Example 1: 123456789Input:&quot;tree&quot;Output:&quot;eert&quot;Explanation:&#39;e&#39; appears twice while &#39;r&#39; and &#39;t&#39; both appear once.So &#39;e&#39; must appear before both &#39;r&#39; and &#39;t&#39;. Therefore &quot;eetr&quot; is also a valid answer. Example 2: 123456789Input:&quot;cccaaa&quot;Output:&quot;cccaaa&quot;Explanation:Both &#39;c&#39; and &#39;a&#39; appear three times, so &quot;aaaccc&quot; is also a valid answer.Note that &quot;cacaca&quot; is incorrect, as the same characters must be together. Example 3: 123456789Input:&quot;Aabb&quot;Output:&quot;bbAa&quot;Explanation:&quot;bbaA&quot; is also a valid answer, but &quot;Aabb&quot; is incorrect.Note that &#39;A&#39; and &#39;a&#39; are treated as two different characters. 比较简单的一道题，具体解法如下： 计数算频率，用unordered_map就搞定了 按频率排序，先把unoredred_map转成vector，然后再sort 生成字符串。 具体代码如下： 1234567891011121314string frequencySort(string s) &#123; unordered_map&lt;char, int&gt; cmap; for(int i = 0;i &lt; s.size(); i++) cmap[s[i]]++; vector&lt;pair&lt;char, int&gt;&gt; pvec(cmap.begin(), cmap.end()); sort(pvec.begin(), pvec.end(), [](const pair&lt;char, int&gt; &amp;p1, const pair&lt;char, int&gt; &amp;p2) &#123; return p1.second &gt; p2.second; &#125;); string res; for(auto it = pvec.begin(); it != pvec.end(); ++it) &#123; res += string(it-&gt;second, it-&gt;first); &#125; return res;&#125; 因为中途需要把unordered_map转成vector，所以使用的空间就有点多了（统计数据存了两份），所以我们尝试直接使用vector来统计。之所以能直接用vector来统计，是因为char类型总共就256个字符而已，所以我们用一个长度为256的vector即可完成，具体代码如下： 12345678910111213string frequencySort(string s) &#123; vector&lt;pair&lt;char, int&gt; &gt; pvec(256); for(int i = 0;i &lt; 256; i++) pvec[i] = make_pair(i, 0); for(int i = 0;i &lt; s.size(); i++) &#123; pvec[s[i]].second++; &#125; string res; for(auto it = pvec.begin(); it != pvec.end() &amp;&amp; it-&gt;second; ++it) &#123; res += string(it-&gt;second, it-&gt;first); &#125; return res;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Longest String Chain","slug":"Longest-String-Chain","date":"2019-11-10T11:12:09.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/11/10/Longest-String-Chain/","link":"","permalink":"http://blog.codeand.fun/2019/11/10/Longest-String-Chain/","excerpt":"","text":"第6天。 今天的题目是Longest String Chain： Given a list of words, each word consists of English lowercase letters. Let’s say word1 is a predecessor of word2 if and only if we can add exactly one letter anywhere in word1 to make it equal to word2. For example, &quot;abc&quot; is a predecessor of &quot;abac&quot;. A word chain is a sequence of words [word_1, word_2, ..., word_k] with k &gt;= 1, where word_1 is a predecessor of word_2, word_2 is a predecessor of word_3, and so on. Return the longest possible length of a word chain with words chosen from the given list of words. Example 1: 123Input: [&quot;a&quot;,&quot;b&quot;,&quot;ba&quot;,&quot;bca&quot;,&quot;bda&quot;,&quot;bdca&quot;]Output: 4Explanation: one of the longest word chain is &quot;a&quot;,&quot;ba&quot;,&quot;bda&quot;,&quot;bdca&quot;. Note: 1 &lt;= words.length &lt;= 1000 1 &lt;= words[i].length &lt;= 16 words[i] only consists of English lowercase letters. 看到这道题的时候，一开始以为要先转化成图来做，但是感觉好像有点复杂化这个问题了，尝试手动跑了一下样例，发现存在最优子结构，因此我们可以用动态规划来做。动规方程如下： $$dp[i] = max({dp[j] + 1 | isPredecessor(words[i], words[j]) == true });$$ 简单解释一下这个方程（可能写的不是很规范），$dp[i]$ 表示以第i 个字符串为结尾的最长String Chain的长度。我们可以用第 i 个字符串的所有Predecessor的 dp 值最大值再加一得到。 同时，为了加速，我们可以先对原始的字符串序列做一次按长度的排序。这样就很容易找到和当前字符串长度相差1的字符串了，这样我们在找所有Predecessor的时候不需要遍历所有数组。 有了动规方程，我们写出这个代码就简单多了，只要按着类似的套路即可。 这样我们代码就只剩下如何判读一个字符串是否是另一个字符串的Predecessor，其实这个问题也挺简单的，只要两个循环即可。 12345678910111213141516171819202122232425262728293031323334353637bool isPredecessor(string &amp;s1, string &amp;s2) &#123; // check s2 is s1's predecessor if (s1.size() != s2.size() + 1) return false; int i = 0; int len = s2.size(); for(;i &lt; len &amp;&amp; s1[i] == s2[i]; i++) /* pass */; for(;i &lt; len &amp;&amp; s1[i+1] == s2[i]; i++) /* pass */; return i == len;&#125;int longestStrChain(vector&lt;string&gt;&amp; words) &#123; // sort by size sort(words.begin(), words.end(), [](const string &amp;s1, const string &amp;s2) &#123; return s1.size() &lt; s2.size(); &#125;); vector&lt;int&gt; dp(words.size(), 1); int beg = 0; int res = 0; for(int i = 1;i &lt; dp.size(); i++) &#123; while(words[beg].size() + 1 &lt; words[i].size()) beg++; for(int j = beg; j &lt; i; j++) &#123; if (isPredecessor(words[i], words[j])) dp[i] = max(dp[i], dp[j] + 1); &#125; res = max(dp[i], res); &#125; return res;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Reverse Substrings Between Each Pair of Parentheses","slug":"Reverse-Substrings-Between-Each-Pair-of-Parentheses","date":"2019-11-09T11:03:51.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2019/11/09/Reverse-Substrings-Between-Each-Pair-of-Parentheses/","link":"","permalink":"http://blog.codeand.fun/2019/11/09/Reverse-Substrings-Between-Each-Pair-of-Parentheses/","excerpt":"","text":"第5天。 今天的题目是：Reverse Substrings Between Each Pair of Parentheses： You are given a string s that consists of lower case English letters and brackets. Reverse the strings in each pair of matching parentheses, starting from the innermost one. Your result should not contain any brackets. Example 1: 12Input: s &#x3D; &quot;(abcd)&quot;Output: &quot;dcba&quot; Example 2: 123Input: s &#x3D; &quot;(u(love)i)&quot;Output: &quot;iloveu&quot;Explanation: The substring &quot;love&quot; is reversed first, then the whole string is reversed. Example 3: 123Input: s &#x3D; &quot;(ed(et(oc))el)&quot;Output: &quot;leetcode&quot;Explanation: First, we reverse the substring &quot;oc&quot;, then &quot;etco&quot;, and finally, the whole string. Example 4: 12Input: s &#x3D; &quot;a(bcdefghijkl(mno)p)q&quot;Output: &quot;apmnolkjihgfedcbq&quot; Constraints: 0 &lt;= s.length &lt;= 2000 s only contains lower case English characters and parentheses. It’s guaranteed that all parentheses are balanced. 很简单的一道题，和昨天那道差不多的思路，都是用栈来解决嵌套问题就好了，甚至比昨天那道题还要简单，所以直接放代码了： 123456789101112131415string reverseParentheses(string s) &#123; stack&lt;string&gt; st; st.push(string()); for(int i = 0;i &lt; s.size(); i++) &#123; if (s[i] == '(') &#123; st.push(string()); &#125; else if (s[i] == ')') &#123; string s = st.top(); st.pop(); st.top() += string(s.rbegin(), s.rend()); &#125; else &#123; st.top().push_back(s[i]); &#125; &#125; return st.top();&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Decode String","slug":"Decode-String","date":"2019-11-08T20:55:51.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/11/08/Decode-String/","link":"","permalink":"http://blog.codeand.fun/2019/11/08/Decode-String/","excerpt":"","text":"第四天。 今天的题目是Decode String： Given an encoded string, return its decoded string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won’t be input like 3a or 2[4]. Examples: 123s &#x3D; &quot;3[a]2[bc]&quot;, return &quot;aaabcbc&quot;.s &#x3D; &quot;3[a2[c]]&quot;, return &quot;accaccacc&quot;.s &#x3D; &quot;2[abc]3[cd]ef&quot;, return &quot;abcabccdcdcdef&quot;. 比较简单的一道题，先分析一下题目，首先输入的格式是k[encoded_string]，要将其扩展成k 个 encoded_string 组成的字符串，我们暂且先不考虑嵌套的情况，我们通过一个简单的状态机就可以解决这个问题： 这个代码写起来也很简单： 12345678910111213141516171819string decodeString(string s) &#123; string res; string temp; int num = 0; for(int i = 0, size = s.size(); i &lt; size; i++) &#123; if (isdigit(s[i])) &#123; num = num * 10 + s[i] - '0'; &#125; else if (s[i] == '[') &#123; temp = \"\"; &#125; else if (s[i] == ']') &#123; for(int i = 0;i &lt; num;i++) res += temp; &#125; else &#123; // charar res.push_back(s[i]); num = 0; &#125; &#125; return res;&#125; 如果这道题不需要考虑嵌套问题的话，上面就是正确的答案了。虽然需要处理嵌套的问题，但是其实只需要用栈来模拟多个层次的嵌套即可： 12345678910111213141516171819202122232425string decodeString(string s) &#123; int num = 0; stack&lt;string&gt; sst; stack&lt;int&gt; nst; nst.push(1); sst.push(string()); for(int i = 0, size = s.size(); i &lt; size; i++) &#123; if (isdigit(s[i])) &#123; num = num * 10 + s[i] - '0'; &#125; else if (s[i] == '[') &#123; beg = end = i + 1; nst.push(num); num = 0; sst.push(string()); &#125; else if (s[i] == ']') &#123; string s = sst.top(); sst.pop(); int n = nst.top(); nst.pop(); for(int j = 0;j &lt; n;j++) sst.top() += s; &#125; else &#123; // char sst.top().push_back(s[i]); &#125; &#125; return sst.top();&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Serialize and Deserialize BST","slug":"Serialize-and-Deserialize-BST","date":"2019-11-07T11:48:04.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2019/11/07/Serialize-and-Deserialize-BST/","link":"","permalink":"http://blog.codeand.fun/2019/11/07/Serialize-and-Deserialize-BST/","excerpt":"","text":"Serialize and Deserialize BST 第三天。 今天的题是[https://leetcode.com/problems/serialize-and-deserialize-bst/](Serialize and Deserialize BST): Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure. The encoded string should be as compact as possible. Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless. 这个题目需要我们实现两个函数，一个对BST进行序列化，一个对BST进行反序列化。总的来说对算法要求不高（时间上），但是要求序列化出来的字符串尽量小。 首先要解决两个问题： 如何序列化一个正常节点 如何序列化一个NULL节点 这里面我们采取这样一个方法，一个正常的节点由以下结构组成： 1234567struct &#123; char flag = 'Y'; union INT &#123; int iv; char cv[4]; &#125;;&#125;; 其中flag来标识，这是一个正常的节点，而INT则是存放节点的值，通过union,我们可以方便的将int转换为char数组。 一个NULL的节点当然也可以通过上面的结构组成，但是对于NULL节点来说，后面的INT其实没有必要，所以我们直接通过字符N来标识NULL节点。 因此，我们的实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Codec &#123;public: union INT &#123; int iv; unsigned char cv[4]; &#125;; // Encodes a tree to a single string. string serialize(TreeNode* root) &#123; string str; serialize(root, str); return str; &#125; void serialize(TreeNode *root, string &amp;str) &#123; if (root == NULL) &#123; str.push_back('N'); return; &#125; INT val; val.iv = root-&gt;val; str.push_back('Y'); for(int i = 0;i &lt; 4;i++) &#123; str.push_back(val.cv[i]); &#125; serialize(root-&gt;left, str); serialize(root-&gt;right, str); &#125; // Decodes your encoded data to tree. TreeNode* deserialize(string data) &#123; int index = 0; return deserialize(data, index); &#125; TreeNode *deserialize(string &amp;data, int &amp;index) &#123; if (index &gt;= data.size() || data[index] == 'N') &#123; index += 1; return nullptr; &#125; index += 1; INT val; for(int i = 0;i &lt; 4;i++) val.cv[i] = (unsigned char)data[index + i]; index += 4; TreeNode *root = new TreeNode(val.iv); root-&gt;left = deserialize(data, index); root-&gt;right = deserialize(data, index); return root; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"二叉树","slug":"二叉树","permalink":"http://blog.codeand.fun/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"K Closest Points to Origin","slug":"K-Closest-Points-to-Origin","date":"2019-11-06T13:24:29.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/11/06/K-Closest-Points-to-Origin/","link":"","permalink":"http://blog.codeand.fun/2019/11/06/K-Closest-Points-to-Origin/","excerpt":"","text":"第2天了。 今天的题目是[https://leetcode.com/problems/k-closest-points-to-origin/](K Closest Points to Origin): We have a list of points on the plane. Find the K closest points to the origin (0, 0). (Here, the distance between two points on a plane is the Euclidean distance.) You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in.) Example 1: 1234567Input: points &#x3D; [[1,3],[-2,2]], K &#x3D; 1Output: [[-2,2]]Explanation: The distance between (1, 3) and the origin is sqrt(10).The distance between (-2, 2) and the origin is sqrt(8).Since sqrt(8) &lt; sqrt(10), (-2, 2) is closer to the origin.We only want the closest K &#x3D; 1 points from the origin, so the answer is just [[-2,2]]. Example 2: 123Input: points &#x3D; [[3,3],[5,-1],[-2,4]], K &#x3D; 2Output: [[3,3],[-2,4]](The answer [[-2,4],[3,3]] would also be accepted.) Note: 1 &lt;= K &lt;= points.length &lt;= 10000 -10000 &lt; points[i][0] &lt; 10000 -10000 &lt; points[i][1] &lt; 10000 今天的题目比较简单，虽然是一道Mediem的题目，但是不知道为什么好像常规做法就AC了。解法就是算每个点到原点的距离先，然后排序，最后取出前K个就好了： 123456789101112131415161718vector&lt;vector&lt;int&gt;&gt; kClosest(vector&lt;vector&lt;int&gt;&gt;&amp; points, int K) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;pair&lt;int, int&gt;&gt; index; for(int i = 0, size = points.size(); i &lt; size; i++) &#123; pair&lt;int,int&gt; p = &#123;i, points[i][0]*points[i][0] + points[i][1]*points[i][1]&#125;; index.push_back(p); &#125; sort(index.begin(), index.end(), [](const pair&lt;int, int&gt; &amp;pi, const pair&lt;int, int&gt; &amp;pj) &#123; return pi.second &lt; pj.second; &#125;); for(int i = 0;i &lt; K;i++) &#123; res.push_back(points[index[i].first]); &#125; return res;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Chromebook 体验","slug":"Chromebook","date":"2019-10-07T19:50:44.000Z","updated":"2020-04-02T14:43:48.831Z","comments":true,"path":"2019/10/07/Chromebook/","link":"","permalink":"http://blog.codeand.fun/2019/10/07/Chromebook/","excerpt":"","text":"剁手的心路历程缘起大概是暑假的时候，刷手机的时候刷到了和Chromebook有点关系的东西吧，好像是在v2ex上看到了FydeOS的软文。随后就去了解了一下这个操作系统，从描述上来看，轻办公的话，好像还是不错的。讲道理，当时就挺心动了，好奇心驱使着我下载了FydeOS的ISO，并在U盘上体验了一番，感觉略卡，顿时就没有了兴趣，而且他们家推的那款电脑好像看起来很廉价，2k的价格为啥我不去买iPad呢？因为当时刚发布没多久好像没看到几个评测，所以慢慢就对其失去了想法，但是关于Chromebook的种子已经埋在了我心里。 重逢开学没多久就到了中秋，因为是新生，所以入学那几天都是不用上课的，但是也上了一天（刚好周四课贼多），所以感觉在上那些无聊的课程时如果能有个iPad或轻薄本的话应该会挺方便的。 大概是中秋假期的某个晚上，刷手机时又刷到了和Chromebook有关的东西吧，买一台Chromebook的想法又从我心中浮起。当时刚好比较闲，在Chromebook吧上看各位老哥关于Chromebook的分享和评测，并跑去下来一个CloudReady的镜像在虚拟机上玩耍了一下。虽然说是因为比较闲才去干这些的，但是其实当时应该是算在评估Chromebook对自己是否适合了。回想一下当时得出的结果应该是这样的： Chromebook大多数比较轻薄，续航较好，很适合做二奶机（自己的笔记本太大太重了） 买对的机器的话，可以很方便的开一个Linux的虚拟机（对自己来说有一定的生产力，本人常年使用Linux） 很多情况需要梯子（反正我的梯子也没断过） 从上面来看，这东西应该是挺适合我的。因为贴吧有位老哥对三星那款Chromebook Plus做了评测，而且本人有点颜值党，所以对三星这款还是比较满意的。 剁手由于Chromebook没有在国内发行，所以淘宝和京东什么的是搜不到什么东西的，想要买Chromebook大概就只有几种途径： 海淘 肉身翻出去买（因为在深圳，所以去香港澳门买东西还是比较方便的） 闲鱼收二手 恩，因为价格的原因，所以我还是选择了最轻松方便的闲鱼。在多次翻阅和比较后，我发现了一个比Chromebook Plus更好的选择，那就是Chromebook Plus v2。之所以说他是更好的选择，最主要是因为当时有位老哥给出来1k4的价格（因为机器A面有个小坑和两条划痕所以才那么低的），而且这款是支持电信LTE的。剁手嘛，总是会有点冲动的，在看到这个价格后没多久，我就和那位老哥联系了一下，并拍下了这款。 Chromebook Plus V2 体验硬件篇因为不是特别懂这块的东西，所以就不班门弄斧了，这里之见见主观的想法： 键盘不算好，应该是低于笔记本的平均水平的，但是也不差，起码比MacBook的好（前几天刚好去体检店玩了一下，没有回弹的键盘实在是太难受了），同时键盘和普通的有点区别，首先没有Win键（这可以理解，毕竟本来就不打算让你装window嘛），其次caps lock键被换成了搜索键（搞得我现在用其他笔记本的时候老是按caps lock），最后他的F1-F12全部被替换成了一些功能键（好像问题不大，有些情况下好像还是会映射成对于F键的，比如开启开发者模式后，Ctrl+Shift+F打开另一个tty，这和Linux的传统是一样的）。 触控板挺好用的，用来那么久了，基本没想过要插一个鼠标。 4G内存+32GB SSD实在是有点不够用啊，内存占有常年是满的，32GB装完系统和必要的东西后，基本上10GB都不一定有。 屏幕相当不错，触摸屏也挺好的。 摄像头没怎么体验过，两个摄像头好像都挺烂的，不过一般人也不会在笔记本上用到摄像头。 S Pen配合一些软件用起来相当好，就是笔有点小，拿久了会不舒服。 Chromebook Plus V2相比与Chromebook Plus多了一个LTE版本，亲测，可以插电信卡（应该是只能插电信卡），而且网络效果还行，没事不会断掉（断掉就重启），个人认为对于Chromebook这种上网本来说，随时随地的网络还是比较重要的，这也是我买V2版本的原因。 软件篇这部分是这篇文章的重点（写这篇文章的主要想法就是想记录下Chromebook上一些好用的应用），主要分为3个部分来展开，这三个部分是分别从Chrome，Linux，Android三个平台来介绍各个软件。 Chrome Chrome主要是介绍一些插件和应用。 Proxy SwitchyOmega：搭梯子时用到的 Adblock Plus：广告拦截 Evernote Web Clipper: 其实我已经弃用Evernote挺久的了，但是在Chromebook上Evernote的确是一个挺好的选择（主要是他安卓上优化的好，后面会提） OneTab：一键把所有打开的Tab收起来，在Chromebook这种小内存的机子上，这东西太有用了 Vimium：在浏览器上使用vim快捷键，喜欢vim的和键盘党可以试一下，不适合大部分人 All-in-One Messenger：用来打开网页版的微信还是不错的选择，但在Chromebook上用微信的次数不多，不确定有没有更好的选择 Cog：用来看Chromebook的硬件信息的，感觉还可以，主要是能看到内存和CPU占用（Chromebook自带的任务管理器看不了，不过最近发现Ctrl + Alt + T打开crosh，里面自带了top命令，会用的人可以考虑用top） Google Keep：ChromeOS自带，和S Pen配合还是挺好用的，但是同步需要梯子。 Minimalist Markdown Editor：很小巧的Markdown编辑器，这篇文章就是在这上面编辑的（当初码字还是很舒服的） Secure Shell App：SSH Client，大半的生产力在上面，不过对中文的兼容不是很好，主要体现在输入中文时，显示会乱掉（估计是没有实时刷新），但是现在还没有找到更好的选择。同时他还可以安装SFTP到文件管理器上，感觉还算挺好用的 TeamViewer：TeamViewer是我见过全平台做的最好的一款产品了，虽然不常用，但是总是会有需要它的时候。 Text：自带的文本编辑器，编辑一下简单的文本文件（比如V2ray的配置文件）还是挺好用的。 Code Pad Text Editor: 代码编辑器，写这篇文章期间发现的，第一感觉还可以 马克飞象：用来做Markdown编辑器还是挺好的，足够好看，而且能够同步到印象笔记中，但是他要收费，所以最后还是弃了 Firefox Send：传一些中小文件用的，速度上还不错，但是有点比较麻烦的就是它不是通过特殊的PIN码来分享，而是URL。把一个URL传到另一个机器上和传一个文件到另一个机器上的麻烦程度其实是一样的，个人认为这是它最大的缺点。不过我后面会有解决（妥协）办法。 Pushbullet：一个多平台的App，可以比较方便的传输信息，文件（传文件和图片什么的其实很慢），这就是用来解决Firefox Send需要把URL传到另一个机器上的方法。 Linux这部分只是简单介绍一下Chromebook上三个不同的Linux环境以及对它们的一些评价吧。 ChromeOS 众所周知，ChromeOS其实是一个Linux的发行版，所以在crosh输入shell其实是可以进入一个Linux环境的，但是ChromeOS的确不像其他常用的Linux发行版，他的终端支持的东西太少了，以至于很多东西想要安装上去其实很困难，例如如果你想要安装v2ray的话，通过go.sh其实是安装不上去的（反正我没成功）。同时，这个环境好像会因为ChromeOS的升级而被破换掉（亲身经历过，但不确定是不是运气刚好比较差）。因此，个人是不建议在这个环境安装太多东西的，不过还是有人弄出来一个ChromeOS的包管理器（chromebrew)，梯子好的话，安装起来并不困难，但是感觉没什么太大用处，我机子上只是用它安装了V2ray而已。 Crostini 这个东西是现在官方在推的，弄起来比较方便，在设置里面开启Linux终端，用起来还是比较方便的。这东西就是在ChromeOS上起了一个Linux的虚拟机，装的是Debian系统（有需要是可以换成其他系统的，在Reddit上有帖子介绍如何在把Debian换成Arch Linux），如果只是想要个命令行来跑一些小程序，用这个还是不错的，debian虽然装东西不如Arch那么方便，但是生态还是不错的，大部分Linux的软件都会有deb包。同时这个东西还有一点比较好的就是在这里面装GUI软件的话，其实可以很方便的在ChromeOS上打开（有点像VirtualBox的无缝模式），不过这样打开的软件是没法使用ChromeOS的输入法的，需要在debian上安装中文环境和输入法（这个网上介绍挺多的，不细讲）。BTW，由于屏幕是高分屏，然后Linux对其支持不太好，所以字体会显示的很小（有低分辨率模式，不过建议不要用，太糊了） Crouton 没搞懂这东西的原理，简单介绍一下他的效果吧。看起来也像是开了一个Linux虚拟机的样子，安装时可以选择不同的发行版（不过选择不多，基本都是debian系的，比如Ubuntu，Kail），同时可以选择安装不同的桌面（比如Unity，xfce，KDE）。一般情况下打开后切换到装好的Linux系统的桌面上，然后你就可以使用这个Linux啦，就像在虚拟机里面开全屏模式一样，可以用Ctrl + Alt + -&gt;和Ctrl + Alt + &lt;-在ChromeOS和Linux之间切换。这东西和Crostini一样也需要自己安装中文环境和输入法。要切来切去肯定比较麻烦，但是它还有个叫xiwi的东西可以实现在ChromeOS上打开LinuxGUI应用，不过体验没有Crostini好，也一样会有高分屏的问题。 还有一点比较重要的就是，Crouton安装起来比较麻烦，大部分包可以用镜像很快的下载下来，但是有个包没办法。个人的解决方法就是先直接用镜像安装，失败后再加http代理。 说实话，ChromeOS对Linux的支持是我最不满意的一部分，无论那种方式都有很多坑，而且有些好像没法解决（起码我现在还没有解决办法）。我现在的情况是，在ChromeOS上只使用Chromebrew安装v2ray，然后开发用Crostini。对于Crouton，我是直接弃掉了。不过Crostini中文上的确支持不好，他的终端App和Secure Shell App采用的估计是同一套代码，所以中文输入时一样会乱掉。不知道什么原因，在Crostini上使用vscode实在是太卡了，卡成PPT的那种。 Android个人觉得，ChromeOS蹭Android的应用的确满足了一部分人的刚需，Android上的一部分应用在Chromebook表现的非常好，当然也有坑点，但是相对于Linux那部分，个人还是比较满意Android的表现的。 MS Office 三件套：Word和ppt应该对大部分人来说是无法避免的东西。不过有点不好的就是，这个东西如果没有Office 365账号的话，是只能看，不能修改的。（hhh，我有学生账号）如果不想订阅Office 365的话，可以考虑下WPS，但是我感觉没有微软出的好用。BTW，大部分Android应用在用键盘输入的时候，输入法的提示栏会跑到左上方去，所以会很难受。 OneDrive：同步神器（才不是因为有1TB容量我才用它的呢） Squid：手写神器，试了很多款，就这个好用点，做做简单的笔记，免费版其实已经够用了。其实收费版好像也就导入PDF有点吸引力，不过这东西不支持PDF的书签，能导入PDF好像也没太大作用 Xodo：PDF神器，手写支持的很好（就是有时候有点卡） Evernote：点名表扬一下，这个可能是对Chromebook支持最好的了，他会把输入法的提示栏拉到当前输入的位置（虽然会闪一下，但是相比其他的好很多了） 总结总的来说，Chromebook作为一个二奶机，还是很不错的选择，不贵的价格（特指二手的），足够好的屏幕和续航。虽然软件应用上还做的不够，但是这在一些轻办公环境下已经相当不错了。","categories":[{"name":"杂事一堆","slug":"杂事一堆","permalink":"http://blog.codeand.fun/categories/%E6%9D%82%E4%BA%8B%E4%B8%80%E5%A0%86/"}],"tags":[{"name":"Chromebook","slug":"Chromebook","permalink":"http://blog.codeand.fun/tags/Chromebook/"},{"name":"ChromeOS","slug":"ChromeOS","permalink":"http://blog.codeand.fun/tags/ChromeOS/"}]},{"title":"Use Travis CI","slug":"Use-Travis-CI","date":"2019-08-20T00:30:27.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2019/08/20/Use-Travis-CI/","link":"","permalink":"http://blog.codeand.fun/2019/08/20/Use-Travis-CI/","excerpt":"","text":"今天简单使用了一下Travis CI。 起因因为搭建Django-blog时，每次更新一次代码，就需要手动登陆到服务器上进行一系列操作来重启服务，感觉过于麻烦且容易出错，因此想使用 CI/CD 工具来自动化这一过程。 所以这里就简单了解了一下 CI/CD，并尝试使用 Travis CI 来实现 Hexo 的自动化部署。 但考虑到 Travis CI 是一个 SaaS 服务，需要开发服务器的权限来完成部署，所以后面应该会先将Django-blog的部署方式转换成Docker的方式，然后在搭建Drone或Jenkins来完成 CI/CD CI/CD CI(Continuous Integration)即持续集成，个人理解是在提交代码后进行一些了测试来确保代码的正确性，保证每个开发者每次提交都会进行测试。 CD(Continuous Deploy)即自动部署，个人理解是在完成了测试后将代码自动化的部署到服务器上，这样就不需要开发者或运维来手动进行代码拉取，设置配置，重启服务等操作了，而是将其自动化。这个东西其实就是我想要的 Travis CI要使用Travis CI来完成自动化部署hexo可以分为以下几个步骤： 在Travis CI网站上将 repo 加入构建 在Github生成Github Access Token并将其加入到Travis CI的环境变量中，这里使用的变量名是GITHUB_TOKEN 在repo上添加一个Travis CI的配置文件： 下面是.travis.yml配置文件 12345678910111213141516171819202122232425langaue: node_jsnode_js: stablebranches: only: - savebefore_install: - npm install -g hexo-cli - git clone https://github.com/smduan/next.git themes/nextinstall: - npm install - npm install hexo-deployer-git --save script: - mv _next_config.yml themes/next/_config.yml - hexo clean - hexo generateafter_script: - git config user.name \"wuxiaobai24\" - git config user.email \"wuxiaobai24@foxmail.com\" - sed -i \"s/GITHUB_TOKEN/$&#123;GITHUB_TOKEN&#125;/g\" ./_config.yml - hexo deploy","categories":[{"name":"DevOps","slug":"DevOps","permalink":"http://blog.codeand.fun/categories/DevOps/"}],"tags":[{"name":"CI/CD","slug":"CI-CD","permalink":"http://blog.codeand.fun/tags/CI-CD/"},{"name":"Hexo","slug":"Hexo","permalink":"http://blog.codeand.fun/tags/Hexo/"}]},{"title":"Maximum Binary Tree","slug":"Maximum-Binary-Tree","date":"2019-03-21T11:31:43.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/03/21/Maximum-Binary-Tree/","link":"","permalink":"http://blog.codeand.fun/2019/03/21/Maximum-Binary-Tree/","excerpt":"","text":"第15天。 今天的题目是Maximum Binary Tree。 并不难的一道题，而且不同寻常的是用栈去做比用递归去做要方便一点。 我这里的想法是，从左向右一直插入就好了，例如输入是[3, 2, 1, 6, 0, 5] 先插入 3 ，然后插入下一个元素时进行讨论： 如果比上一次插入的元素要小，我就直接插入到上一次插入节点的右孩子处就好了。 如果比上一次插入的元素要大，我就用栈回溯到上上次插入节点的位置，进行判断，以此类推。 如果在栈中找到了，我就将新元素插入到该节点的右孩子处，并把原来的右子树当成是新元素的左子树。 如果没在栈中找到，我就把新元素当成新的根节点，并把原来的数当成新元素的左子树。 代码如下： 1234567891011121314151617181920212223242526272829303132333435TreeNode* constructMaximumBinaryTree1(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) return nullptr; stack&lt;TreeNode*&gt; st; auto end = nums.end(); TreeNode *root = new TreeNode(nums[0]); TreeNode *p = root; st.push(root); for(auto it = nums.begin() + 1; it != end; ++it) &#123; int val = *it; TreeNode *t = new TreeNode(val); if (val &lt; p-&gt;val) &#123; p-&gt;right = t; &#125; else &#123; while(!st.empty() &amp;&amp; val &gt; st.top()-&gt;val) st.pop(); if (!st.empty()) &#123; p = st.top(); t-&gt;left = p-&gt;right; p-&gt;right = t; &#125; else &#123; t-&gt;left = root; root = t; &#125; &#125; p = t; st.push(p); &#125; return root;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"Tree","slug":"Tree","permalink":"http://blog.codeand.fun/tags/Tree/"}]},{"title":"Daily Temperatures","slug":"Daily-Temperatures","date":"2019-03-20T11:17:39.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/03/20/Daily-Temperatures/","link":"","permalink":"http://blog.codeand.fun/2019/03/20/Daily-Temperatures/","excerpt":"","text":"第14天。 今天的题目是Daily Temperatures. 这道题会给我一个数组代表温度，如：T = [73, 74, 75, 71, 69, 72, 76, 73] 我们返回一个数组来表示，多少天会回暖（即比当天温度要高），如[1, 1, 4, 2, 1, 1, 0, 0] 如 74 比 73 高，则返回的数组中第一个数值应该为1，而对于 75 ，因为他后面只有76比他高，那么就得4天后才回暖，那么对应的位置应该放置4. 简单的想法当然是对每一个数字，从前向后找啦，但是这样复杂度就是O(N^2)了，所以我们换钟思路，从后向前去获取答案，看看能不能通过这种方式来减少复杂度。 之所以这样做，是想着能否利用之前已经求过的结果来推断当前的结果，比如求解 75 时，我们先猜答案是1，然后发现向前一天的温度是71，那么显然猜错了，这时我们要继续向前猜 69 吗？显然没必要啊，因为 69 都还没 71 大，我们应该利用之前求出的答案，发现比 71 大的数再他后面 2 天，所以我们直接猜答案是 1 + 2 即可，用这种方式就可以把前面的结果利用上了： 12345678910111213vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123; int len = T.size(); vector&lt;int&gt; res(len, 0); for(int i = len-2; i&gt;= 0; --i) &#123; int t = 1; while(T[i + t] &lt;= T[i] &amp;&amp; res[i+t] != 0) t += res[i+t]; res[i] = (T[i+t] &lt;= T[i])?0:t; &#125; return res;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Stone Game","slug":"Stone-Game","date":"2019-03-13T09:38:05.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2019/03/13/Stone-Game/","link":"","permalink":"http://blog.codeand.fun/2019/03/13/Stone-Game/","excerpt":"","text":"第13天，今天的题目有点有趣，也有点快。 今天的题目是Stone Game。 恩，这道题的答案是： 123456class Solution &#123;public: bool stoneGame(vector&lt;int&gt;&amp; piles) &#123; return true; &#125;&#125;; 解释如下： 假设有2n个石头。 因为Alex先选，那么Alex可以选第1或者2n个石头，如果选了1，那么Lee就只能选择2或者2n,Lee不管选哪个，Alex都可以选择一个奇数位的石头，如3或2n-1,即如果Alex先选了1,那么他可以让Lee一直选到的是偶数位的石头，反之亦然。因此Alex只要在开始选择的时候，计算所有石头奇数位之和以及偶数位之和，判断谁大就可以知道怎么选才能胜利了，因此，直接return true就好了。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Array Nesting","slug":"Array-Nesting","date":"2019-03-12T09:55:49.000Z","updated":"2020-04-02T14:43:48.831Z","comments":true,"path":"2019/03/12/Array-Nesting/","link":"","permalink":"http://blog.codeand.fun/2019/03/12/Array-Nesting/","excerpt":"","text":"第12天。 今天的题目是565. Array Nesting 总感觉这道题是刷过的。这道题的输入是一个由0到 N-1 组成的数组，按照S[i] = {A[i], A[A[i]], A[A[A[i]]], ... }的规则，找到S[i]最长的长度。 显然按这种走法，这个数组会是由多个环组成的，也就是我们要找出最长那个环的长度，我们只需要简单的去寻找即可，而且一旦我们经过了某个元素，一定不会出现在其他人的环中了，所以我们可以将其赋值为-1表示已经使用过来。 这样，我们的算法就是O(n)的复杂度了： 123456789101112131415161718192021222324class Solution &#123;public: int arrayNesting(vector&lt;int&gt;&amp; nums) &#123; int res = 0; for(int i = 0;i &lt; nums.size(); i++) &#123; if (nums[i] &lt; 0) continue; res = max(res, helper(nums, i)); &#125; return res; &#125; int helper(vector&lt;int&gt; &amp;nums, int index) &#123; int c = 0, j = nums[index]; nums[index] = -1; while(j &gt;= 0) &#123; int t = nums[j]; nums[j] = -1; j = t; c++; &#125; return c; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Bitwise ORs of Subarrays","slug":"Bitwise-ORs-of-Subarrays","date":"2019-03-11T10:22:12.000Z","updated":"2020-04-02T14:43:48.831Z","comments":true,"path":"2019/03/11/Bitwise-ORs-of-Subarrays/","link":"","permalink":"http://blog.codeand.fun/2019/03/11/Bitwise-ORs-of-Subarrays/","excerpt":"","text":"第11天，今天刷的是一道动态规划的题目。 今天的题目是Bitwise ORs of Subarrays: 这道题的时间复杂度很高，我们用个例子来解释解法： 首先输入是[1, 2, 4],我们先看下能不能用[1, 2]的答案来推出[1, 2, 4]的答案： [1, 2]的答案是1, 2, 3如果都与4或一下的话，会得到的是[5, 6, 7]，而[1, 2, 4]的答案中应该是没有5的，那么问题出在哪里了呢？如果仔细想一下的话，会发现这里要求的是连续子数组，而以4为结尾的连续子数组只有：[4], [2, 4], [1, 2, 4]，对它们进行或也就是说其实1其实是不会和4进行或运算的。 那么要和4进行或运算的数组是什么呢？答案是一个空数组和所有以2结尾的连续子数组的或运算结果，而进行完或运算后得到的结果就是所有以4结尾的或运算结果。 这时候我们就很容易想到解法了： 用一个set保存所有以A[i-1]结尾的或运算结果，记为set[i-1]，然后分别与A[i]进行或运算插入到另一个set中，并在最后插入一个A[i]就可以得到set[i]。 故： 12345678910111213141516class Solution &#123;public: int subarrayBitwiseORs(vector&lt;int&gt;&amp; A) &#123; int len = A.size(); if (len == 0) return 0; unordered_set&lt;int&gt; res, cur, cur2; for(auto &amp;i: A) &#123; cur2 = &#123;i&#125;; for(auto &amp;j : cur) cur2.insert(i | j); cur = cur2; for(auto &amp;j: cur) res.insert(j); &#125; return res.size(); &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"动态规划","slug":"动态规划","permalink":"http://blog.codeand.fun/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Odd Even Linked List","slug":"Odd-Even-Linked-List","date":"2019-03-09T12:12:09.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/03/09/Odd-Even-Linked-List/","link":"","permalink":"http://blog.codeand.fun/2019/03/09/Odd-Even-Linked-List/","excerpt":"","text":"第10天，今天的题目总感觉做过，但是翻记录又没有，难道是在学校的OJ上做的？？？ 今天的题目是 Odd Even Linked List。 好久没碰到链表的题了，这题比较简单。我们用一个新的链表来存奇数位的元素即可，而且这里没必要重新建立一个链表，只需要把原来链表里面的连接过来就好了，完成后，自然就把一个链表分成两个链表了。 区分奇偶数位，可以用一个 flag 来标识当前元素是奇数还是偶数，然后每移动一次就翻转该 flag ，当然更简单的是，我们循环一次移动两个元素，这样看起来会简洁一点，而且在循环内部不需要任何的条件判断，只需要在循环结束后做一些后处理即可。 123456789101112131415161718192021222324class Solution &#123;public: ListNode* oddEvenList(ListNode* head) &#123; if (head == nullptr || head-&gt;next == nullptr) return head; ListNode even(0); ListNode *p = head; ListNode *q = &amp;even; while(p-&gt;next &amp;&amp; p-&gt;next-&gt;next) &#123; q-&gt;next = p-&gt;next; p-&gt;next = p-&gt;next-&gt;next; p = p-&gt;next; q = q-&gt;next; &#125; if (p-&gt;next != nullptr) &#123; q-&gt;next = p-&gt;next; q = q-&gt;next; &#125; p-&gt;next = even.next; q-&gt;next = nullptr; return head; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://blog.codeand.fun/tags/Linked-List/"}]},{"title":"Matchsticks to Square","slug":"Matchsticks-to-Square","date":"2019-03-08T11:10:39.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/03/08/Matchsticks-to-Square/","link":"","permalink":"http://blog.codeand.fun/2019/03/08/Matchsticks-to-Square/","excerpt":"","text":"第9天，恩，忘记洗衣服了，写完就去洗。 今天的题目是Matchsticks to Square。 没想到是一道暴搜的题。。。 既然是暴搜，那思路就比较简单了： 我们先计算出数组和，然后除以4就是每条边的长度了，然后用暴力搜索的方式看是否能连续四次移除长度之和为边长的火柴。 暴搜时可以用一些小技巧，比如先排序来保证先用掉比较长的火柴，这样一旦发现，剩下的火柴比需要的长度还长就可以直接判定失败了，减少搜索次数。 而且标记是否使用掉该火柴的used数组也可以省略掉，因为火柴长度一定大于0， 可以用其相反数来表示已经用掉了 12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool makesquare(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); if (len == 0) return false; sort(nums.rbegin(), nums.rend()); int sum = 0; for(auto &amp;i: nums) sum+=i; if (sum % 4) return false; for(int i = 0;i &lt; 4; i++) &#123; if (dfs(nums, sum/4) == false) return false; &#125; return true; &#125; bool dfs(vector&lt;int&gt; &amp;nums, int len) &#123; if (len == 0) return true; else if (len &lt; 0) return false; for(int i = 0;i &lt; nums.size(); i++) &#123; if (len &lt; nums[i]) return false; if (nums[i] &lt;= 0) continue; nums[i] = -nums[i]; if (dfs(nums, len + nums[i])) return true; nums[i] = -nums[i]; &#125; return false; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"All Nodes Distance K in Binary Tree","slug":"All-Nodes-Distance-K-in-Binary-Tree","date":"2019-03-07T10:07:50.000Z","updated":"2020-04-02T14:43:48.831Z","comments":true,"path":"2019/03/07/All-Nodes-Distance-K-in-Binary-Tree/","link":"","permalink":"http://blog.codeand.fun/2019/03/07/All-Nodes-Distance-K-in-Binary-Tree/","excerpt":"","text":"第8天，感觉快要把每天刷题的习惯找回来了。。。 今天的题目是All Nodes Distance K in Binary Tree 这道题可以分为几个部分来解决： 寻找target节点 向下寻找距离当前节点K步的节点 从target节点向前寻找 虽说是三部分，但是在实现“寻找target节点”的时候，我们需要考虑到如何向前寻找，我们先把“向下寻找距离当前节点K步的节点”实现了。 很容易发现，这是一个递归的过程，做遍历的时候维护好K值即可，然后加一些判断条件就能实现了。 如果忽略掉“从target节点向前寻找”这个要求，我们要怎么实现寻找target节点呢？ 也是一个很简单的问题，就直接用递归形式的先序遍历即可，遍历时判断当前节点是否为target节点。 现在就剩下最后一部分了，也是这道题的难点所在。 要实现向前移动，我们可以利用“寻找target节点”的一些信息，通过一个返回值来确定，是否在某个子分支中找到 target 节点： 如果找到了，我们就可以从当前节点开始向另一个分支寻找了，因为需要计算到target节点的距离，所以我们干脆把返回值设置为还需要走多少步才能到达”距离target节点K步“的位置，故： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; distanceK(TreeNode* root, TreeNode* target, int K) &#123; vector&lt;int&gt; res; if (root == nullptr || target == nullptr) return res; downSearch(res, target, K); findTarget(res, root, target, K); return res; &#125; int findTarget(vector&lt;int&gt; &amp;res, TreeNode *root, TreeNode *target, int K) &#123; if (root == nullptr) return -1; if (root == target) return K - 1; // left int left_k = findTarget(res, root-&gt;left, target, K); if (left_k == 0) &#123; res.push_back(root-&gt;val); return left_k - 1; &#125; else if (left_k &gt; 0) &#123; downSearch(res, root-&gt;right, left_k-1); return left_k - 1; &#125; int right_k = findTarget(res, root-&gt;right, target, K); if (right_k == 0) &#123; res.push_back(root-&gt;val); return right_k - 1; &#125; else if (right_k &gt; 0) &#123; downSearch(res, root-&gt;left, right_k-1); return right_k - 1; &#125; return -1; &#125; void downSearch(vector&lt;int&gt; &amp;res, TreeNode* p, int K) &#123; if (p == nullptr || K &lt; 0) return ; if (K == 0) &#123; res.push_back(p-&gt;val); return; &#125; downSearch(res, p-&gt;left, K-1); downSearch(res, p-&gt;right, K-1); &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"Tree","slug":"Tree","permalink":"http://blog.codeand.fun/tags/Tree/"}]},{"title":"Sum Root to Leaf Numbers","slug":"Sum-Root-to-Leaf-Numbers","date":"2019-03-06T08:43:17.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2019/03/06/Sum-Root-to-Leaf-Numbers/","link":"","permalink":"http://blog.codeand.fun/2019/03/06/Sum-Root-to-Leaf-Numbers/","excerpt":"","text":"第7天，为什么今天随机到了一道水题。。。 今天的题目是129. Sum Root to Leaf Numbers 恩，这是一道打卡水题，明明是道Easy的题目，却混进了Medium中： 这道题有个比较容易想错的方法就是，用后序遍历做： 1234int sumNumbers(TreeNode* root) &#123; if (root == nullptr) return 0; return sumNumbers(root-&gt;left) + sumNumbers(root-&gt;right) + 20 * root-&gt;val;&#125; 这个方法对满二叉树是没问题的，但是对于普通的二叉树就会有问题，如： 123 1 &#x2F; 2 也就是说，在两边高度不一样时，是会出问题的，为了解决这个问题，我们要把思路换过来，把root到当前节点的值计算出来，并传给子节点去计算： 1234567891011121314class Solution &#123;public: int sumNumbers(TreeNode* root) &#123; return sumNumbers(root, 0); &#125; int sumNumbers(TreeNode* root, int v) &#123; if (root == nullptr) return 0; v = v*10 + root-&gt;val; if (root-&gt;right == nullptr &amp;&amp; root-&gt;left == nullptr) return v; return sumNumbers(root-&gt;left, v) + sumNumbers(root-&gt;right, v); &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"Tree","slug":"Tree","permalink":"http://blog.codeand.fun/tags/Tree/"}]},{"title":"Longest Repeating Character Replacement","slug":"Longest-Repeating-Character-Replacement","date":"2019-03-05T10:20:25.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/03/05/Longest-Repeating-Character-Replacement/","link":"","permalink":"http://blog.codeand.fun/2019/03/05/Longest-Repeating-Character-Replacement/","excerpt":"","text":"第6天， 下雨了。。。。 今天的题目是Longest Repeating Character Replacement。 emmmm，这道题一开始的解法虽然AC了，但是时间复杂度是O(n^2)，但是最佳解法却是O(n)，先看下我的解法： 思路比较简单，就是不断以某个字符为起始，以这个字符为目标，计算修改k次后能达到的长度，然而这样会有个问题，例如ABBB,如果k为1的话，我计算出来是3，但真实结果是4。 为了解决这个问题，我增加了一次判断，对前k个字符进行替换，替换成下一个字符，即以下一个字符为目标，计算修改k次后能达到的长度。 具体代码如下： 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int characterReplacement(string s, int k) &#123; int len = s.size(); int res = 0; int j, a; for(int i = 0; i &lt; len; i++) &#123; char c = s[i]; a = k; for(j = i+1;j &lt; len; j++) &#123; if (c != s[j]) &#123; if (a == 0) break; else a--; &#125; &#125; res = max(j-i, res); &#125; for(int i = 0;i &lt; k &amp;&amp; i+1 &lt; len; i++) &#123; char c = s[i+1]; a = k-i-1; for(j = i + 2;j &lt; len; j++) &#123; if (c != s[j]) &#123; if (a == 0) break; else a--; &#125; &#125; res = max(j-i, res); &#125; return res; &#125;&#125;; OK，现在可以忽略掉上面的解法了，看看O(n)的解法是怎样的： 12345678910111213141516171819class Solution &#123;public: int characterReplacement(string s, int k) &#123; vector&lt;int&gt; ch(26); int start = 0, end = 0, max_count = 0; int len = s.size(); while(end &lt; len) &#123; ch[s[end] - 'A']++; // update max_count max_count = max(max_count, ch[s[end]-'A']); end++; if ( end - start &gt; max_count + k) &#123; ch[s[start] - 'A']--; start++; &#125; &#125; return end - start; &#125;&#125;; 很精妙的用滑窗解决了这个问题： 首先，它用一个数组记录滑窗内的出现字符的个数，因此每次迭代或操作都向前移动一个字符而已，所以我们可以很容易维护出一个max_count，即所有字符出现次数最大的那一个。 然后如果是一个正确的解的话，要满足一个约束end - start - k &gt; max_count,如果满足的话，可以增大滑窗去寻找更大的窗口，如果不行，那么我们就向前移动滑窗。 虽然在迭代结束后，我们不能保证当前滑窗就是满足约束的解，但是我们可以保证，最大的窗口大小一定和我们现在的滑窗大小是一样的，故可以得到解。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Minimum Falling Path Sum","slug":"Minimum-Falling-Path-Sum","date":"2019-03-04T08:32:48.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2019/03/04/Minimum-Falling-Path-Sum/","link":"","permalink":"http://blog.codeand.fun/2019/03/04/Minimum-Falling-Path-Sum/","excerpt":"","text":"第5天，早起刷题的一天。 今天的题目是Minimum Falling Path Sum 一道典型的动态规划题，动态规划的题目一般都可以分为多步走，一旦执行完一步，走下一步时可以利用之前几步的结果来快速的选择下一步要怎么走。 关键就是要找出怎么利用之前几步的结果。 如这里的，我们要知道走到最后一行的最短路径，那么如果我们已经知道了走到倒数第二行（即上一行）的最短路径，我们就可以很快的算出走到最后一行的最短路径，即： dp[i][j] = min(dp[i-1][j-1], dp[i][j], dp[i][j+1]) + A[i][j] 然后很顺手的我们可以用两个数组来优化代码的空间复杂度，即把二维数组转成两个一维数组。 因此代码如下: 123456789101112131415161718192021222324252627class Solution &#123;public: int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123; int h = A.size(), w; if (h == 0) return 0; w = A[0].size(); vector&lt;int&gt; dp0 = A[0]; vector&lt;int&gt; dp1(w, INT_MAX); for(int i = 1; i &lt; h; i++) &#123; for(int j = 0;j &lt; w; j++) &#123; dp1[j] = INT_MAX; if (j &gt; 0) dp1[j] = min(dp0[j-1], dp1[j]); dp1[j] = min(dp0[j], dp1[j]); if (j + 1 &lt; w) dp1[j] = min(dp0[j+1], dp1[j]); dp1[j] += A[i][j]; &#125; swap(dp1, dp0); &#125; int res = INT_MAX; for(auto &amp;i: dp0) res = min(res, i); return res; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"动态规划","slug":"动态规划","permalink":"http://blog.codeand.fun/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Spiral Matrix","slug":"Spiral-Matrix","date":"2019-03-03T11:22:31.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2019/03/03/Spiral-Matrix/","link":"","permalink":"http://blog.codeand.fun/2019/03/03/Spiral-Matrix/","excerpt":"","text":"第四天，这又是一道之前没AC掉的题目。 今天的题目是54. Spiral Matrix 题意比较好理解，写的时候注意一下下标变换即可，最好现在纸上把给出的测例手动跑一下。 个人觉得，最大的坑点在第二个测例中已经给出来了，如果遇到[[1], [2]]或[[1, 2]]这种长条的要怎么做。 其实我们把他当成特殊例子即可，当所给出的矩阵的行列长度不一样时，最后一定会遇到上面的情况，这样我们可以先把正常的搞定，然后在最后面处理这两种情况即可。 这道题的主要思路是，我们模拟螺旋式的走法移动下标，然后一圈一圈的去游走即可，这里的代码不难，想清楚下标变换即可，最后一圈需要处理，因为最后一圈可能是三种情况： 只有一个元素 多个元素排成一列 多个元素排成一行 对于上面的三种情况，如果用之前模拟螺旋的方法，很容易走多了几步，其实只要简单的用两重循环即可。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;int&gt; res; int istart = 0, iend = matrix.size()-1; if (iend == -1) return res; int jstart = 0, jend = matrix[0].size()-1; // printf(\"%d %d %d %d\\n\", istart, iend, jstart, jend); while(istart &lt; iend &amp;&amp; jstart &lt; jend) &#123; int i = istart, j = jstart; // -&gt; for(;j &lt;= jend; j++) res.push_back(matrix[i][j]); j--; i++; // | // V for(;i &lt;= iend; i++) res.push_back(matrix[i][j]); i--; j--;; // &lt;- for(;j &gt;= jstart; j--) res.push_back(matrix[i][j]); j++; i--; // ^ // | for(;i &gt; istart; i--) res.push_back(matrix[i][j]); istart++; iend--; jstart++; jend--; // for(auto i: res) cout &lt;&lt; i &lt;&lt; \" \"; // cout &lt;&lt; endl; &#125; /// cout &lt;&lt; \"----\" &lt;&lt; endl; for(int i = istart; i &lt;= iend;i++) for(int j = jstart; j &lt;= jend; j++) res.push_back(matrix[i][j]); return res; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"Array","slug":"Array","permalink":"http://blog.codeand.fun/tags/Array/"}]},{"title":"Simplify Path","slug":"Simplify-Path","date":"2019-03-02T23:27:32.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2019/03/02/Simplify-Path/","link":"","permalink":"http://blog.codeand.fun/2019/03/02/Simplify-Path/","excerpt":"","text":"第三天（hhh，好像又很久没刷了）, 又AC掉了逻辑题，或者说又是一道用if else加状态机搞定的题。 今天的题目是71. Simplify Path 以后还是不copy题目到这里来了，有点麻烦的感觉。。。 对于这种纯看逻辑的题目，可以先分析一下给出的测例，然后通过题目来分析要注意什么： “/home/“ “/../“ “/home//foo/“ “/a/./b/../../c/“ “/a/../../b/../c//.//“ “/a//b////c/d//././/..” 从上面我们大概可以知道要注意的一些点有： 首先疑似最开始的符号一定是’/‘？ 通过/来分割单词，这意味着我们可以用python中的split或者先做一次遍历来分割单词，这样做会简化逻辑（但我没用这种方法） 要区分.和.. .表示当前目录，..表示上级目录 遇到多个/，就当成一个 事实上在后面的测试中，我发现一个很坑的点，就是...和..a这种并不是一个特殊的字符串，可以作为路径名。 我们现在尝试写一个基于状态机的方法，首先定义一下遍历时需要的状态： 前面是一个正常的字符 遇到/,就插入到结果字符串中，并跳转到1。 遇到.，就跳转到2。 遇到一个正常的字符，插入到结果字符串中。 前面是/ 如果遇到一个/，就直接跳过 如果遇到一个.,跳转到2 如果是一个正常字符，就插入到结果字符串中并跳转到0 前面是. 如果遇到一个/, 就跳转到1 如果遇到一个.,就跳转到3 如果遇到一个正常字符，就插入.和这个字符，并跳转到0 前面是.. 如果遇到一个/,就开始回溯删除到前面一个/ 其余则插入一个..和这个字符，并跳转到0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution &#123;public: string simplifyPath(string path) &#123; string res; // some flag to kepp state. int state = 0; // 0: last char is [char] // 1: last char is '/' // 2: last char is '.' // 3: last char is \"..\" if (path.size() != 0 &amp;&amp; path[path.size()-1]!='/') path.push_back('/'); int len = path.size(); for(int i = 0; i &lt; len; i++) &#123; char c = path[i]; if (state == 0) &#123; if (c == '/') &#123; res.push_back('/'); state = 1; &#125; else if (c == '.') state = 2; else res.push_back(c); &#125; else if (state == 1) &#123; if (c == '/') &#123;&#125; else if (c == '.') &#123; state = 2; &#125; else &#123; res.push_back(c); state = 0; &#125; &#125; else if (state == 2) &#123; if (c == '/') state = 1; else if (c == '.') &#123; // '..' state = 3; &#125; else &#123; res.push_back('.'); res.push_back(c); state = 0; &#125; &#125; else if (state == 3) &#123; if (c == '/') &#123; // go back res.pop_back(); // pop '/' while(res.size() != 0 &amp;&amp; *res.rbegin() != '/') &#123; res.pop_back(); // pop anthing until '/' &#125; if (res.size() == 0) res.push_back('/'); state = 1; &#125; else &#123; res.push_back('.'); res.push_back('.'); res.push_back(c); state = 0; &#125; &#125; //cout &lt;&lt; state &lt;&lt; \" \" &lt;&lt; c &lt;&lt; \" \" &lt;&lt; res &lt;&lt; endl; &#125; if ((state == 1 &amp;&amp; res.size() != 1)) res.pop_back(); return res; &#125;&#125;; update at 2020-03-23 状态转移图： 这道题其实用栈会更简单一点： 12345678910111213141516171819202122232425string simplifyPath(string path) &#123; vector&lt;string&gt; st; int beg = 0; path.push_back('/'); for(int i = 0, sz = path.size(); i &lt; sz; i++) &#123; if (path[i] == '/') &#123; auto s = path.substr(beg, i-beg); beg = i + 1; if (s == \".\" || s.size() == 0) &#123; // do nothing &#125; else if (s == \"..\") &#123; if (st.size() != 0) st.pop_back(); // make sure '/../' is ok &#125; else st.push_back(s); &#125; &#125; string res; for(auto &amp;s: st) &#123; // cout &lt;&lt; s &lt;&lt; endl; res.push_back('/'); res += s; &#125; if (res.size() == 0) res.push_back('/'); return res;&#125; 用stringstream和getline来进行字符串分割： 123456789101112131415161718192021string simplifyPath(string path) &#123; string buf; istringstream ss(path); vector&lt;string&gt; st; while(getline(ss, buf, '/')) &#123; // cout &lt;&lt; buf &lt;&lt; endl; if (buf == \".\" || buf.size() == 0) &#123; &#125; else if (buf == \"..\")&#123; if (st.size() != 0) st.pop_back(); &#125; else st.push_back(buf); &#125; string res; for (auto &amp;s: st) &#123; res.push_back('/'); res += s; &#125; if (res.size() == 0) res.push_back('/'); return res;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"Stack","slug":"Stack","permalink":"http://blog.codeand.fun/tags/Stack/"},{"name":"String","slug":"String","permalink":"http://blog.codeand.fun/tags/String/"},{"name":"FSM","slug":"FSM","permalink":"http://blog.codeand.fun/tags/FSM/"}]},{"title":"ZigZag Conversion","slug":"ZigZag-Conversion","date":"2019-02-15T17:42:54.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2019/02/15/ZigZag-Conversion/","link":"","permalink":"http://blog.codeand.fun/2019/02/15/ZigZag-Conversion/","excerpt":"","text":"第二天。今天AC掉了一道之前没AC掉的题目。。。 今天的题目是6. ZigZag Conversion 题目描述： The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) 123P A H NA P L S I I GY I R And then read line by line: “PAHNAPLSIIGYIR” Write the code that will take a string and make this conversion given a number of rows: 1string convert(string s, int numRows); Example 1: 12Input: s &#x3D; &quot;PAYPALISHIRING&quot;, numRows &#x3D; 3Output: &quot;PAHNAPLSIIGYIR&quot; 12345678Input: s &#x3D; &quot;PAYPALISHIRING&quot;, numRows &#x3D; 4Output: &quot;PINALSIGYAHRPI&quot;Explanation:P I NA L S I GY A H RP I 恩，又是一道“编程题“， 并不涉及到什么算法，静下心来仔细想想还是能做出来的。做这道题的思路就是一点一点跑例子，找出其中的规律就好了。 我们先以输入为s = &quot;PAYPALISHIRING&quot;, numRows = 3为例子，这是题目给出的例子，正确答案已经有了。 先把Z字型画出来（不难发现，题目在最开始其实已经给出了答案）： 123P A H NA P L S I I GY I R 观察上面的例子我们可以发现： 第一行中的元素在原来的字符串中下标相差4个。 第二行中的元素在原来字符串中下标相差2个。 ok，看起来好像找到了一些规律，继续跑一个例子验证一下，这次的输入是s = &quot;PAYPALISHIRING&quot;, numRows = 3，把Z字型画出来： 1234P I NA L S I GY A H RP I 可以看到第一行的元素在原来字符串中的下标相差6个，但是第二行却出现了一些不一样的情况： A与L相差4个，L与S却相差2个 S与I相差4个，I与G却相差2个 看起来offset是有规律的，而且好像需要分成两种情况，继续看看第3行： Y与A相差2个，A与H相差4个 H与R相差4个，如果还有元素的话，下一个元素与R之间显然相差2个。 从上面的例子来看显然是要分成两种情况的，某一行中下标之间的offset是不断在两个数字间不断变换的。 我们尝试用两个数组来保存这些offset，我们把这两个数组定义为skipDown和skipUp。其中skipDown表示下标在z字型中经过了一个向下的剪头，如第二个例子中，第一行的P移动到I时，P经过了AYPAl组成的向下的剪头。skipUp同理可推。 如果我们继续跑例子的话，应该是比较容易找出规律的： 第i行的skipDown为2*(i-1)，而第一行和最后一行的skipDown都应该为2*(numRows)。 skipDown与skipUp是逆序的关系。 综上，我们可以写出下面的代码： 12345678910111213141516171819202122232425262728293031string convert(string s, int numRows) &#123; if (numRows &lt; 2) return s; vector&lt;int&gt; skipDown(numRows); vector&lt;int&gt; skipUp(numRows); skipDown[0] = 2*(numRows-1); skipUp[0] = 0; for(int i = 1;i &lt; numRows; i++) &#123; skipDown[i] = skipDown[i-1] - 2; skipUp[i] = skipUp[i-1] + 2; &#125; skipDown[numRows-1] = skipDown[0]; skipUp[0] = skipUp[numRows-1]; string res(s.size(), ' '); int index = 0; for(int i = 0;i &lt; numRows; i++) &#123; bool flag = true; for(int j = i;j &lt; s.size();index++) &#123; res[index] = s[j]; if (flag) &#123; j += skipDown[i]; &#125; else &#123; j += skipUp[i]; &#125; flag = !flag; &#125; &#125; return res;&#125; 当然这肯定不是最优的代码，比如其实我们可以不用两个数组，甚至不用数组来保存的offset，但是这样写会比较容易理解，代码会比较简单点。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"String-to-Integer(atoi)","slug":"String-to-Integer-atoi","date":"2019-02-14T21:39:48.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2019/02/14/String-to-Integer-atoi/","link":"","permalink":"http://blog.codeand.fun/2019/02/14/String-to-Integer-atoi/","excerpt":"","text":"hhh, 开始一天一道LeetCode吧, 恩, 忘记了之前算到第几天了, 那么从头开始吧, 今天是第一天. 今天的题目是(8. String to Integer (atoi))[https://leetcode.com/problems/string-to-integer-atoi/] 题目描述: Implement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note: Only the space character ‘ ‘ is considered as whitespace character. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31, 2^31 − 1]. If the numerical value is out of the range of representable values, INT_MAX (2^31 − 1) or INT_MIN (−2^31) is returned. Example 1: Input: “42”Output: 42 Example 2: Input: “ -42”Output: -42Explanation: The first non-whitespace character is ‘-‘, which is the minus sign. Then take as many numerical digits as possible, which gets 42. Example 3: Input: “4193 with words”Output: 4193Explanation: Conversion stops at digit ‘3’ as the next character is not a numerical digit. Example 4: Input: “words and 987”Output: 0Explanation: The first non-whitespace character is ‘w’, which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed. Example 5: Input: “-91283472332”Output: -2147483648Explanation: The number “-91283472332” is out of the range of a 32-bit signed integer. Thefore INT_MIN (−231) is returned. 怎么说呢， 这是一道编程題， 而不是算法题， 事实上没用到什么算法， 把逻辑理清楚， 然后注意一下坑就好了。 我们现在来理一理atoi()的逻辑： 我们要跳过字符串开头的所有空格。 第一个非空格字符，只能是+, -以及0到9的所以数字。 如果第一个非空格字符是-， 我们就要返回一个负数。 解析字符串中的数字， 直到遇到第一个非数字就结束（或者遍历晚字符串） 然后如果在解析数字的时候发现， 如果溢出了， 就直接返回INT_MAX或INT_MIN(看前面是否有符号) 感觉整个逻辑还是比较好写的， 就只有一个麻烦点：怎么判断是否溢出了？ 有两个方法： 方法一： 因为atoi()只解析32位的有符号整数， 所以我们可以直接用64位的整数来计算结果，这样就可以直接判断是否超出32位的范围了，也就是用long long, 但是这样要计算64位的乘法和加法，会比较耗时。 方法二： 直接用32位的整数来计算结果， 在解释这个方法前，我们先看下是如何解析数字的, 解析数字主要就是把单个字符转成数字， 然后通过以下等式来迭代计算结果res = res * 10 + i;。可以看到这里有一个乘10的计算，所以我们可以在计算这个等式之前， 用INT_MAX/10来判断是否溢出。 1234567891011121314151617181920212223242526272829303132int myAtoi(string str) &#123; int res = 0; // clear space int beg = 0; while(beg &lt; str.size()) &#123; char c = str[beg]; if (c == ' ') beg++; else if (c == '-' || c == '+'||(c &lt;= '9' &amp;&amp; c &gt;= '0')) break; else return res; &#125; int sign = 1; int max_num = INT_MAX; // if we have '+' or '-' if (str[beg] == '+') &#123; beg++; &#125; else if (str[beg] == '-') &#123; beg++; sign = -1; max_num = INT_MIN; &#125; const int c = INT_MAX/10; for(;beg &lt; str.size() &amp;&amp; str[beg] &gt;= '0' &amp;&amp; str[beg] &lt;= '9'; beg++) &#123; int i = str[beg]-'0'; if (res &gt; c || (res == c &amp;&amp; i &gt; 7)) return max_num; res = res * 10 + i; &#125; return sign*res;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"记一次Hexo迁移","slug":"记一次Hexo迁移","date":"2019-02-14T09:08:44.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2019/02/14/记一次Hexo迁移/","link":"","permalink":"http://blog.codeand.fun/2019/02/14/%E8%AE%B0%E4%B8%80%E6%AC%A1Hexo%E8%BF%81%E7%A7%BB/","excerpt":"","text":"很久没有写过Blog了, 而且也把系统换成了Manjaro, 所以又要再配置一次Hexo的环境等等, 为了下次迁移的时候, 能更快的搞定, 所以记录一下这次迁移的过程. 获取源文件Hexo如果需要迁移的话, 只需要保留以下几个文件即可: _config.yml theme/ source/ scaffold/ package.json .gitignore 因为之前已经迁移过一次了, 所以我的源文件都已经保存在github上了, 在wuxiaobai24.github.io起了一个save分支来保存文件. 所以获取源文件, 我只需要: 1$ git clone git@github.com:wuxiaobai24/wuxiaobai24.github.io.git 安装Hexo这一步网上大多教程都写的很清楚了, 这里简略提一下, 主要是以下几个步骤: 安装npm 用npm安装hexo hexo init blog 把上面提到的源文件全部拷贝到blog文件夹中 注意:这里的blog文件最好放在wuxiaobai24.github.io目录下, 这样利用backups.sh可以很快的把源文件拷贝到blog文件夹中, 但是记得把backups.sh里面最后三行关于git的删去或注释掉 安装依赖 首先先把主题安装下来先, 之前因为忘记了这个, 导致hexo generate失败 1$ git clone git@github.com:litten/hexo-theme-yilia.git themes/yilia npm install 检测是否成功 12$ hexo g$ hexo s 构建快速的写作环境 将blog移到任何你想要放的位置, 然后把之前的wuxiaobai24.github.io文件夹删去 在blog目录下, git clone git@github.com:wuxiaobai24/wuxiaobai24.github.io.git 在vscode中安装vscode-hexo插件 主要的工作流为: vscode中&gt; hexo new生成新的文章 写文章, 并&gt; hexo generate vscode中&gt; hexo deplot部署 最后在命令行下切换到blog/wuxiaobai24.github.io中, 执行backups.sh备份源文件. PS: 个人建议把主题的config.yml也备份一下.","categories":[{"name":"杂事一堆","slug":"杂事一堆","permalink":"http://blog.codeand.fun/categories/%E6%9D%82%E4%BA%8B%E4%B8%80%E5%A0%86/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.codeand.fun/tags/Hexo/"},{"name":"blog","slug":"blog","permalink":"http://blog.codeand.fun/tags/blog/"}]},{"title":"Palindromic-SubStrings","slug":"Palindromic-SubStrings","date":"2018-03-05T09:51:59.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2018/03/05/Palindromic-SubStrings/","link":"","permalink":"http://blog.codeand.fun/2018/03/05/Palindromic-SubStrings/","excerpt":"","text":"今天的题目是Palindromic Substrings: Given a string, your task is to count how many palindromic substrings in this string. The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters. Example 1:Input: “abc”Output: 3Explanation: Three palindromic strings: “a”, “b”, “c”.Example 2:Input: “aaa”Output: 6Explanation: Six palindromic strings: “a”, “a”, “a”, “aa”, “aa”, “aaa”.Note:The input string length won’t exceed 1000. 主要思路： 很敏感的想到了动态规划，比如说我们现在想要知道aabaa是不是回文，如果我们已经求出来aba是回文，那么我就可以之间判断第一个字符和最后一个字符是否相等即可，还有一点就是如果要判断的字符串的长度为1或0，显然就可以之间返回为是字符串啦。 所以我们可以写出动规方程： dp[first][last] = (dp[first+1][last-1] || last-first-2 &lt;= 0) &amp;&amp; s[first] == s[last]; 123456789101112131415class Solution &#123;public: int countSubstrings(string s) &#123; int size = s.size(); vector&lt;vector&lt;bool&gt;&gt; dp(size,vector&lt;bool&gt;(size,false)); int res = 0; for(int i = size-1; i &gt;= 0; i--) &#123; for(int j = i;j &lt; size;j++) &#123; dp[i][j] = s[i] == s[j] &amp;&amp; (j-i-2 &lt;= 0 || dp[i+1][j-1]); res += dp[i][j]; &#125; &#125; return res; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Queue Reconstruction by Height","slug":"Queue-Reconstruction-by-Height","date":"2018-03-04T12:50:30.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2018/03/04/Queue-Reconstruction-by-Height/","link":"","permalink":"http://blog.codeand.fun/2018/03/04/Queue-Reconstruction-by-Height/","excerpt":"","text":"题目是Queue Reconstruction by Height: 题目描述： Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue. Note:The number of people is less than 1,100. Example Input:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]] Output:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 求解思路： 很好玩的题目，一开始是没有思路怎么做的，先解释一下题目先 首先它的输入是一个格式为(h,k)的二元组的列表，h表示person的高度，然后k是在队伍中站在它前面且高度大于等于他的人的个数。 我们要根据这些信息来重建这个队列（输入是乱的），是它符合上面的格式。 首先想到的就是先排序，不排序，肯定要一直扫描所有的person才能得到我们的想要的信息。 然后就按h的顺序来排序，当h相等时就按k排序。 按照上面的样例进行排序就得到： 1[[4,4], [5, 0], [5, 1], [6, 1], [7, 0], [7, 1]] 我们先考虑第一个位置放什么，从头开始扫描：[4,4]显然不是，[5, 0]，因为k为0，所以显然就是它了，我们并不需要扫描到后面去，因为它是高度最小的且k为0的person,所以我们可以直接把它放到第一个位置上去，这样的话，现在我们考虑可以第二个位置了，有了放第一个的方法，我们就可以递归的去做，现在是找[[4,4],[5,1],[6,1],[7,0],[7,1]第一个放的位置，直接扫过去就可以得到[7,0]的位置，看起来好像是对的方法，但是我们很容易就发现，下一个我们就没法找出来了，因为没有k为0的person了，所以我们要不断的更新去做，比如[5, 0]移动到第一个位置需要经过[4,4]，那么这时[4,4]前面就站着一个[5,0]而且比他高，所以在后面的扫描中，它的k应该就是3了，[7,0]向前移动的时候同理，[4,4], [5, 1], [6, 1]的k都需要减一。 因为我们是不能直接修改people的k的，所以我们需要一个数组来保存。 还有一点就是上面没有考虑到高度相同的情况，比如[7,0],[7,1]，第二个人前面其实已经站着一个高度大于等于它的人了，其实它的k其实应该是0,而不是1，所以我们需要继续调整，因为可能会出现[7,0],[7,1],[7,2]的情况，所以在从前往后生成新的数组保存k值的时候，我们还需要向前扫描看前面有多少个高度相同的人才能计算出实际的k值，这样的时间复杂度是O(n^2)，所以我们不保存k值，我们保存k前面有多少个高度大于等于它的人，这样的生成辅助数据的时间复杂度就是O(n)了。 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;pair&lt;int, int&gt;&gt; reconstructQueue(vector&lt;pair&lt;int, int&gt;&gt;&amp; people) &#123; int size = people.size(); if (size == 0 || size == 1) return people; sort(people.begin(), people.end(), [](const pair&lt;int, int&gt; &amp;p1,const pair&lt;int, int&gt; &amp;p2) &#123; return p1.first &lt; p2.first || (p1.first == p2.first &amp;&amp; p1.second &lt; p2.second); &#125;); vector&lt;int&gt; m(size, 0); m[0] = 0; for(int i = 1;i &lt; size;i++) &#123; if (people[i].first == people[i-1].first) &#123; m[i] = m[i-1] + 1; &#125; else m[i] = 0; &#125; // like insert sort. for(int i = 1;i &lt; size;i++) &#123; auto p = people[i]; int t = m[i], j; for(j = i-1;j &gt;= 0 &amp;&amp; (p.second - t) &lt; (people[j].second - m[j]) ;j--) &#123; if (people[j].first &lt;= p.first) m[j]++; people[j+1] = people[j]; m[j+1] = m[j]; &#125; people[j+1] = p; m[j+1] = t; &#125; return people; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Count Complete Tree Nodes","slug":"Count-Complete-Tree-Nodes","date":"2018-03-03T13:38:01.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2018/03/03/Count-Complete-Tree-Nodes/","link":"","permalink":"http://blog.codeand.fun/2018/03/03/Count-Complete-Tree-Nodes/","excerpt":"","text":"题目是Count Complete Tree Nodes: 题目描述： Given a complete binary tree, count the number of nodes. Definition of a complete binary tree from Wikipedia:In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. 求解思路： 一开始想的是想法是，我们把最后一层的个数计算出来就简单很多了，所以我们可以先计算树的高度，然后用二分查找算出层数，虽然能过，但是很慢很慢（为什么我算出来的时间复杂度是O(lgn*lgn)啊。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int countNodes(TreeNode *root) &#123; if (root == nullptr) return 0; int height = 0; TreeNode *p = root; while(p) &#123; p = p-&gt;left; height++; &#125; cout &lt;&lt; height &lt;&lt; endl; int low = 0; int high = pow(2, height - 1); int count = high; int h, mid, t, m; int mask = 1 &lt;&lt; (height - 2); while(low &lt; high) &#123; mid = (low + high)/2; /* cout &lt;&lt; low &lt;&lt;\" \" &lt;&lt; mid &lt;&lt; \" \" &lt;&lt; high &lt;&lt; endl; */ p = root; h = height; t = mid; m = mask; while(p) &#123; //cout &lt;&lt; \"#\" &lt;&lt; p-&gt;val &lt;&lt; endl; if (t &amp; m) p = p-&gt;right; else p = p-&gt;left; h--; m = m&gt;&gt;1; &#125; // cout &lt;&lt; h &lt;&lt; endl; if (h == 0) low = mid + 1; else high = mid; &#125; cout &lt;&lt; count &lt;&lt; endl; cout &lt;&lt; low &lt;&lt; endl; return count + low - 1; &#125;&#125;; 然后就想着不要那么复杂，我们先看左子树是不是满二叉树，如果不是，我们就可以通过左子树的高度来求右子树的节点个数了，但是这样方法在c++上是跑不过去的，但是在python中很快，很奇怪的是同样的测例，c++的版本要400ms左右，但是python的版本只要40ms左右，而且这个做法在python中还是比较快的： 12345678910111213141516171819202122class Solution: def countNodes(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; if root is None: return 0 h, count, iffull &#x3D; self.countNodesHelper(root) return count def countNodesHelper(self, root): if root is None: return 0, 0, True left_h, left_count, left_full &#x3D; self.countNodesHelper(root.left) if not left_full: # print(&#39;not full&#39;) return left_h + 1, left_count + 2**(left_h - 1), False right_h, right_count, right_full &#x3D; self.countNodesHelper(root.right) # print(left_count + right_count + 1) return left_h+1, left_count + right_count + 1, left_full and right_full and left_h &#x3D;&#x3D; right_h 最后看一下dicuss中的解法，想法和我第二个解法有点类似，但是更简洁，应该也更快： 1234567891011121314151617int countNodes(TreeNode* root) &#123; if(!root) return 0; int hl=0, hr=0; TreeNode *l=root, *r=root; while(l) &#123;hl++;l=l-&gt;left;&#125; while(r) &#123;hr++;r=r-&gt;right;&#125; if(hl==hr) return pow(2,hl)-1; return 1+countNodes(root-&gt;left)+countNodes(root-&gt;right);&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Add Two Numbers II","slug":"Add-Two-Numbers-II","date":"2018-03-02T11:02:52.000Z","updated":"2020-04-02T14:43:48.831Z","comments":true,"path":"2018/03/02/Add-Two-Numbers-II/","link":"","permalink":"http://blog.codeand.fun/2018/03/02/Add-Two-Numbers-II/","excerpt":"","text":"题目是Add Two Numbers II: 题目描述： You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Follow up:What if you cannot modify the input lists? In other words, reversing the lists is not allowed. Example: Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 8 -&gt; 0 -&gt; 7 求解思路： 这道题最简练的方法就是用栈了做了，然后还可以先计算出两个链表的长度，再生成链表。 思路都比较简单，emmm，一开始以为做成递归的会比较简单，后来发现不仅时间复杂度还是代码的复杂度都挺高的，做成迭代的会好很多。 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; stack&lt;int&gt; s1, s2; int carry = 0, v1, v2, v; ListNode *cur; ListNode *pre = nullptr; while(l1 || l2) &#123; if (l1) &#123; s1.push(l1-&gt;val); l1 = l1-&gt;next; &#125; if (l2) &#123; s2.push(l2-&gt;val); l2 = l2-&gt;next; &#125; &#125; while(!s1.empty() || !s2.empty() || carry) &#123; v1 = v2 = 0; if (!s1.empty()) &#123; v1 = s1.top(); s1.pop(); &#125; if (!s2.empty()) &#123; v2 = s2.top(); s2.pop(); &#125; v = v1 + v2 + carry; cur = new ListNode(v % 10); cur-&gt;next = pre; pre = cur; carry = v /10; &#125; return pre; &#125;&#125;; 给出一个dicuss中的方法，很巧妙，用的是翻转链表（题目说不能修改原来的链表，所以这里是翻转output): 1234567891011121314151617181920212223242526272829ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; int n1 = 0, n2 = 0, carry = 0; ListNode *curr1 = l1, *curr2 = l2, *res = NULL; while( curr1 )&#123; curr1=curr1-&gt;next; n1++; &#125; while( curr2 )&#123; curr2=curr2-&gt;next; n2++; &#125; curr1 = l1; curr2 = l2; while( n1 &gt; 0 &amp;&amp; n2 &gt; 0)&#123; int sum = 0; if( n1 &gt;= n2 )&#123; sum += curr1-&gt;val; curr1=curr1-&gt;next; n1--;&#125; if( n2 &gt; n1 )&#123; sum += curr2-&gt;val; curr2=curr2-&gt;next; n2--;&#125; res = addToFront( sum, res ); &#125; curr1 = res; res = NULL; while( curr1 )&#123; curr1-&gt;val += carry; carry = curr1-&gt;val/10; res = addToFront( curr1-&gt;val%10, res ); curr2 = curr1; curr1 = curr1-&gt;next; delete curr2; &#125; if( carry ) res = addToFront( 1, res ); return res;&#125;ListNode* addToFront( int val, ListNode* head )&#123; ListNode* temp = new ListNode(val); temp-&gt;next = head; return temp;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Coin Change 2","slug":"Coin-Change-2","date":"2018-03-01T10:30:58.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2018/03/01/Coin-Change-2/","link":"","permalink":"http://blog.codeand.fun/2018/03/01/Coin-Change-2/","excerpt":"","text":"题目是Coin Change 2: 题目描述： You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin. Note:You can assume that 0 &lt;= amount &lt;= 5000 1 &lt;= coin &lt;= 5000 the number of coins is less than 500 the answer is guaranteed to fit into signed 32-bit integer Example 1: Input: amount = 5, coins = [1, 2, 5]Output: 4Explanation: there are four ways to make up the amount:5=55=2+2+15=2+1+1+15=1+1+1+1+1 Example 2: Input: amount = 3, coins = [2]Output: 0Explanation: the amount of 3 cannot be made up just with coins of 2. Example 3: Input: amount = 10, coins = [10]Output: 1 求解思路： 又是一道动态规划的题目，最近不知道为什么，老是把问题想的太过于复杂，比如change1中的解法，就是不好的方法，时间复杂度是O(amount*amount*size). 然后看了一下dicuss才知道还有时间复杂度更小的解法（其实就是最内层的循环是没必要的），然后是对空间复杂度进行了一下优化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution &#123;public: int change1(int amount, vector&lt;int&gt;&amp; coins) &#123; int size = coins.size(); if (amount == 0) return 1; if (size == 0) return 0; vector&lt;vector&lt;int&gt;&gt; dp(size + 1, vector&lt;int&gt;(amount + 1, 0)); dp[0][0] = 1; for(int i = 1;i &lt;= size;i++) &#123; dp[i][0] = 1; for(int j = 1;j &lt;= amount;j++) for(int t = j;t &gt;= 0;t-=coins[i-1]) dp[i][j] += dp[i-1][t]; &#125; return dp[size][amount]; &#125; int change2(int amount, vector&lt;int&gt;&amp; coins) &#123; int size = coins.size(); if (amount == 0) return 1; if (size == 0) return 0; vector&lt;vector&lt;int&gt;&gt; dp(size + 1, vector&lt;int&gt;(amount + 1, 0)); dp[0][0] = 1; for(int i = 1;i &lt;= size;i++) &#123; dp[i][0] = 1; for(int j = 1;j &lt;= amount;j++) &#123; dp[i][j] = dp[i-1][j]; if (coins[i-1] &lt;= j) dp[i][j] += dp[i][j-coins[i-1]]; &#125; &#125; return dp[size][amount]; &#125; int change(int amount, vector&lt;int&gt;&amp; coins) &#123; int size = coins.size(); if (amount == 0) return 1; if (size == 0) return 0; vector&lt;int&gt; dp(amount + 1, 0); dp[0] = 1; for(auto &amp;coin:coins) for(int j = 1;j &lt;= amount;j++) if (coin &lt;= j) dp[j] += dp[j-coin]; return dp[amount]; &#125; &#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Copy List with Random Pointer","slug":"Copy-List-with-Random-Pointer","date":"2018-02-28T10:12:58.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2018/02/28/Copy-List-with-Random-Pointer/","link":"","permalink":"http://blog.codeand.fun/2018/02/28/Copy-List-with-Random-Pointer/","excerpt":"","text":"题目是Copy List with Random Pointer: 题目描述： A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. 求解思路： 很直观的方法，用来O(n)的空间来保存地址，没想到过了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Definition for singly-linked list with a random pointer. * struct RandomListNode &#123; * int label; * RandomListNode *next, *random; * RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: RandomListNode *copyRandomList(RandomListNode *head) &#123; if(head == nullptr) return head; unordered_map&lt;RandomListNode *, RandomListNode *&gt; m; RandomListNode *p = head; RandomListNode copy(0); RandomListNode *q = &amp;copy; while(p) &#123; q-&gt;next = new RandomListNode(p-&gt;label); //auto it = m.find(p); //if (it != m.end()) it-&gt;second = q-&gt;next; m[p] = q-&gt;next; p = p-&gt;next; q = q-&gt;next; &#125; m[nullptr] = nullptr; p = head; q = copy.next; while(p) &#123; q-&gt;random = m[p-&gt;random]; p = p-&gt;next; q = q-&gt;next; &#125; return copy.next; &#125;&#125;; share一个dicuss中看到的方法： 图片失效的话，直接去leetcode中看原贴。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Delete and Earn","slug":"Delete-and-Earn","date":"2018-02-27T10:45:44.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2018/02/27/Delete-and-Earn/","link":"","permalink":"http://blog.codeand.fun/2018/02/27/Delete-and-Earn/","excerpt":"","text":"题目是Delete and Earn: 题目描述： Given an array nums of integers, you can perform operations on the array. In each operation, you pick any nums[i] and delete it to earn nums[i] points. After, you must delete every element equal to nums[i] - 1 or nums[i] + 1. You start with 0 points. Return the maximum number of points you can earn by applying such operations. Example 1: Input: nums = [3, 4, 2]Output: 6Explanation:Delete 4 to earn 4 points, consequently 3 is also deleted.Then, delete 2 to earn 2 points. 6 total points are earned. Example 2: Input: nums = [2, 2, 3, 3, 3, 4]Output: 9Explanation:Delete 3 to earn 3 points, deleting both 2’s and the 4.Then, delete 3 again to earn 3 points, and 3 again to earn 3 points.9 total points are earned. Note:The length of nums is at most 20000.Each element nums[i] is an integer in the range [1, 10000]. 求解思路： 一道动态规划的题目，动态规划的题目做多了之后感觉都有套路了，这道题算是比较简单的套路吧。 先对输入进行一下收集（其实只做排序也应该可以，但是感觉会比较复杂一点），然后对于一个数来说他有两种可能，一种是delete，一种是不delete，然后根据不同的状态来计算即可。 感觉可以用四个int来进行空间上的优化，但我没试 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: int deleteAndEarn(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) return 0; unordered_map&lt;int, int&gt; m; for(auto &amp;i:nums) m[i]++; vector&lt;pair&lt;int, int&gt; &gt; helper(m.begin(), m.end()); sort(helper.begin(), helper.end(), [](pair&lt;int, int&gt; &amp;p1,pair&lt;int, int&gt; &amp;p2) &#123; return p1.first &lt; p2.first; &#125;); //for(int i = 0;i &lt; helper.size(); i++) &#123; // cout &lt;&lt; helper[i].first &lt;&lt; helper[i].second &lt;&lt; endl; //&#125; vector&lt;int&gt; d(helper.size()+1, 0); //delete vector&lt;int&gt; nd(helper.size()+1, 0); // no delete d[1] = helper[0].first; for(int i = 1;i &lt; helper.size()+1;i++) &#123; // set d /* if (helper[i-1].first-1 == helper[i-2].first) &#123; d[i] = helper[i-1].first * helper[i-1].second + max(d[i-2], nd[i-2]); &#125; else d[i] = helper[i-1].first * helper[i-1].second + max(d[i-1], nd[i-1]); */ d[i] = helper[i-1].first * helper[i-1].second + ( (helper[i-1].first-1 == helper[i-2].first)?max(d[i-2], nd[i-2]):max(d[i-1], nd[i-1]) ); // set nd nd[i] = max(d[i-1], nd[i-1]); &#125; return max(d[helper.size()], nd[helper.size()]); &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Combination Sum II","slug":"Combination-Sum-II","date":"2018-02-26T14:22:23.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2018/02/26/Combination-Sum-II/","link":"","permalink":"http://blog.codeand.fun/2018/02/26/Combination-Sum-II/","excerpt":"","text":"第107天。 虽然前几天都有刷题，但是没写blog。 题目是Combination Sum II: 题目描述： Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. Each number in C may only be used once in the combination. Note: All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations. For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,A solution set is: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 求解思路： 显然是用回溯法来做了（也就是穷举），都成套路了，有一个难点就是这里要求不能重复，可能可以用set来做，这里采取的方法是先排序再回溯的方法。 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; ret; vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; sort(candidates.begin(), candidates.end(), [](int a, int b) &#123; return a &gt; b; &#125;); vector&lt;int&gt; temp; combinationSum2(candidates, 0, target, temp); return ret; &#125; bool combinationSum2(vector&lt;int&gt;&amp; candidates, int beg, int target, vector&lt;int&gt; temp) &#123; if (target == 0) &#123; // get a solution ret.push_back(temp); return true; &#125; for(int i = beg; i &lt; candidates.size() ; i++) &#123; if (candidates[i] &gt; target) continue; temp.push_back(candidates[i]); combinationSum2(candidates, i + 1, target - candidates[i], temp); while(i + 1 &lt; candidates.size() &amp;&amp; candidates[i] == candidates[i+1]) i++; temp.pop_back(); &#125; return false; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Delete Operation for Two Strings","slug":"delete-operation-for-two-strings","date":"2018-02-21T15:11:06.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2018/02/21/delete-operation-for-two-strings/","link":"","permalink":"http://blog.codeand.fun/2018/02/21/delete-operation-for-two-strings/","excerpt":"","text":"第106天。 今天的题目是Delete Operation for Two Strings: 题目描述： Given two words word1 and word2, find the minimum number of steps required to make word1 and word2 the same, where in each step you can delete one character in either string. Example 1: Input: “sea”, “eat”Output: 2Explanation: You need one step to make “sea” to “ea” and another step to make “eat” to “ea”. Note: The length of given words won’t exceed 500.Characters in given words can only be lower-case letters. 求解思路： 这道题和数据结构的最后一道附加题有点像，好像是附加题的操作是改变，而这里的是删除，然后当时的解法在这道题上AC尴尬，果然当时最后一题还是写错了吗，我就说为什么没拿到A+嘛。 思路比较简单（毕竟是考试的时候都能想出来的方法），只要知道最长公共子串就好了。拿题目给出的例子来说sea和eat的LCS是ea这样只要删掉s和t即可达到相同，有趣的是LSC是算法课讲动态规划时讲的。 1234567891011121314151617181920class Solution &#123;public: int minDistance(string word1, string word2) &#123; int l = LCS(word1, word2); return word1.size() + word2.size() - l - l; &#125; int LCS(string &amp;s1, string &amp;s2) &#123; vector&lt;vector&lt;int&gt;&gt; dp(s1.size() + 1, vector&lt;int&gt;(s2.size() + 1, 0)); for(int i = 1;i &lt; dp.size();i++) &#123; for(int j = 1;j &lt; dp[0].size(); j++) &#123; if (s1[i-1] == s2[j-1]) dp[i][j] = dp[i-1][j-1] + 1; else dp[i][j] = max(dp[i-1][j], dp[i][j-1]); &#125; &#125; return dp[s1.size()][s2.size()]; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Partition-List","slug":"Partition-List","date":"2018-02-20T10:27:31.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2018/02/20/Partition-List/","link":"","permalink":"http://blog.codeand.fun/2018/02/20/Partition-List/","excerpt":"","text":"第105天。 今天的题目是Patrition List: Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. For example,Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5. 一开始想复杂了，所以写的有点丑陋，主要的思想是，把一个链表划分成两个链表，一个大于，一个小于，然后在将他们拼接成一个链表即可： 123456789101112131415161718192021222324252627282930313233ListNode *less, *less_tail;ListNode *greater, *greater_tail;ListNode* partition1(ListNode* head, int x) &#123; less = new ListNode(-1); greater = new ListNode(-1); less_tail = less; greater_tail = greater; helper(head, x); //show(less); //show(greater); less_tail-&gt;next = greater-&gt;next; greater_tail-&gt;next = nullptr; less_tail = less-&gt;next; //less-&gt;next = greater-&gt;next = nullptr; delete less; delete greater; return less_tail;&#125;void helper(ListNode *head, int x) &#123; if (head == nullptr) return ; if (head-&gt;val &lt; x) &#123; less_tail-&gt;next = head; less_tail = less_tail-&gt;next; &#125; else &#123; greater_tail-&gt;next = head; greater_tail = greater_tail-&gt;next; &#125; helper(head-&gt;next, x);&#125; 然后简洁的解法： 123456789101112131415161718ListNode *partition(ListNode *head, int x) &#123; ListNode left(-1), right(-1); ListNode *l = &amp;left, *r = &amp;right; while(head) &#123; if (head-&gt;val &lt; x) &#123; l-&gt;next = head; l = l-&gt;next; &#125; else &#123; r-&gt;next = head; r = r-&gt;next; &#125; head = head-&gt;next; &#125; l-&gt;next = right.next; r-&gt;next = nullptr; return left.next;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Verify-Preorder-Serialization-of-a-Binary-Tree","slug":"Verify-Preorder-Serialization-of-a-Binary-Tree","date":"2018-02-19T11:54:41.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2018/02/19/Verify-Preorder-Serialization-of-a-Binary-Tree/","link":"","permalink":"http://blog.codeand.fun/2018/02/19/Verify-Preorder-Serialization-of-a-Binary-Tree/","excerpt":"","text":"第104天。 今天的题目是331. Verify Preorder Serialization of a Binary Tree: One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node’s value. If it is a null node, we record using a sentinel value such as #. 1234567 _9_ &#x2F; \\ 3 2 &#x2F; \\ &#x2F; \\ 4 1 # 6&#x2F; \\ &#x2F; \\ &#x2F; \\# # # # # # For example, the above binary tree can be serialized to the string “9,3,4,#,#,1,#,#,2,#,6,#,#”, where # represents a null node. Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree. Each comma separated value in the string must be either an integer or a character ‘#’ representing null pointer. You may assume that the input format is always valid, for example it could never contain two consecutive commas such as “1,,3”. Example 1:“9,3,4,#,#,1,#,#,2,#,6,#,#”Return true Example 2:“1,#”Return false Example 3:“9,#,#,1”Return false 虽然题目很长，但是理解起来并不难，就是给你一串字符串表示一棵二叉树，用,分隔节点的值，用#表示空指针，然后问你这个字符串能不能还原出来一棵二叉树（在不建树的情况下）,其实和建树很像，都是递归的去做： 123456789101112131415bool isValidSerialization(string preorder) &#123; int beg = 0; return isValidSerialization(preorder,beg) &amp;&amp; !next(preorder, beg);&#125;bool isValidSerialization(string preorder, int &amp;beg) &#123; if (beg &gt;= preorder.size()) return false; if (preorder[beg] == '#') return true; return next(preorder, beg) &amp;&amp; isValidSerialization(preorder, beg) &amp;&amp; next(preorder, beg) &amp;&amp; isValidSerialization(preorder, beg);&#125;bool next(string &amp;preorder, int &amp;beg) &#123; while(beg &lt; preorder.size() &amp;&amp; preorder[beg] != ',') beg++; beg++; return beg &lt; preorder.size();&#125; 然后是dicuss中的迭代版本： 12345678910111213bool isValidSerialization(string preorder) &#123; if (preorder.empty()) return false; preorder+=','; int sz=preorder.size(),idx=0; int capacity=1; for (idx=0;idx&lt;sz;idx++)&#123; if (preorder[idx]!=',') continue; capacity--; if (capacity&lt;0) return false; if (preorder[idx-1]!='#') capacity+=2; &#125; return capacity==0;&#125; Update at 2020-04-02 补充一个自己的写法： 12345678910bool isValidSerialization(string preorder) &#123; int i, c, size; for(i = 0, c = 1, size = preorder.size(); i &lt; size &amp;&amp; c; i++)&#123; if (preorder[i] == '#') c--; else c++; // c--; c+=2; // move next node while(i &lt; size &amp;&amp; preorder[i]!=',') i++; &#125; return c == 0 &amp;&amp; i &gt;= size;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"Stack","slug":"Stack","permalink":"http://blog.codeand.fun/tags/Stack/"}]},{"title":"Coin-Change","slug":"Coin-Change","date":"2018-02-19T01:57:40.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2018/02/19/Coin-Change/","link":"","permalink":"http://blog.codeand.fun/2018/02/19/Coin-Change/","excerpt":"","text":"第104天。 熬夜写的一道题。。。 今天的题目是Coin Change: You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Example 1:coins = [1, 2, 5], amount = 11return 3 (11 = 5 + 5 + 1) Example 2:coins = [2], amount = 3return -1. Note:You may assume that you have an infinite number of each kind of coin. 想到动态规划后就简单了,但是容易超时，超时的解法： 123456789101112131415int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; vector&lt;int&gt; dp(amount+1, INT_MAX); for(auto i:coins) if (i &lt;= amount) dp[i] = 1; dp[0] = 0; for(int i = 1;i &lt;= amount;i++) &#123; for(int j = 0;j &lt; i;j++) &#123; if (dp[j] != INT_MAX &amp;&amp; dp[i-j] != INT_MAX) dp[i] = min(dp[i], dp[j] + dp[i-j]); &#125; &#125; return dp[amount] == INT_MAX?-1:dp[amount];&#125; 这里的复杂度是O(amount^2)，当amount比较大的时候就跑不动了，修改成O(n*amount)后就能AC掉了： 12345678910111213141516171819int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; vector&lt;int&gt; dp(amount+1, INT_MAX); sort(coins.begin(), coins.end()); for(auto i:coins) if (i &lt;= amount) dp[i] = 1; dp[0] = 0; for(int i = 1;i &lt;= amount;i++) &#123; for(int j = 0;j &lt; coins.size(); j++) &#123; if (coins[j] &gt; i || dp[i - coins[j]] == INT_MAX) continue; dp[i] = min(dp[i], dp[i - coins[j]] + 1); &#125; &#125; return dp[amount] == INT_MAX?-1:dp[amount];&#125; dicuss中的解法类似，但是比较简洁： 12345678910111213int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; int Max = amount + 1; vector&lt;int&gt; dp(amount + 1, Max); dp[0] = 0; for (int i = 1; i &lt;= amount; i++) &#123; for (int j = 0; j &lt; coins.size(); j++) &#123; if (coins[j] &lt;= i) &#123; dp[i] = min(dp[i], dp[i - coins[j]] + 1); &#125; &#125; &#125; return dp[amount] &gt; amount ? -1 : dp[amount];&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"动态规划","slug":"动态规划","permalink":"http://blog.codeand.fun/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Unique-Binary-Search-Trees-II","slug":"Unique-Binary-Search-Trees-II","date":"2018-02-17T20:52:51.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2018/02/17/Unique-Binary-Search-Trees-II/","link":"","permalink":"http://blog.codeand.fun/2018/02/17/Unique-Binary-Search-Trees-II/","excerpt":"","text":"第103天。 今天的题目是95. Unique Binary Search Trees II: Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1…n. For example,Given n = 3, your program should return all 5 unique BST’s shown below. 123451 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\2 1 2 3 比较有趣的一道题目，主要是怎么穷举出所以的可能，一开始我是想着将问题从n减少到n-1这样来做，后来发现好像这样很难弄的样子，后来突然想到我们可以利用BST的性质，即对于当前节点来说，左子树的节点的值一定比当前节点的小，右子树的节点的值一定比当前节点的大，那么我们可以这样来做： 比如如果n = 3，那么这棵树就由[1,2,3]组成，那么先确定根节点的值，确定根节点后就可以确定左子树中可能出现的值，和右子树中可能出现的值，这样我们就能将问题简化并递归求解下去了： 看代码吧，其实这次代码比较简单： 123456789101112131415161718192021222324vector&lt;TreeNode*&gt; generateTrees(int n) &#123; return generateTrees(1,n);&#125;vector&lt;TreeNode *&gt; generateTrees(int beg, int end) &#123; vector&lt;TreeNode *&gt; ret; if (beg &gt; end) return ret; for(int i = beg;i &lt;= end;i++) &#123; vector&lt;TreeNode *&gt; left = generateTrees(beg, i-1); vector&lt;TreeNode *&gt; right = generateTrees(i+1, end); if (left.size() == 0) left.push_back(nullptr); if (right.size() == 0) right.push_back(nullptr); for(auto l:left) for(auto r:right) &#123; auto p = new TreeNode(i); p-&gt;left = l; p-&gt;right = r; ret.push_back(p); &#125; &#125; return ret;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"二叉树","slug":"二叉树","permalink":"http://blog.codeand.fun/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"Set-Matrix-Zeroes","slug":"Set-Matrix-Zeroes","date":"2018-02-16T21:32:14.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2018/02/16/Set-Matrix-Zeroes/","link":"","permalink":"http://blog.codeand.fun/2018/02/16/Set-Matrix-Zeroes/","excerpt":"","text":"第102天。 今天的题目是Set Matrix Zeroes: Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place. 虽然题目看起来很简单，但是还是有一些坑点的，因为你一检测到一个0就马上把它所在的行和列置零，这样会影响到后面检测零的操作（因为无法区分是否被修改过），所以一般都是先记录下0的位置或者需要置零的行和列，然后在进行置零。 这题的时间复杂度基本都是O(m*n),所以这里比较关注空间复杂度： 这里给出一个O(m+n)的解法： 123456789101112131415161718192021222324void setZeroes1(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if (matrix.size() == 0) return ; //O(m + n) vector&lt;bool&gt; row(matrix.size(),false); vector&lt;bool&gt; col(matrix[0].size(), false); //记录哪几行和哪几列需要置零 for(int i = 0;i &lt; matrix.size();i++) for(int j = 0;j &lt; matrix[0].size(); j++) if (matrix[i][j] == 0) row[i] = col[j] = true; //进行置0 for(int i = 0;i &lt; matrix.size();i++) if (row[i]) &#123; for(int j = 0;j &lt; matrix[0].size(); j++) matrix[i][j] = 0; &#125; for(int i = 0;i &lt; matrix[0].size();i++) if (col[i]) &#123; for(int j = 0;j &lt; matrix.size(); j++) matrix[j][i] = 0; &#125;&#125; 然后因为一行中只要有一个为0就可以直接对整行置零（还是先把整行扫描完的，不然某列本应该置零的却没有记录下来），所以我们可以在扫描一行的时候用一个flag来记录是否要置零，一旦扫完此行就马上置零，这样空间复杂度就减少成O(n): 12345678910111213141516171819202122232425void setZeroes2(vector&lt;vector&lt;int&gt;&gt; &amp;matrix) &#123; //O(n) if (matrix.size() == 0) return ; bool setzero; vector&lt;bool&gt; col(matrix[0].size(), false); for(int i = 0;i &lt; matrix.size();i++) &#123; setzero = false; for(int j = 0;j &lt; matrix[0].size();j++) &#123; if (matrix[i][j] == 0) &#123; setzero = true; col[j] = true; &#125; &#125; for(int j = 0;setzero &amp;&amp; j &lt; matrix[0].size();j++) &#123; matrix[i][j] = 0; &#125; &#125; for(int i = 0;i &lt; matrix[0].size();i++) &#123; if (col[i] == false) continue; for(int j = 0;j &lt; matrix.size(); j++) matrix[j][i] = 0; &#125;&#125; 然后题目上提到可以用O(1)的空间复杂度来实现，然后就是需要重用空间啦，这里重用第一行来实现： 12345678910111213141516171819202122232425262728void setZeroes(vector&lt;vector&lt;int&gt;&gt; &amp;matrix) &#123; int m = matrix.size(); if (m == 0) return ; int n = matrix[0].size(); //重用第一行来去掉额外的空间 bool setzero = false, raw0 = false; for(int i = 0;i &lt; n;i++) if (matrix[0][i] == 0) &#123; raw0 = true; break; &#125; for(int i = 1;i &lt; m;i++) &#123; setzero = false; for(int j = 0;j &lt; n;j++) if (matrix[i][j] == 0) &#123; setzero = true; matrix[0][j] = 0; &#125; for(int j = 0;setzero &amp;&amp; j &lt; n;j++) matrix[i][j] = 0; &#125; for(int i = 0;i &lt; n;i++) &#123; for(int j = 0;j &lt; m;j++) &#123; if (matrix[0][i] == 0) matrix[j][i] = 0; &#125; if (raw0) matrix[0][i] = 0; &#125;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Path-Sum-II","slug":"Path-Sum-II","date":"2018-02-15T20:40:34.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2018/02/15/Path-Sum-II/","link":"","permalink":"http://blog.codeand.fun/2018/02/15/Path-Sum-II/","excerpt":"","text":"第101天，新年快乐啊。 今天的题目是Path Sum-II: Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum. For example:Given the below binary tree and sum = 22, 1234567 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\7 2 5 1 return 1234[ [5,4,11,2], [5,8,4,5]] 比较简单，只贴代码咯： 123456789101112131415161718vector&lt;vector&lt;int&gt;&gt; ret;vector&lt;vector&lt;int&gt;&gt; pathSum1(TreeNode* root, int sum) &#123; vector&lt;int&gt; temp; pathSum(root, sum, temp); return ret;&#125;void pathSum(TreeNode *root, int sum, vector&lt;int&gt; &amp;temp) &#123; if (root == nullptr) return ; //cout &lt;&lt; root-&gt;val &lt;&lt; endl; temp.push_back(root-&gt;val); if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr &amp;&amp; sum == root-&gt;val) &#123; ret.push_back(temp); &#125; pathSum(root-&gt;left, sum - root-&gt;val, temp); pathSum(root-&gt;right, sum - root-&gt;val, temp); temp.pop_back();&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"二叉树","slug":"二叉树","permalink":"http://blog.codeand.fun/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"Flatten-Nested-List-Iterator","slug":"Flatten-Nested-List-Iterator","date":"2018-02-14T15:27:39.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2018/02/14/Flatten-Nested-List-Iterator/","link":"","permalink":"http://blog.codeand.fun/2018/02/14/Flatten-Nested-List-Iterator/","excerpt":"","text":"第100天。 今天的题目是flatten-Nested-List-Iterator: Given a nested list of integers, implement an iterator to flatten it. Each element is either an integer, or a list – whose elements may also be integers or other lists. Example 1:Given the list [[1,1],2,[1,1]], By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1]. Example 2:Given the list [1,[4,[6]]], By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6]. 挺有趣的题目，主要是要实现一个嵌套列表的迭代器，大概是三个函数： 1234567891011121314class NestedIterator &#123;public: NestedIterator(vector&lt;NestedInteger&gt; &amp;nestedList) &#123; &#125; int next() &#123; &#125; bool hasNext() &#123; &#125;&#125;; 然后他也提供了NestedInteger的接口和一些说明，算是对题目的补充： 123456789101112131415161718192021222324/** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * class NestedInteger &#123; * public: * // Return true if this NestedInteger holds a single integer, rather than a nested list. * bool isInteger() const; * * // Return the single integer that this NestedInteger holds, if it holds a single integer * // The result is undefined if this NestedInteger holds a nested list * int getInteger() const; * * // Return the nested list that this NestedInteger holds, if it holds a nested list * // The result is undefined if this NestedInteger holds a single integer * const vector&lt;NestedInteger&gt; &amp;getList() const; * &#125;; *//** * Your NestedIterator object will be instantiated and called as such: * NestedIterator i(nestedList); * while (i.hasNext()) cout &lt;&lt; i.next(); */ 从补充中我们可以看到，在调用next前一定会先调用hasNext,有了这个前提我们写起来会方便一点。 我的解法是，NestedIterator只保存构造函数中传入的nestedList的两个迭代器，之所以是两个，是因为要保存end迭代器，然后要实现嵌套，我们还要一个NestedIterator的指针，利用这个指针来对下一级列表的元素进行迭代： 123456789101112131415161718192021222324252627class NestedIterator &#123;public: NestedIterator(vector&lt;NestedInteger&gt; &amp;nestedList) &#123; _it = nestedList.begin(); _end_it = nestedList.end(); _tmp_it = nullptr; &#125; int next() &#123; if (_it-&gt;isInteger()) &#123; int ret = _it-&gt;getInteger(); ++_it; return ret; &#125; return _tmp_it-&gt;next(); &#125; bool hasNext() &#123; if (_it == _end_it) return false; if (_it-&gt;isInteger()) return true; if (_tmp_it == nullptr) &#123; _tmp_it = new NestedIterator(_it-&gt;getList()); &#125; if (_tmp_it-&gt;hasNext()) return true; delete _tmp_it; _tmp_it = nullptr; ++_it; return hasNext(); &#125;private: vector&lt;NestedInteger&gt;::iterator _it, _end_it; NestedIterator *_tmp_it;&#125;; 然后这里的实现虽然比较简单，简洁，但是在遇到一些特殊情况的时候会对性能造成极大的影响,比如说[[[[[1,2,3]]]]],虽然只有三个元素，但是因为有5层的嵌套，我们要有5个迭代器，每次调用next和hasNext都需要递归调用5次才能返回，这样效率就有点低了. dicuss中的解法会比较好一点，类别DFS来做，先用stack保存所有的元素，在调用hasNext的时候，如果栈顶是列表就将其展开并压栈（倒序），然后在递归调用hasNext，直到栈顶为数字时,然后调用next就直接返回栈顶即可： 1234567891011121314151617181920212223242526272829303132class NestedIterator &#123;public: NestedIterator(vector&lt;NestedInteger&gt; &amp;nestedList) &#123; begins.push(nestedList.begin()); ends.push(nestedList.end()); &#125; int next() &#123; hasNext(); return (begins.top()++)-&gt;getInteger(); &#125; bool hasNext() &#123; while (begins.size()) &#123; if (begins.top() == ends.top()) &#123; begins.pop(); ends.pop(); &#125; else &#123; auto x = begins.top(); if (x-&gt;isInteger()) return true; begins.top()++; begins.push(x-&gt;getList().begin()); ends.push(x-&gt;getList().end()); &#125; &#125; return false; &#125;private: stack&lt;vector&lt;NestedInteger&gt;::iterator&gt; begins, ends;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"k近邻算法","slug":"k近邻算法","date":"2018-02-13T22:21:27.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2018/02/13/k近邻算法/","link":"","permalink":"http://blog.codeand.fun/2018/02/13/k%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/","excerpt":"","text":"刚看了有关kNN的东西，总结一下： kNN算法（k-近邻算法）是一种可用于分类和回归的非参数统计方法。 分类算法：最近的k个邻居进行投票得到类别 回归算法：最近的k个邻居的平均数 这里只讨论分类算法。 先给个直观的理解，比如现在我们要判断一个人是男生还是女生，我们只考虑身高、体重这两个特征。显然如何两个人的身高体重越相近，那么他们的性别就越相近。kNN就是基于这个直观的想法来做的，如果我们要判断x是什么类别，我们就在train data中找出与x最相邻的k个数据，然后通过投票机制来觉得最后的分类。 这里我们就需要定义距离了： 简单的就用欧几里得距离（即L2距离）$\\sqrt((x_1 - y_1)^2 + … + (x_2 - y_2)^2)$ 给出demo代码（参考机器学习实战）： 12345678910111213141516def classify0(inX, dataSet, labels, k): dataSetSize = dataSet.shape[0] # 欧式距离计算 diffMat = np.tile(inX, (dataSetSize,1)) - dataSet sqDiffMat = diffMat**2 sqDistance = sqDiffMat.sum(axis=1) distances = sqDistance**0.5 #找出前k个距离最小的sample sortedDistIndicies = distances.argsort() # 这里返回的是indicies classCount = &#123;&#125; for i in range(k): voteIlabel = labels[sortedDistIndicies[i]] classCount[voteIlabel] = classCount.get(voteIlabel, 0) + 1 sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True) return sortedClassCount[0][0]","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://blog.codeand.fun/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"Decode-Ways","slug":"Decode-Ways","date":"2018-02-13T16:47:08.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2018/02/13/Decode-Ways/","link":"","permalink":"http://blog.codeand.fun/2018/02/13/Decode-Ways/","excerpt":"","text":"第99天。 今天的题目是Decode Ways: A message containing letters from A-Z is being encoded to numbers using the following mapping: 1234'A' -&gt; 1'B' -&gt; 2...'Z' -&gt; 26 Given an encoded message containing digits, determine the total number of ways to decode it. For example,Given encoded message “12”, it could be decoded as “AB” (1 2) or “L” (12). The number of ways decoding “12” is 2. 在店里面发呆的时候突然想到的解法，虽然当然当时没有想出完整解法，但是找到了思路（动态规划的题目就是这样，一旦意识到是动态规划后就简单多了）,这道题主要难在要意识到是动态规划比较难，毕竟是要倒着做动态规划的。 1234567891011121314151617181920int numDecodings(string s) &#123; if (s.size() == 0) return 0; int i = s.size() - 1; s.push_back('\\0'); vector&lt;int&gt; dp(s.size() + 1, 0); dp[i+1] = 1; for(; i &gt;= 0;i--) &#123; switch(s[i]) &#123; case '0': dp[i] = 0; break; case '1': dp[i] = dp[i+1] + dp[i+2]; break; case '2': if (s[i+1] &gt;= '0' &amp;&amp; s[i+1] &lt;= '6') &#123; dp[i] = dp[i+1] + dp[i+2]; break; &#125; default: dp[i] = dp[i+1]; &#125; &#125; return dp[0];&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"动态规划","slug":"动态规划","permalink":"http://blog.codeand.fun/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Reverse-Linked-List-II","slug":"Reverse-Linked-List-II","date":"2018-02-12T22:20:08.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2018/02/12/Reverse-Linked-List-II/","link":"","permalink":"http://blog.codeand.fun/2018/02/12/Reverse-Linked-List-II/","excerpt":"","text":"第98天。 今天的题目是Reverse Linked List II : Reverse a linked list from position m to n. Do it in-place and in one-pass. For example:Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4, return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL. Note:Given m, n satisfy the following condition:1 ≤ m ≤ n ≤ length of list. 之前做个一道翻转的题目了，所以这道题就比较简单了,想法和之前的一样，先从翻转整个链表开始考虑（也就是之前那道题目） 我们只需要把相邻节点间的箭头换个方向，比如说： 1-&gt;2就调整为1&lt;-2,有了这个想法后就简单多了： 123456789101112ListNode *reverse(ListNode *head) &#123; if (head == nullptr || head-&gt;next == nullptr) return head; ListNode *pre = nullptr; ListNode *cur = head; while(cur != nullptr) &#123; ListNode *t = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = t; &#125; return pre;&#125; 这个也是同理，只不过有些细节不一样罢了： 123456789101112131415161718192021222324252627ListNode* reverseBetween(ListNode* head, int m, int n) &#123; if (head == nullptr || head-&gt;next == nullptr) return head; if (m == n) return head; ListNode ret(0); ret.next = head; ListNode *pre = &amp;ret; int i = 1; for(;i &lt; m;i++) pre = pre-&gt;next; ListNode *cur = pre-&gt;next; ListNode *next = cur-&gt;next; for(;i &lt; n;i++) &#123; ListNode *t = next-&gt;next; next-&gt;next = cur; cur = next; next = t; &#125; pre-&gt;next-&gt;next = next; pre-&gt;next = cur; return ret.next;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"链表","slug":"链表","permalink":"http://blog.codeand.fun/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"Binary-Tree-Zigzag-Level-Order-Traversal","slug":"Binary-Tree-Zigzag-Level-Order-Traversal","date":"2018-02-11T22:45:59.000Z","updated":"2020-04-02T14:43:48.831Z","comments":true,"path":"2018/02/11/Binary-Tree-Zigzag-Level-Order-Traversal/","link":"","permalink":"http://blog.codeand.fun/2018/02/11/Binary-Tree-Zigzag-Level-Order-Traversal/","excerpt":"","text":"第97天。 今天的题目是Binary Tree Zigzag Level Order Traversal: Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between). For example:Given binary tree [3,9,20,null,null,15,7], 12345 3 / \\9 20 / \\ 15 7 return its zigzag level order traversal as: 12345[ [3], [20,9], [15,7]] 首先想到的是用层次遍历的方式来实现。 简单的层次遍历： 1234567891011void levelTra(TreeNode *root) &#123; if (root == nullptr) return ; queue&lt;TreeNode *&gt; q; q.push(root); while(!q.empty()) &#123; root = q.front(); q.pop(); cout &lt;&lt; root-&gt;val; if (root-&gt;left) q.push(root-&gt;left); if (root-&gt;right) q.push(root-&gt;right); &#125;&#125; 但是上面的方法是没法区分层数的，我们通过nullptr来表示换行： 12345678910111213141516171819void levelTra(TreeNode *root) &#123; if (root == nullptr) return ; queue&lt;TreeNode *&gt; q; q.push(root); q.push(nullptr); while(true) &#123; root = q.top(); q.pop(); if (root == nullptr) &#123; cout &lt;&lt; \"new level\" &lt;&lt; endl; if (q.empty()) break; q.push(nullptr); &#125; cout &lt;&lt; root-&gt;val &lt;&lt; endl; if (root-&gt;left) q.push(root-&gt;left); if (root-&gt;right) q.push(root-&gt;right); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt; &gt; ret; vector&lt;int&gt; tmp; if (root == nullptr) return ret; //level tra bool flag = true; //判断遍历方向 queue&lt;TreeNode *&gt; q; q.push(root); q.push(nullptr); while(true) &#123; root = q.front(); q.pop(); if (root == nullptr) &#123; if (flag) ret.push_back(tmp); else ret.push_back(vector&lt;int&gt;(tmp.rbegin(), tmp.rend())); tmp.clear(); flag = !flag; if (q.empty()) break; q.push(nullptr); continue; &#125; tmp.push_back(root-&gt;val); if (root-&gt;left) q.push(root-&gt;left); if (root-&gt;right) q.push(root-&gt;right); &#125; return ret;&#125; 然后是dicuss中的方法，简单的来说就是通过深度优先遍历来生成获取层次遍历的每层的数组（好像之前写过？），然后就会比前面用queue的方法快。 1234567891011121314151617181920void travel(TreeNode *root, vector&lt;vector&lt;int&gt; &gt; &amp;ret, int level) &#123; if (root == nullptr) return ; if (level &gt;= ret.size()) ret.push_back(vector&lt;int&gt;()); ret[level].push_back(root-&gt;val); travel(root-&gt;left, ret, level + 1); travel(root-&gt;right, ret, level + 1);&#125;vector&lt;vector&lt;int&gt; &gt; zigzagLevelOrder(TreeNode *root) &#123; vector&lt;vector&lt;int&gt;&gt; ret; travel(root, ret, 0); for(int i = 0;i &lt; ret.size();i++) &#123; if (i % 2) reverse(ret[i].begin(), ret[i].end()); &#125; return ret;&#125; Update as 2020-03-28 最近在总结 Stack Tag 的算法，然后发现这道题可以用双栈来解，和前面队列的做法有点类似，某种意义上也是在模拟层次遍历，但是因为栈后进先出的特性，所以很直接的实现了逆序的操作，不需要额外做reverse。 12345678910111213141516171819202122232425vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt; &gt; res; int level = 0; stack&lt;TreeNode*&gt; st_even, st_odd; if (root) st_even.push(root); while(!st_even.empty() || !st_odd.empty()) &#123; stack&lt;TreeNode*&gt; &amp;st1 = level % 2 == 0 ? st_even : st_odd; stack&lt;TreeNode*&gt; &amp;st2 = level % 2 == 0 ? st_odd : st_even; vector&lt;int&gt; temp; for(int i = 0, size = st1.size(); i &lt; size; i++) &#123; root = st1.top(); st1.pop(); temp.push_back(root-&gt;val); TreeNode *left = root-&gt;left, *right = root-&gt;right; if (level % 2) swap(left, right); if (left) st2.push(left); if (right) st2.push(right); &#125; //cout &lt;&lt; st1.size() &lt;&lt; \" \" &lt;&lt; st2.size() &lt;&lt; endl; res.push_back(temp); level++; &#125; return res;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"Tree","slug":"Tree","permalink":"http://blog.codeand.fun/tags/Tree/"},{"name":"Stack","slug":"Stack","permalink":"http://blog.codeand.fun/tags/Stack/"},{"name":"Queues","slug":"Queues","permalink":"http://blog.codeand.fun/tags/Queues/"},{"name":"BFS","slug":"BFS","permalink":"http://blog.codeand.fun/tags/BFS/"}]},{"title":"blog迁移","slug":"blog迁移","date":"2018-02-10T22:52:09.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2018/02/10/blog迁移/","link":"","permalink":"http://blog.codeand.fun/2018/02/10/blog%E8%BF%81%E7%A7%BB/","excerpt":"","text":"今天把hexo从win搬到了Deepin下，准备长期驻扎Deepin了。然后有几篇文章的时间有点不对了。。whatever，不管了。 这篇blog只是一个测试： $$ \\sum_{i=1}^n a_i = 0 $$","categories":[],"tags":[{"name":"杂事一堆","slug":"杂事一堆","permalink":"http://blog.codeand.fun/tags/%E6%9D%82%E4%BA%8B%E4%B8%80%E5%A0%86/"}]},{"title":"Search-a-2D-Matrix-II","slug":"Search-a-2D-Matrix-II","date":"2018-01-27T10:30:43.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2018/01/27/Search-a-2D-Matrix-II/","link":"","permalink":"http://blog.codeand.fun/2018/01/27/Search-a-2D-Matrix-II/","excerpt":"","text":"第96天。 今天的题目是Search a 2D Matrix II: Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted in ascending from left to right.Integers in each column are sorted in ascending from top to bottom.For example, Consider the following matrix: 1234567[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] Given target = 5, return true. Given target = 20, return false. 以前好像看过这道题，但是应该嫌麻烦没做，今天做了一下，感觉好像也不是很难的样子，二分查找的升级版（在2维情况下）： 12345678910111213141516171819202122bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; int n = matrix.size(); if (n == 0) return false; int m = matrix[0].size(); return searchMatrix(matrix,0,n-1,0,m-1,target);&#125;bool searchMatrix(vector&lt;vector&lt;int&gt; &gt; &amp;matrix, int xlow, int xhigh, int ylow, int yhigh, int target) &#123; //cout &lt;&lt; xlow &lt;&lt; \" \" &lt;&lt; xhigh &lt;&lt; endl // &lt;&lt; ylow &lt;&lt; \" \" &lt;&lt; yhigh &lt;&lt; endl; if (xlow &gt; xhigh || ylow &gt; yhigh) return false; int xmid = (xlow + xhigh)/2, ymid = (ylow + yhigh)/2; if (matrix[xmid][ymid] == target) return true; else if (matrix[xmid][ymid] &lt; target) return searchMatrix(matrix,xmid + 1, xhigh, ylow, yhigh,target) || searchMatrix(matrix,xlow, xhigh, ymid + 1, yhigh, target); else return searchMatrix(matrix, xlow, xmid-1, ylow, yhigh,target) || searchMatrix(matrix,xlow, xhigh, ylow, ymid-1, target);&#125; 为什么dicuss的解法大多都是: 12345678910111213141516bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; int i = 0; int j = matrix[0].size() - 1; while(i &lt; matrix.size() &amp;&amp; j &gt;= 0) &#123; if(matrix[i][j] == target) return true; if(matrix[i][j] &lt; target) i++; else j--; &#125; return false;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Same-Tree","slug":"Same-Tree","date":"2018-01-26T11:44:17.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2018/01/26/Same-Tree/","link":"","permalink":"http://blog.codeand.fun/2018/01/26/Same-Tree/","excerpt":"","text":"第95天。 今天的题目比较水。 今天的题目是Same Tree: Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. 太简单了，不做太多解释了: 123456bool isSameTree(TreeNode* p, TreeNode* q) &#123; if (p == nullptr &amp;&amp; q == nullptr) return true; else if (p &amp;&amp; q) &#123; return q-&gt;val == p-&gt;val &amp;&amp; isSameTree(p-&gt;left,q-&gt;left) &amp;&amp; isSameTree(p-&gt;right,q-&gt;right); &#125; else return false;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Nim-Game","slug":"Nim-Game","date":"2018-01-25T10:52:41.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2018/01/25/Nim-Game/","link":"","permalink":"http://blog.codeand.fun/2018/01/25/Nim-Game/","excerpt":"","text":"第94天。 今天的题目有点智障。。。 今天的题目是Nim Game: You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap. For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend. 很自然的想到用dp去做，然而时间超限了： 1234567891011bool canWinNim1(int n) &#123; if (n &lt;= 3) return true; vector&lt;bool&gt; dp(n+1,false); dp[1] = dp[2] = dp[3] = true; for(int i = 4;i &lt;= n;i++) &#123; dp[i] = !(dp[i-1] &amp;&amp; dp[i-2] &amp;&amp; dp[i-3]); // if (dp[i] == false) cout &lt;&lt; i &lt;&lt; \" \"; &#125; // cout &lt;&lt; endl; return dp[n];&#125; 把false的值输出来之后，发现，只要不是4的倍数就会赢。 123bool canWinNim(int n) &#123; return n % 4;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Construct-the-Rectangle","slug":"Construct-the-Rectangle","date":"2018-01-24T12:36:36.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2018/01/24/Construct-the-Rectangle/","link":"","permalink":"http://blog.codeand.fun/2018/01/24/Construct-the-Rectangle/","excerpt":"","text":"第93天。 今天的题目是Construct the Rectangle: For a web developer, it is very important to know how to design a web page’s size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements: The area of the rectangular web page you designed must equal to the given target area. The width W should not be larger than the length L, which means L &gt;= W. The difference between length L and width W should be as small as possible.You need to output the length L and the width W of the web page you designed in sequence.Example:Input: 4Output: [2, 2]Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1].But according to requirement 2, [1,4] is illegal; according to requirement 3, [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.Note:The given area won’t exceed 10,000,000 and is a positive integerThe web page’s width and length you designed must be positive integers. 比较简单的题目，但是题目有点长，总结一下就是，你要求出L,W满足一下条件： L, W is int L*W=Area L &gt;= W &gt; 0 min |L-W| 既然要使得|L-W|最小，那么显然，L=W=sqrt(Area)时，L-W是最小的，但是因为L和W限制成整数了,且sqrt(Area)不一定是整数，如果把它转换成int的话，L*W不一定等于Area了。所以我们必须调整L和W的值，简单的调整方法就是，如果L*W &lt; Area,我们就加大L之所以是加大L而不是加大W的原因是需要满足L &gt;= W，同理L*W &gt; Area时，我们就减小W。这样子我们始终会找到一个L,W满足上面的条件： 123456789101112vector&lt;int&gt; constructRectangle(int area) &#123; int L, W; int sqrt_a = sqrt(area); W = L = sqrt_a; int a = W*L; while(a != area) &#123; if (a &lt; area) L++; else if (a &gt; area) W--; a = W*L; &#125; return &#123;L, W&#125;;&#125; 然后dicuss中的解法更巧妙一点，我们只求W，然后L = Area/W： 12345public int[] constructRectangle(int area) &#123; int w = (int)Math.sqrt(area); while (area%w!=0) w--; return new int[]&#123;area/w, w&#125;;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Rotate-Image","slug":"Rotate-Image","date":"2018-01-23T12:28:20.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2018/01/23/Rotate-Image/","link":"","permalink":"http://blog.codeand.fun/2018/01/23/Rotate-Image/","excerpt":"","text":"第92天。 今天的题目是Rotate Image: You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note:You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Example 1: 12345678910111213Given input matrix = [ [1,2,3], [4,5,6], [7,8,9]],rotate the input matrix in-place such that it becomes:[ [7,4,1], [8,5,2], [9,6,3]] Example 2: 123456789101112131415Given input matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]], rotate the input matrix in-place such that it becomes:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] 虽然是一道Medium的题目，但是还是比较简单的。 主要的思路是一圈一圈的进行旋转，不断缩减，直到不需要旋转的时候： 123456789101112131415void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int beg = 0, end = matrix.size() - 1; int temp; while(beg &lt; end) &#123; int size = end - beg; for(int i = 0;i &lt; size;i++) &#123; temp = matrix[beg+i][beg]; matrix[beg+i][beg] = matrix[end][beg+i]; matrix[end][beg+i] = matrix[end-i][end]; matrix[end-i][end] = matrix[beg][end-i]; matrix[beg][end-i] = temp; &#125; beg++; end--; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Repeated-Substring-Pattern","slug":"Repeated-Substring-Pattern","date":"2018-01-22T10:54:49.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2018/01/22/Repeated-Substring-Pattern/","link":"","permalink":"http://blog.codeand.fun/2018/01/22/Repeated-Substring-Pattern/","excerpt":"","text":"第91天。 今天的题目是Repeated Substring Pattern: Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.Example 1:Input: “abab” Output: True Explanation: It’s the substring “ab” twice.Example 2:Input: “aba” Output: FalseExample 3:Input: “abcabcabcabc” Output: True Explanation: It’s the substring “abc” four times. (And the substring “abcabc” twice.) 一开始没看清，以为只有重复一次的情况，后来发现还可以重复多次，这样的话就不得不多扫描几遍了,有点希尔排序的解法： 1234567891011121314151617bool repeatedSubstringPattern1(string s) &#123; for(int i = 1;i &lt; s.size();i++) if (repeatedSubstringPattern(s,i)) return true; return false;&#125;bool repeatedSubstringPattern(string &amp;s,int p) &#123; // cout &lt;&lt; p &lt;&lt; endl; int size = s.size(); if (size % p) return false; for(int i = 0;i &lt; p;i++) &#123; for(int j = i+p;j &lt; size;j += p) &#123; //cout &lt;&lt; s[i] &lt;&lt; \" \" &lt;&lt; s[j] &lt;&lt; endl; if (s[i] != s[j]) return false; &#125; &#125; return true;&#125; 然后是在dicuss中的利用kmp的解法，但我还是没看懂为什么可以这样做。 12345678910bool repeatedSubstringPattern(string str) &#123; int i = 1, j = 0, n = str.size(); vector&lt;int&gt; dp(n+1,0); while( i &lt; str.size() )&#123; if( str[i] == str[j] ) dp[++i]=++j; else if( j == 0 ) i++; else j = dp[j]; &#125; return dp[n]&amp;&amp;dp[n]%(n-dp[n])==0;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Linked-List-Random-Node","slug":"Linked-List-Random-Node","date":"2018-01-21T10:45:53.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2018/01/21/Linked-List-Random-Node/","link":"","permalink":"http://blog.codeand.fun/2018/01/21/Linked-List-Random-Node/","excerpt":"","text":"第90天。 今天的题目是Linked List Random Node: Given a singly linked list, return a random node’s value from the linked list. Each node must have the same probability of being chosen. Follow up:What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space? Example: // Init a singly linked list [1,2,3].ListNode head = new ListNode(1);head.next = new ListNode(2);head.next.next = new ListNode(3);Solution solution = new Solution(head); // getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.solution.getRandom(); 写出了一个朴素的解法，两次扫描： 12345678910111213141516171819202122Solution(ListNode* p) &#123; len = 0; head = p; while(p) &#123; len++; p = p-&gt;next; &#125; cout &lt;&lt; len &lt;&lt; endl;&#125;/** Returns a random node's value. */int getRandom() &#123; int r = rand() % len; cout &lt;&lt; r &lt;&lt; endl; ListNode *p = head; while(r-- &amp;&amp; p) &#123; p = p-&gt;next; &#125; return p-&gt;val;&#125;int len;ListNode *head; 然后是利用栈来做的一个解法，即一直递归调用直到链表结尾，这时我们已经遍历了一遍链表就可以知道其长度了，在这时生成随机数，然后在递归调用返回的时候通过这个随机数来选取节点： 1234567891011121314151617181920212223int getRandom() &#123; temp_len = 0; getRandom(head); return res;&#125;bool getRandom(ListNode *p) &#123; if (p == nullptr) &#123; rand_n = rand() % temp_len; return false; &#125; temp_len++; if(getRandom(p-&gt;next)) return true; if (rand_n == 0) &#123; res = p-&gt;val; return true; &#125; rand_n--; return false;&#125;int temp_len;int rand_n;ListNode *head;int res; 最后是dicuss中的水库抽样法： 12345678910111213int getRandom() &#123; int res = head-&gt;val; ListNode* node = head-&gt;next; int i = 2; while(node)&#123; int j = rand()%i; if(j==0) res = node-&gt;val; i++; node = node-&gt;next; &#125; return res;&#125; 证明可参考：http://blog.csdn.net/so_geili/article/details/52937212","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Binary-Tree-Paths","slug":"Binary-Tree-Paths","date":"2018-01-20T10:24:03.000Z","updated":"2020-04-02T14:43:48.831Z","comments":true,"path":"2018/01/20/Binary-Tree-Paths/","link":"","permalink":"http://blog.codeand.fun/2018/01/20/Binary-Tree-Paths/","excerpt":"","text":"第89天。 今天的题目是Binary-Tree-Paths: Given a binary tree, return all root-to-leaf paths. For example, given the following binary tree: 1 / 2 3 5 All root-to-leaf paths are: [“1-&gt;2-&gt;5”, “1-&gt;3”] 比较的简单的题目，直接用递归做就好了，因为python写起来比较简单，所以这里用python实现： 1234567891011121314151617181920212223def binaryTreePaths(self, root): \"\"\" :type root: TreeNode :rtype: List[str] \"\"\" self.ret = [] if root is None: return self.ret s = [] self.binaryTreePathsRec(root,s) return self.retdef binaryTreePathsRec(self,root,s): if root is None: return s.append(str(root.val)) if root.left is None and root.right is None: self.ret.append('-&gt;'.join(s)) else: self.binaryTreePathsRec(root.left,s) self.binaryTreePathsRec(root.right,s) s.pop()","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Split-Linked-List-in-Parts","slug":"Split-Linked-List-in-Parts","date":"2018-01-19T11:34:09.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2018/01/19/Split-Linked-List-in-Parts/","link":"","permalink":"http://blog.codeand.fun/2018/01/19/Split-Linked-List-in-Parts/","excerpt":"","text":"第88天。 今天的题目是Split Linked List in Parts: Given a (singly) linked list with head node root, write a function to split the linked list into k consecutive linked list “parts”. The length of each part should be as equal as possible: no two parts should have a size differing by more than 1. This may lead to some parts being null. The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later. Return a List of ListNode’s representing the linked list parts that are formed. Examples 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 equal parts [ [1], [2], [3], [4], null ]Example 1:Input:root = [1, 2, 3], k = 5Output: [[1],[2],[3],[],[]]Explanation:The input and each element of the output are ListNodes, not arrays.For example, the input root has root.val = 1, root.next.val = 2, \\root.next.next.val = 3, and root.next.next.next = null.The first element output[0] has output[0].val = 1, output[0].next = null.The last element output[4] is null, but it’s string representation as a ListNode is [].Example 2:Input:root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]Explanation:The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.Note: The length of root will be in the range [0, 1000].Each value of a node in the input will be an integer in the range [0, 999].k will be an integer in the range [1, 50]. 虽然不难，但是自己还是做了一个早上，现在的效率真的是低的可以。 首先要知道每个块要有多少个节点就必须先知道总共有多少个节点，所以第一遍扫描算节点数肯定是少不了的，然后就可以开始算每个块的个数了。 k&gt;=n时，显然前n块只需要放一个就好了，后面的不用管。 k&lt;n时，可以分成两部分，前面的一部分比后面的一部分多放一个块，穷举几次可以知道，后面的部分每个快放n/k个节点，前面的部分有n%k个块。 其实到这里就可以发现其实并不需要分情况,第二种已经包括了第一种了。 12345678910111213141516171819202122vector&lt;ListNode*&gt; splitListToParts(ListNode* root, int k) &#123; int size = 0; for(ListNode *p = root;p != nullptr;p=p-&gt;next) size++; vector&lt;ListNode *&gt; ret(k,nullptr); int a = size/k; int b = size%k; ListNode *pre = nullptr; ListNode *p = root; for(int i = 0;i &lt; k &amp;&amp; p;i++) &#123; ret[i] = p; for(int j = 0;j &lt; a + (b&gt;0);j++) &#123; pre = p; p = p-&gt;next; &#125; b--; pre-&gt;next = nullptr; &#125; return ret;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Min-Cost-Climbing-Stairs","slug":"Min-Cost-Climbing-Stairs","date":"2018-01-18T09:47:16.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2018/01/18/Min-Cost-Climbing-Stairs/","link":"","permalink":"http://blog.codeand.fun/2018/01/18/Min-Cost-Climbing-Stairs/","excerpt":"","text":"第87天。 今天的题目是Min Cost Climbing Stairs： On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed). Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1. Example 1:Input: cost = [10, 15, 20]Output: 15Explanation: Cheapest is start on cost[1], pay that cost and go to the top.Example 2:Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]Output: 6Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].Note:cost will have a length in the range [2, 1000].Every cost[i] will be an integer in the range [0, 999]. 比较简单的动态规划题，emmm，爬楼梯的升级： 123456789int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123; cost.push_back(0); int n = cost.size(); vector&lt;int&gt; dp(n+2,0); for(int i = 2;i &lt; n+2;i++) &#123; dp[i] = min(dp[i-1],dp[i-2]) + cost[i-2]; &#125; return dp[n+1];&#125; 可以做一些简化: 12345678910int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123; int n = cost.size(); vector&lt;int&gt; dp(n,0); dp[0] = cost[0]; dp[1] = cost[1]; for(int i = 0;i &lt; n;i++) &#123; dp[i] = min(dp[i-1],dp[i-2]) + cost[i]; &#125; return min(dp[n-1],dp[n-2]);&#125; 甚至，如果cost可以修改的话，我们还可以把dp也省下来: 12345678int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123; int n = cost.size(); vector&lt;int&gt; &amp;dp = cost; for(int i = 0;i &lt; n;i++) &#123; dp[i] = min(dp[i-1],dp[i-2]) + cost[i]; &#125; return min(dp[n-1],dp[n-2]);&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"DP","slug":"DP","permalink":"http://blog.codeand.fun/tags/DP/"}]},{"title":"Rectangle-Area","slug":"Rectangle-Area","date":"2018-01-17T12:35:45.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2018/01/17/Rectangle-Area/","link":"","permalink":"http://blog.codeand.fun/2018/01/17/Rectangle-Area/","excerpt":"","text":"第86天。 今天的题目是Rectangle Area: Find the total area covered by two rectilinear rectangles in a 2D plane. Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.Assume that the total area is never beyond the maximum possible value of int. 一开始以为是求两个矩形重合部分的面积，后来仔细看了一下才发现是求它们的覆盖面积，好在把重合部分面积求出来后，求他们覆盖面积也比较简单，只需要先求出两个矩形的面积和之后再减去重合部分的面积就可以得到覆盖面积了。 123456789101112131415161718int area(int A,int B,int C,int D) &#123; return (C-A)*(D-B);&#125;int intersect(int A, int B, int C, int D, int E, int F, int G, int H) &#123; //求重合部分的面积 if (!check(A, B, C, D, E, F, G, H)) return 0; return min(min(C-E,G-A),min(G-E,C-A)) * min(min(D-F,H-B),min(D-B,H-F));&#125;int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) &#123; int a1 = area(A, B, C, D); int a2 = area(E, F, G, H); //cout &lt;&lt; a1 &lt;&lt; \" \" &lt;&lt; a2 &lt;&lt; endl; return a1- intersect(A, B, C, D, E, F, G, H) + a2;&#125;bool check(int A, int B, int C, int D, int E, int F, int G, int H) &#123; //判断是否重合 return ( abs(A+C-E-G) &lt;= (abs(A-C) + abs(G-E)) )&amp;&amp; (abs(B+D-F-H) &lt;= (abs(D-B) + abs(H-F))); &#125; 然后是dicuss中比较简洁的解法： 12345int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) &#123; int left = max(A,E), right = max(min(C,G), left); int bottom = max(B,F), top = max(min(D,H), bottom); return (C-A)*(D-B) - (right-left)*(top-bottom) + (G-E)*(H-F);&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Longest-Palindrome","slug":"Longest-Palindrome","date":"2018-01-16T09:28:28.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2018/01/16/Longest-Palindrome/","link":"","permalink":"http://blog.codeand.fun/2018/01/16/Longest-Palindrome/","excerpt":"","text":"第85天。 今天的题目是Longest Palindrome: Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters. This is case sensitive, for example “Aa” is not considered a palindrome here. Note:Assume the length of given string will not exceed 1,010. Example: Input:“abccccdd” Output:7 Explanation:One longest palindrome that can be built is “dccaccd”, whose length is 7. 这里有一点比较好玩的就是，他问的是能用这里字母组成的最长回文，所以他给的字符串顺序是不重要的，我们可以先用unordered_map先统计各个字母的个数，然后利用这些个数来计算即可。 先考虑回文长度是偶数的情况，一个字母要出现在回文中，就必须保证偶数个字母一起出现，这样的话我们就可以这样来计算了： 12for(auto &amp;p:wcount) ret += (p.second / 2); ret *= 2; 然后考虑奇数的情况，从它给的示例中我们很容易的发现，奇数的情况就是偶数的情况加一，当然也可能不加一，因为可以字母不够用。所以我们可以写出以下解法： 12345678int longestPalindrome(string s) &#123; unordered_map&lt;char,int&gt; wcount; for(auto &amp;c:s) wcount[c]++; int ret = 0; for(auto &amp;p:wcount) ret += (p.second / 2); ret *= 2; return (ret &lt; s.size())?ret+1:ret;&#125; 还可以更快一点，把除法和乘法去掉： 1234567int longestPalindrome(string s) &#123; unordered_map&lt;char,int&gt; wcount; for(auto &amp;c:s) wcount[c]++; int ret = 0; for(auto &amp;p:wcount) ret += ((p.second % 2)?p.second-1:p.second); return (ret &lt; s.size())?ret+1:ret;&#125; dicuss有一个解法比较有趣，他是通过数出现奇数次的字母来实现的： 123456int longestPalindrome(string s) &#123; int odds = 0; for (char c='A'; c&lt;='z'; c++) odds += count(s.begin(), s.end(), c) &amp; 1; return s.size() - odds + (odds &gt; 0);&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Remove-Duplicates-from-Sorted-Array","slug":"Remove-Duplicates-from-Sorted-Array","date":"2018-01-15T11:10:38.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2018/01/15/Remove-Duplicates-from-Sorted-Array/","link":"","permalink":"http://blog.codeand.fun/2018/01/15/Remove-Duplicates-from-Sorted-Array/","excerpt":"","text":"第84天。 All right,最终还是在期末考的时候断了。 今天的题目是Remove Duplicates from Sorted Array: Given a sorted array, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example: Given nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length. 明明是道水题，但是还是做了挺久的，而且效率也不高： 12345678910int removeDuplicates1(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); for(int i = size - 1;i &gt;= 1;i--) &#123; if (nums[i] == nums[i-1]) &#123; swap(nums[i],nums[--size]); &#125; &#125; sort(nums.begin(),nums.begin() + size); return size;&#125; 说他效率不高的原因就在于最后要做一次排序。 然后是dicuss中给出的O(n)的解法： 12345678int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() &lt;= 1) return nums.size(); int end = 1; for(int i = 1;i &lt; nums.size();i++) &#123; if (nums[i] != nums[i-1]) nums[end++] = nums[i]; &#125; return end;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Judge-Route-Cicle","slug":"Judge-Route-Cicle","date":"2017-12-19T08:20:43.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/12/19/Judge-Route-Cicle/","link":"","permalink":"http://blog.codeand.fun/2017/12/19/Judge-Route-Cicle/","excerpt":"","text":"第83天。 今天的题目是:Judge Route Circle: Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place. The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). The output should be true or false representing whether the robot makes a circle. Example 1:Input: “UD”Output: trueExample 2:Input: “LL”Output: false 比较无聊的一道题目,我们只需要维护一组下标来记录所在的位置即可，然后判断移动完后是否回到了最开始的位置即可： 123456789101112bool judgeCircle(string moves) &#123; int x = 0, y = 0; for(auto c:moves) &#123; switch(c)&#123; case 'U': y++; break; case 'D': y--; break; case 'L': x--; break; case 'R': x++; break; &#125; &#125; return x == 0 &amp;&amp; y == 0;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Intersection-of-Two-Arrays","slug":"Intersection-of-Two-Arrays","date":"2017-12-18T13:00:24.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/12/18/Intersection-of-Two-Arrays/","link":"","permalink":"http://blog.codeand.fun/2017/12/18/Intersection-of-Two-Arrays/","excerpt":"","text":"第82天。 今天的题目是Intersection of Two Arrays: Given two arrays, write a function to compute their intersection. Example:Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2]. Note:Each element in the result must be unique.The result can be in any order. 可以用排序做，也可以用hash做： 排序的做法： 1234567891011121314151617vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; sort(nums1.begin(),nums1.end()); sort(nums2.begin(),nums2.end()); auto beg1 = nums1.begin(); auto beg2 = nums2.begin(); vector&lt;int&gt; ret; while(beg1 &lt; nums1.end() &amp;&amp; beg2 &lt; nums2.end()) &#123; if (*beg1 == *beg2) &#123; int t = *beg1; ret.push_back(t); while(beg1 &lt; nums1.end() &amp;&amp; *beg1 == t) beg1++; while(beg2 &lt; nums2.end() &amp;&amp; *beg2 == t) beg2++; &#125; else if (*beg1 &lt; *beg2) beg1++; else beg2++; &#125; return ret;&#125; hash的做法： 1234567891011vector&lt;int&gt; intersection1(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; unordered_map&lt;int,int&gt; m; vector&lt;int&gt; ret; for(auto i:nums1) m[i]++; for(auto i:nums2) if (m.find(i) != m.end() &amp;&amp; m[i]) &#123; m[i] = 0; ret.push_back(i); &#125; return ret;&#125; dicuss还有用set做的: 12345678vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; set&lt;int&gt; s(nums1.begin(), nums1.end()); vector&lt;int&gt; out; for (int x : nums2) if (s.erase(x)) out.push_back(x); return out;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Remove-Element","slug":"Remove-Element","date":"2017-12-17T10:54:14.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/12/17/Remove-Element/","link":"","permalink":"http://blog.codeand.fun/2017/12/17/Remove-Element/","excerpt":"","text":"第81天。 今天的题目是Remove Element: Given an array and a value, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example: Given nums = [3,2,2,3], val = 3, Your function should return length = 2, with the first two elements of nums being 2. 简单的我们可以遍历数组，然后找到和val相同的元素，然后删除，但是这样对于多个相同的元素效率不高，所以我们先不删除元素，而是把他移动到最后面去，知道遍历完才删除。 12345678int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int last = nums.size(); for(int i = 0;i &lt; last;i++) &#123; if (nums[i] == val) swap(nums[--last],nums[i--]); &#125; nums.erase(nums.begin() + last,nums.end()); return nums.size();&#125; dicuss中另一个方法也很精妙： 12345int removeElement(int A[], int n, int elem) &#123; int begin=0; for(int i=0;i&lt;n;i++) if(A[i]!=elem) A[begin++]=A[i]; return begin;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Reverse-String","slug":"Reverse-String","date":"2017-12-16T19:36:01.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2017/12/16/Reverse-String/","link":"","permalink":"http://blog.codeand.fun/2017/12/16/Reverse-String/","excerpt":"","text":"第80天。 今天的题目是Reverse String: Write a function that takes a string as input and returns the string reversed. Example:Given s = “hello”, return “olleh”. 水的不能再水的题目. 1234567string reverseString(string s) &#123; int i = 0,j = s.size() - 1; while(i &lt; j) &#123; swap(s[i++],s[j--]); &#125; return s;&#125; 如果用python话： 123456def reverseString(self, s): \"\"\" :type s: str :rtype: str \"\"\" return s[::-1]","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"String","slug":"String","permalink":"http://blog.codeand.fun/tags/String/"}]},{"title":"Reverse-Words-in-a-String-III","slug":"Reverse-Words-in-a-String-III","date":"2017-12-15T09:29:55.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2017/12/15/Reverse-Words-in-a-String-III/","link":"","permalink":"http://blog.codeand.fun/2017/12/15/Reverse-Words-in-a-String-III/","excerpt":"","text":"第79天。 今天的题目是Reverse Words in a String III: Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. Example 1:Input: “Let’s take LeetCode contest”Output: “s’teL ekat edoCteeL tsetnoc”Note: In the string, each word is separated by single space and there will not be &gt; any extra space in the string. 用python的话就很简单了： 123456789def reverseWords(self, s): \"\"\" :type s: str :rtype: str \"\"\" words = s.split() for i in range(len(words)): words[i] = words[i][::-1] return ' '.join(words) 然后是dicuss中的c解法： 123456789101112131415161718192021void reverse(int b, int e, char *s)&#123; while(b &lt; e) &#123; s[b] = s[b] ^ s[e]; s[e] = s[b] ^ s[e]; s[b] = s[b] ^ s[e]; b++; e--; &#125;&#125;char* reverseWords(char* s) &#123; int i, s_len = strlen(s), index = 0; for(i = 0; i &lt;= s_len; i++) &#123; if((s[i] == ' ') || (s[i] == '\\0'))&#123; reverse(index, i - 1, s); index = i + 1; &#125; &#125; return s;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"String","slug":"String","permalink":"http://blog.codeand.fun/tags/String/"}]},{"title":"Intersection-of-Two-Arrays-II","slug":"Intersection-of-Two-Arrays-II","date":"2017-12-14T07:57:29.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/12/14/Intersection-of-Two-Arrays-II/","link":"","permalink":"http://blog.codeand.fun/2017/12/14/Intersection-of-Two-Arrays-II/","excerpt":"","text":"第78天。 又是hash,为什么每次都随机到hash. 今天的题目是Intersection of Two Arrays II: Given two arrays, write a function to compute their intersection. Example:Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2]. Note:Each element in the result should appear as many times as it shows in both arrays.The result can be in any order.Follow up:What if the given array is already sorted? How would you optimize your algorithm?What if nums1’s size is small compared to nums2’s size? Which algorithm is better?What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once? 和昨天的解法有点想,先遍历一个数组，用hash table进行计数，然后再遍历第二个数组，然后实时的更新hash table就好了： 123456789101112vector&lt;int&gt; intersec1t(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; unordered_map&lt;int,int&gt; m; for(auto i:nums1) m[i]++; vector&lt;int&gt; ret; for(auto i:nums2) &#123; if (m[i] != 0) &#123; ret.push_back(i); m[i]--; &#125; &#125; return ret;&#125; 还有就是可以用sort来做： 1234567891011121314vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; sort(nums1.begin(),nums1.end()); sort(nums2.begin(),nums2.end()); int i1,i2; vector&lt;int&gt; ret; for(i1=0,i2=0;i1 &lt; nums1.size() &amp;&amp; i2 &lt; nums2.size();) &#123; if (nums1[i1] == nums2[i2]) &#123; ret.push_back(nums1[i1]); i1++; i2++; &#125; else if (nums1[i1] &gt; nums2[i2]) i2++; else i1++; &#125; return ret;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Longest-Harmonious-Subsequence","slug":"Longest-Harmonious-Subsequence","date":"2017-12-13T11:22:16.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/12/13/Longest-Harmonious-Subsequence/","link":"","permalink":"http://blog.codeand.fun/2017/12/13/Longest-Harmonious-Subsequence/","excerpt":"","text":"第77天。 今天的题目是Longest Harmonious Subsequence: We define a harmonious array is an array where the difference between its maximum value and its minimum value is exactly 1. Now, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible subsequences. Example 1:Input: [1,3,2,2,5,2,3,7]Output: 5Explanation: The longest harmonious subsequence is [3,2,2,2,3].Note: The length of the input array will not exceed 20,000. 好像有是一个用hash做的题目： 1234567891011int findLHS(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int,int&gt; m; for(int i = 0;i &lt; nums.size();i++) m[nums[i]]++; int len = 0; for(auto &amp;p:m) &#123; if (m.count(p.first + 1) &gt; 0) len = max(len,p.second + m[p.first + 1]); &#125; return len;&#125; dicuss中有用sort做的： 123456789101112131415int findLHS(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(),nums.end()); int len = 0; for(int i = 1, start = 0, new_start = 0; i&lt;nums.size(); i++) &#123; if (nums[i] - nums[start] &gt; 1) start = new_start; if (nums[i] != nums[i-1]) new_start = i; if(nums[i] - nums[start] == 1) len = max(len, i-start+1); &#125; return len;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Length-of-Last-Word","slug":"Length-of-Last-Word","date":"2017-12-12T10:49:45.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/12/12/Length-of-Last-Word/","link":"","permalink":"http://blog.codeand.fun/2017/12/12/Length-of-Last-Word/","excerpt":"","text":"第76天。 快考试，可能要水一个月的easy题了。 今天的题目是Length of Last Word: Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. Example: Input: “Hello World”Output: 5 一看完题目，我就想到了python的split: 12345678def lengthOfLastWord(self, s): \"\"\" :type s: str :rtype: int \"\"\" words = s.split(); if len(words) == 0: return 0; return len(words[-1]) 然后是用c++用find去解的： 12345678910111213int lengthOfLastWord(string s) &#123; auto beg = s.begin(); auto it = beg; auto end = s.end(); // fix the bug like that \"hello world \" for(int i = s.size() - 1;i &gt;= 0 &amp;&amp; s[i] == ' ';i--) end--; while((it = find(beg,end,' ')) != end) &#123; beg = it + 1; &#125; return end - beg;&#125; 然后是从后面向前扫描的方法： 1234567int lengthOfLastWord(string s) &#123; auto end = s.rbegin(); while(end != s.rend() &amp;&amp; *end == ' ') end++; auto beg = end; while(beg != s.rend() &amp;&amp; *beg != ' ') beg++; return beg - end;&#125; 然后是dicuss中的解法，和上面的从后向前扫描的方法类似，只不过它第二个循环里面顺带计算了length: 123456789int lengthOfLastWord(string s) &#123; int len = 0, tail = s.length() - 1; while (tail &gt;= 0 &amp;&amp; s[tail] == ' ') tail--; while (tail &gt;= 0 &amp;&amp; s[tail] != ' ') &#123; len++; tail--; &#125; return len;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Maximum-Swap","slug":"Maximum-Swap","date":"2017-12-11T10:00:36.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/12/11/Maximum-Swap/","link":"","permalink":"http://blog.codeand.fun/2017/12/11/Maximum-Swap/","excerpt":"","text":"第75天。 今天的题目是Maximum Swap: Given a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get. Example 1:Input: 2736Output: 7236Explanation: Swap the number 2 and the number 7.Example 2:Input: 9973Output: 9973Explanation: No swap.Note:The given number is in the range [0, 10^8] 怎么说呢，写一个不优雅的解法还是挺简单的。 先把num分解成多个digit，然后尝试在找出最大的，如果最大的值和最高位不同，我们就交换，如果相同，我们就找出除去最高位的最大值，直到找不到能交换的，或者交换一次，我们就退出。 然后把digit按照对应的次序还原即可： 123456789101112131415161718192021222324int maximumSwap(int num) &#123; vector&lt;int&gt; t; while(num != 0) &#123; t.push_back(num % 10); num /= 10; &#125; int k = t.size() - 1; while(k &gt;= 0) &#123; auto max = max_element(t.begin(),t.begin() + k + 1); if (*max != t[k]) &#123; int a = *max; *max = t[k]; t[k] = a; break; &#125; k--; &#125; for(auto it = t.rbegin();it != t.rend();it++) &#123; num = 10 * num + *it; &#125; return num;&#125; 然后是dicuss中的解法,好像想法差不多。 12345678910111213141516171819202122int maximumSwap(int num) &#123; string numString = to_string(num); int n = numString.length(); vector&lt;int&gt; dpPosition(n, -1); int curMaxPos = n - 1; for (int i = n - 1; i &gt;= 0; i--) &#123; if (numString[i] &gt; numString[curMaxPos]) &#123; curMaxPos = i; &#125; dpPosition[i] = curMaxPos; &#125; for (int i = 0; i &lt; n; i++) &#123; if(numString[dpPosition[i]] != numString[i]) &#123; swap(numString[i], numString[dpPosition[i]]); break; &#125; &#125; return stoi(numString);&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Contains-Duplicate-II","slug":"Contains-Duplicate-II","date":"2017-12-10T11:22:34.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/12/10/Contains-Duplicate-II/","link":"","permalink":"http://blog.codeand.fun/2017/12/10/Contains-Duplicate-II/","excerpt":"","text":"第74天。 今天的题目是Contains Duplicate II: Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k. 显然这道题目可以用两个循环去实现，但是这样会超时，效率不高。 这里是用Hash Table去做的,key存储nums[i],value存储i,这样我们用O(n)的时间就可以完成了。 12345678bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) &#123; unordered_map&lt;int,int&gt; m; for(int i = 0;i &lt; nums.size();i++) &#123; if (m.find(nums[i]) != m.end() &amp;&amp; m[nums[i]] + k &gt;= i) return true; m[nums[i]] = i; &#125; return false;&#125; dicuss中的做法是用unordered_set去做的。 12345678910111213141516bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k)&#123; unordered_set&lt;int&gt; s; if (k &lt;= 0) return false; if (k &gt;= nums.size()) k = nums.size() - 1; for (int i = 0; i &lt; nums.size(); i++) &#123; if (i &gt; k) s.erase(nums[i - k - 1]); if (s.find(nums[i]) != s.end()) return true; s.insert(nums[i]); &#125; return false;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"Hash","slug":"Hash","permalink":"http://blog.codeand.fun/tags/Hash/"}]},{"title":"Lexicographical-Number","slug":"Lexicographical-Number","date":"2017-12-09T10:39:01.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/12/09/Lexicographical-Number/","link":"","permalink":"http://blog.codeand.fun/2017/12/09/Lexicographical-Number/","excerpt":"","text":"第73天。 今天的题目是Lexicographical Numbers: Given an integer n, return 1 - n in lexicographical order. For example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9]. Please optimize your algorithm to use less time and space. The input size may be as large as 5,000,000. emmm，lexicographical是字典序的意思。 首先，这种有规律的题目一般用递归来写会比较简单（但是可能会超时），我们先找出它的规律，在不到n的时候，没加入一个数字i,我们就要看i*10 ~ i*10 + 9是否小于n,如果小于我们就把它加入，然后在递归的进行判断。 有一点需要注意的就是，它是从1开始的，所以我们一开始就要尝试的把1 ~ 9加入，而不是0 ~ 9： 12345678910111213141516vector&lt;int&gt; lexicalOrder(int n) &#123; vector&lt;int&gt; ret; //lexicalOrder(ret,n,1); for(int i = 1;i &lt; 10 &amp;&amp; i &lt;= n;i++) &#123; ret.push_back(i); lexicalOrder(ret,n,i*10); &#125; return ret;&#125;void lexicalOrder(vector&lt;int&gt; &amp;vec,int n,int base) &#123; for(int i = 0;i &lt; 10;i++,base++) &#123; if (base &gt; n)&#123; return; &#125; vec.push_back(base); lexicalOrder(vec,n,10*base); &#125;&#125; 然后是在dicuss中看到的迭代解法： 1234567891011121314151617vector&lt;int&gt; lexicalOrder(int n) &#123; vector&lt;int&gt; res(n); int cur = 1; for (int i = 0; i &lt; n; i++) &#123; res[i] = cur; if (cur * 10 &lt;= n) &#123; cur *= 10; &#125; else &#123; if (cur &gt;= n) cur /= 10; cur += 1; while (cur % 10 == 0) cur /= 10; &#125; &#125; return res;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Find-Peak-Element","slug":"Find-Peak-Element","date":"2017-12-08T09:37:52.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/12/08/Find-Peak-Element/","link":"","permalink":"http://blog.codeand.fun/2017/12/08/Find-Peak-Element/","excerpt":"","text":"第72天。 今天的题目是Find Peak Element: A peak element is an element that is greater than its neighbors. Given an input array where num[i] ≠ num[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that num[-1] = num[n] = -∞. For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2. 显然这道题写出一个O(n)的解法很简单。 这里的用二分法去求解，可以用O(logn)解出，分和合两个步骤都是O(1)的时间复杂度。 1234567891011121314int findPeakElement(vector&lt;int&gt;&amp; nums) &#123; return findPeakElement(nums,0,nums.size() - 1);&#125;int findPeakElement1(vector&lt;int&gt; &amp;nums,int first,int last) &#123; if (first &gt; last) return -1; int mid = (first + last)/2; int a = 0; if ( (mid+1 == nums.size() || nums[mid] &gt; nums[mid + 1]) &amp;&amp; (mid-1 &lt; 0 || nums[mid] &gt; nums[mid-1]) ) return mid; int left = findPeakElement(nums,first,mid-1); if (left != -1) return left; return findPeakElement(nums,mid+1,last);&#125; 当然这不是最好的解法，这里其实是用二分查找去做的： 12345678910111213141516int findPeakElement(const vector&lt;int&gt; &amp;num) &#123; return Helper(num, 0, num.size()-1);&#125;int Helper(const vector&lt;int&gt; &amp;num, int low, int high)&#123; if(low == high) return low; else &#123; int mid1 = (low+high)/2; int mid2 = mid1+1; if(num[mid1] &gt; num[mid2]) return Helper(num, low, mid1); else return Helper(num, mid2, high); &#125;&#125; 或者 12345678910111213141516int findPeakElement(const vector&lt;int&gt; &amp;num) &#123; int low = 0; int high = num.size()-1; while(low &lt; high) &#123; int mid1 = (low+high)/2; int mid2 = mid1+1; if(num[mid1] &lt; num[mid2]) low = mid2; else high = mid1; &#125; return low;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Find-Bottom-Left-Tree","slug":"Find-Bottom-Left-Tree","date":"2017-12-07T09:01:56.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/12/07/Find-Bottom-Left-Tree/","link":"","permalink":"http://blog.codeand.fun/2017/12/07/Find-Bottom-Left-Tree/","excerpt":"","text":"第71天。 今天的题目是Find Bottom Left Tree Value: Given a binary tree, find the leftmost value in the last row of the tree. Example 1:Input: 2 / 1 3 Output:1Example 2:Input: 1 / \\ 2 3 / / \\ 4 5 6 / 7 Output:7Note: You may assume the tree (i.e., the given root node) is not NULL. 显然这可以用带高度的深度优先去做： 1234567891011121314151617181920212223int findBottomLeftValue(TreeNode *root,int &amp;height) &#123; if (root == nullptr) &#123; height = -1; return -1; &#125; if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) return root-&gt;val; int lefth,righth; lefth = righth = height + 1; int left = findBottomLeftValue(root-&gt;left,lefth); int right = findBottomLeftValue(root-&gt;right,righth); if (lefth &gt;= righth) &#123; height = lefth; return left; &#125; else&#123; height = righth; return right; &#125;&#125;int findBottomLeftValue(TreeNode* root) &#123; int h = 0; return findBottomLeftValue(root,h);&#125; 看起来就不优雅，而且很繁琐的样子,下面是dicuss中用广度优先去做的： 123456789101112public int findLeftMostNode(TreeNode root) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) &#123; root = queue.poll(); if (root.right != null) queue.add(root.right); if (root.left != null) queue.add(root.left); &#125; return root.val;&#125; 以及python版本： 12345def findLeftMostNode(self, root): queue = [root] for node in queue: queue += filter(None, (node.right, node.left)) return node.val","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Count-Numbers-with-Unique-Digits","slug":"Count-Numbers-with-Unique-Digits","date":"2017-12-06T11:14:01.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/12/06/Count-Numbers-with-Unique-Digits/","link":"","permalink":"http://blog.codeand.fun/2017/12/06/Count-Numbers-with-Unique-Digits/","excerpt":"","text":"第70天。 今天的题目是Count Numbers with Unique Digits: Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x &lt; 10^n. Example:Given n = 2, return 91. (The answer should be the total numbers in the range of 0 ≤ x &lt; 100, excluding [11,22,33,44,55,66,77,88,99]) 先解释一下题目，所谓的unique digits就是这个数字中不包含相同的数字。 理解到这个的话，我们就从n=2开始考虑。 其实只需要一点排列组合的知识就可以发现如果它是个2位数,那么就会有9*9,第一个之所以是9，是因为，0不能出现在最高位，后面的那个是就是因为他不能和前面那个数字相同。如果是个3位数，那就是9*9*8,那个8是因为不能和前面两位出现的数字。 然后其实我们这里只得出来n位数的情况，但是它要的范围是0 &lt; x &lt; 10^n。这样的话，如果n=3,我们就需要求出1位数的个数、2位数的个数、3位数的个数，然后他们的和就是答案了。 我们可以写成动态规划的形式： 1234567891011121314int countNumbersWithUniqueDigits(int n) &#123; int *dp = new int[n+1]; dp[0] = 1; int k = 9; int a = 9; for(int i = 1;i &lt;= n &amp;&amp; a &gt; 0;i++) &#123; dp[i] = k + dp[i-1]; k *= a; a--; &#125; int ret = dp[n]; delete dp; return ret;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"DP","slug":"DP","permalink":"http://blog.codeand.fun/tags/DP/"}]},{"title":"Trim-a-Binary-Search-Tree","slug":"Trim-a-Binary-Search-Tree","date":"2017-12-05T11:06:42.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2017/12/05/Trim-a-Binary-Search-Tree/","link":"","permalink":"http://blog.codeand.fun/2017/12/05/Trim-a-Binary-Search-Tree/","excerpt":"","text":"第69天。 今天的题目是Trim a Binary Search Tree: Given a binary search tree and the lowest and highest boundaries as L and R, trim the tree so that all its elements lies in [L, R] (R &gt;= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree. Example 1:Input: 1 / 0 2 L = 1 R = 2 Output: 1 \\ 2 Example 2:Input: 3 / 0 4 2 / 1 L = 1 R = 3 Output: 3 / 2 / 1 一开始没看到时二叉排序树，然后写的就有点复杂了： 12345678910111213TreeNode* trimBST(TreeNode* root, int L, int R) &#123; if (!root) return nullptr; root-&gt;left = trimBST(root-&gt;left,L,R); root-&gt;right = trimBST(root-&gt;right,L,R); if (root-&gt;val &gt;= L &amp;&amp; root-&gt;val &lt;= R) return root; else if (root-&gt;left != nullptr &amp;&amp; root-&gt;right != nullptr) &#123; auto p = root-&gt;left; while(p-&gt;left) p = p-&gt;left; p-&gt;left = root-&gt;right; return root-&gt;left; &#125; return (root-&gt;left)?root-&gt;left:root-&gt;right;&#125; 12345678TreeNode* trimBST(TreeNode* root, int L, int R) &#123; if (root == nullptr) return nullptr; if (root-&gt;val &lt; L) return trimBST(root-&gt;right,L,R); if (root-&gt;val &gt; R) return trimBST(root-&gt;left,L,R); root-&gt;left = trimBST(root-&gt;left,L,R); root-&gt;right = trimBST(root-&gt;right,L,R); return root;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Longest-Continuous-Increasing-Subsqeuence","slug":"Longest-Continuous-Increasing-Subsqeuence","date":"2017-12-04T13:19:31.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/12/04/Longest-Continuous-Increasing-Subsqeuence/","link":"","permalink":"http://blog.codeand.fun/2017/12/04/Longest-Continuous-Increasing-Subsqeuence/","excerpt":"","text":"第68天。 今天的题目是Longest Continuous Increasing Subsequence: Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarra y). Example 1:Input: [1,3,5,4,7]Output: 3Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3.Even though [1,3,5,7] is also an increasing subsequence, it’s not a continuous one where 5 and 7 are separated by 4.Example 2:Input: [2,2,2,2,2]Output: 1Explanation: The longest continuous increasing subsequence is [2], its length is 1.Note: Length of the array will not exceed 10,000. 题目比较简单，只需要遍历一遍所有元素，然后每次都比较它和它前面一个元素的大小即可： 123456789101112int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) return 0; int ret = 0; int a = 1; for(int i = 0;i + 1 &lt; nums.size();i++) if (nums[i] &lt; nums[i+1]) a++; else &#123; ret = max(a,ret); a = 1; &#125; return max(a,ret);&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Valid-Triangle-Number","slug":"Valid-Triangle-Number","date":"2017-12-03T10:26:32.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2017/12/03/Valid-Triangle-Number/","link":"","permalink":"http://blog.codeand.fun/2017/12/03/Valid-Triangle-Number/","excerpt":"","text":"第67天。 今天的题目是Valid Triangle Number: Given an array consists of non-negative integers, your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.Example 1:Input: [2,2,3,4]Output: 3Explanation:Valid combinations are:2,3,4 (using the first 2)2,3,4 (using the second 2)2,2,3Note:The length of the given array won’t exceed 1000.The integers in the given array are in the range of [0, 1000]. 莫名其妙的用一个O(n^3)的解法AC了: 123456789101112int triangleNumber(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(),nums.end()); int ret = 0; for(int i = 0;i &lt; nums.size();i++) &#123; for(int j = i + 1;j &lt; nums.size();j++) &#123; //nums[i] + num[j] &gt; a; for(int k = j+1;k &lt; nums.size() &amp;&amp; nums[i] + nums[j] &gt; nums[k];k++) ret++; &#125; &#125; return ret;&#125; 然后是dicuss中的O(n^2)的解法： 123456789101112131415public static int triangleNumber(int[] A) &#123; Arrays.sort(A); int count = 0, n = A.length; for (int i=n-1;i&gt;=2;i--) &#123; int l = 0, r = i-1; while (l &lt; r) &#123; if (A[l] + A[r] &gt; A[i]) &#123; count += r-l; r--; &#125; else l++; &#125; &#125; return count;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Binary-Tree-Right-Side-View","slug":"Binary-Tree-Right-Side-View","date":"2017-12-02T09:32:23.000Z","updated":"2020-04-02T14:43:48.831Z","comments":true,"path":"2017/12/02/Binary-Tree-Right-Side-View/","link":"","permalink":"http://blog.codeand.fun/2017/12/02/Binary-Tree-Right-Side-View/","excerpt":"","text":"第66天。 今天的题目是Binary Tree Right Side View: Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. For example:Given the following binary tree, 1 &lt;— / 2 3 &lt;— \\ 5 4 &lt;— You should return [1, 3, 4]. 挺有趣的题目。 简单的来讲，首先，我们肯定是要让右子树优先，然后还要保证在左子树比右子树高的情况下，它的节点也能被放到要返回的数组中。 要比较高度，我们就需要在遍历的时候带上一个height,然后我们从按右子树优先进行先序遍历，这样就可以保证上面两个条件满足了，那，现在就是要计算什么时候将节点加入数组了。 我们可以发现返回的数组的大小和树的高度是相同的，这样我们就可以通过当前节点的高度来决定是否要将值加入数组，又因为我们遍历的时候已经是右子树优先了，所以第一次遇到这个高度的节点的时候，我们就可以直接将其放入数组中。 1234567891011vector&lt;int&gt; rightSideView1(TreeNode* root) &#123; vector&lt;int&gt; ret; helper(root,0,ret); return ret;&#125;void helper(TreeNode *root,int height,vector&lt;int&gt; &amp;ret) &#123; if (root == nullptr) return ; if (height == ret.size()) ret.push_back(root-&gt;val); helper(root-&gt;right,height + 1,ret); helper(root-&gt;left,height+1,ret);&#125; 然后是dicuss中用层次遍历做的: 12345678910111213141516171819public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; // reverse level traversal List&lt;Integer&gt; result = new ArrayList(); Queue&lt;TreeNode&gt; queue = new LinkedList(); if (root == null) return result; queue.offer(root); while (queue.size() != 0) &#123; int size = queue.size(); for (int i=0; i&lt;size; i++) &#123; TreeNode cur = queue.poll(); if (i == 0) result.add(cur.val); if (cur.right != null) queue.offer(cur.right); if (cur.left != null) queue.offer(cur.left); &#125; &#125; return result;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"Tree","slug":"Tree","permalink":"http://blog.codeand.fun/tags/Tree/"}]},{"title":"Swaps-Nodes-in-Pairs","slug":"Swaps-Nodes-in-Pairs","date":"2017-12-01T13:24:36.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2017/12/01/Swaps-Nodes-in-Pairs/","link":"","permalink":"http://blog.codeand.fun/2017/12/01/Swaps-Nodes-in-Pairs/","excerpt":"","text":"第65天。 今天的题目是Swap Nodes in Pairs: Given a linked list, swap every two adjacent nodes and return its head. For example,Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. 和之前做的链表翻转有点像，可以用指针的指针来做： 123456789101112131415bool swap(ListNode **head) &#123; if (*head == nullptr || ( *head)-&gt;next == nullptr) return false; ListNode *p = *head; ListNode *next = p-&gt;next; p-&gt;next = next-&gt;next; next-&gt;next = p; *head = next; return true;&#125;ListNode* swapPairs(ListNode* head) &#123; ListNode **p = &amp;head; while(swap(p)) p=&amp;((*p)-&gt;next-&gt;next); return head;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"ListNode","slug":"ListNode","permalink":"http://blog.codeand.fun/tags/ListNode/"}]},{"title":"Convert Sorted Array to Binary Search Tree","slug":"Convert-Sorted-Array-to-Binary-Search-Tree","date":"2017-11-30T18:08:21.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/11/30/Convert-Sorted-Array-to-Binary-Search-Tree/","link":"","permalink":"http://blog.codeand.fun/2017/11/30/Convert-Sorted-Array-to-Binary-Search-Tree/","excerpt":"","text":"第64天。 要死了，天天晚睡早起的，今天一定要早睡晚起（或者等下就睡睡先） 今天的题目是Convert Sorted Array to Binary Search Tree: Given an array where elements are sorted in ascending order, convert it to a height balanced BST. 这道题其实一开始没有思路的，感觉很难搞的样子，但是今天数据结构课上讲二分查找时提到了二分查找树（好像是这个名字），然后就觉得好像它就是一个height balanced BST. 然后就仿照二分查找的递归算法解出了这道题，其实就是二分查找的逆过程： 1234567891011TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; return sortedArrayToBST(nums,0,nums.size() - 1);&#125;TreeNode *sortedArrayToBST(vector&lt;int&gt; &amp;nums,int low,int high) &#123; if (low &gt; high) return nullptr; int mid = (low + high)/2; TreeNode *root = new TreeNode(nums[mid]); root-&gt;left = sortedArrayToBST(nums,low,mid-1); root-&gt;right = sortedArrayToBST(nums,mid+1,high); return root;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Path-Sum","slug":"Path-Sum","date":"2017-11-29T12:50:19.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/11/29/Path-Sum/","link":"","permalink":"http://blog.codeand.fun/2017/11/29/Path-Sum/","excerpt":"","text":"第63天。 赶算法实验，再水一题。 今天的题目是Path Sum: Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. For example:Given the below binary tree and sum = 22, 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1 return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22. 比较简单，但是有一些坑点。 它要求一定要到left. 然后空节点不能当成0. 然后是代码： 1234567bool hasPathSum(TreeNode* root, int sum) &#123; if (!root ) return false; if (!root-&gt;left &amp;&amp; !root-&gt;right) return sum == root-&gt;val; if (!root-&gt;left) return hasPathSum(root-&gt;right,sum-root-&gt;val); if (!root-&gt;right) return hasPathSum(root-&gt;left,sum - root-&gt;val); return hasPathSum(root-&gt;left,sum - root-&gt;val) || hasPathSum(root-&gt;right,sum - root-&gt;val);&#125; 其实dicuss中的更精炼一点： 12345bool hasPathSum(TreeNode *root, int sum) &#123; if (root == NULL) return false; if (root-&gt;val == sum &amp;&amp; root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) return true; return hasPathSum(root-&gt;left, sum-root-&gt;val) || hasPathSum(root-&gt;right, sum-root-&gt;val);&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"Tree","slug":"Tree","permalink":"http://blog.codeand.fun/tags/Tree/"}]},{"title":"Plus-One","slug":"Plus-One","date":"2017-11-28T22:52:56.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/11/28/Plus-One/","link":"","permalink":"http://blog.codeand.fun/2017/11/28/Plus-One/","excerpt":"","text":"第62天。 今天很不在状态啊，明明是课最少的一天，却把那么多事拖到了晚上。 今天的题目是Plus One: Given a non-negative integer represented as a non-empty array of digits, plus one to the integer. You may assume the integer do not contain any leading zero, except the number 0 itself. The digits are stored such that the most significant digit is at the head of the list. 比较简单的一道的题目，就是给你一个数组来表示一个数字，而且又不没有负数什么的，只需要从后往前遍历一遍，对当前元素进行加一再模上10，如果变成了0,那么说明有进位，我们继续遍历，如果不是0,说明后面的元素都没有改变，直接返回即可。 然后需要考虑的就是99这种类型，因为他本来是用两个数字即可表示,但是加一后需要3个数字： 12345678vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; for(auto it = digits.rbegin();it != digits.rend();it++) &#123; *it = (*it + 1) % 10; if (*it != 0) return digits; &#125; if (*digits.begin() == 0) digits.insert(digits.begin(),1); return digits;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Single Number III","slug":"Single-Number-III","date":"2017-11-27T12:23:09.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2017/11/27/Single-Number-III/","link":"","permalink":"http://blog.codeand.fun/2017/11/27/Single-Number-III/","excerpt":"","text":"第61天。 今天的题目是Single Number III: Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. For example: Given nums = [1, 2, 1, 3, 2, 5], return [3, 5]. Note:The order of the result is not important. So in the above example, [5, 3] is also correct.Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity? 在求解这个问题之前，我们先考虑一下简化后的问题，如果只有一个Single Number的话，我们要怎么求解。 如果熟悉异或运算的话，就很快的想出解决办法，这里用到了三个性质： 0^a = a a^a = 0 a^b^a = b 假设现在序列有个数，分别为n1,n2,n2...nk,我们将它们异或起来：t = n1^n2^n3^...^nk,因为中间只有一个single number,所以t中只有一个数不能因为a^a = 0而消除掉。因此t就是这个序列中的single number. 这是只有一个single number的情况，如果我们用类似的方法去做这道题的话，我们会得到t = a1^a2,但是显然我们无法快速的将a1和a2分解出来，除非我们知道其中一个数。 那我们能不能把序列分成两部分来做，每部分都包含一个single number且其余的数都包含两个，我们可以从bit的角度来考虑，如果某个位（比如说最低位）为1,那我们就将它分到第一部分，否则我们就将它分到第二部分，这样的方法可以很好的区分除了single number之外的数（因为两个single number可能分到相同的部分）。现在的问题就是我们要怎么将两个single number分到不同部分。 现在我们已经有了t = a1^a2,异或的定义是不同的bit为1,相同的bit为0,所以说t中为1的bit位（总是可以找到）可以作为我们上面那个算法的区分点了。 然后现在就是找出t中一个为1的bit了，简单的可以遍历去做，比较只有32位，所以时间复杂度是O(1)的，但是我们有一个更快的方法：t &amp; (t-1)可以将第一个为1的bit位清0,然后我们再异或上原来的t,我们就可以得到对应的mask了。 12345678vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123; int t = 0; for(auto i:nums) t ^= i; int lastBit = (t &amp; (t-1)) ^ t; int a = 0; for(auto i:nums) if (i&amp;lastBit) a^=i; return &#123;a,a^t&#125;;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"Bit-Manipulation","slug":"Bit-Manipulation","permalink":"http://blog.codeand.fun/tags/Bit-Manipulation/"}]},{"title":"The-Learning-Problem","slug":"The-Learning-Problem","date":"2017-11-26T15:17:47.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2017/11/26/The-Learning-Problem/","link":"","permalink":"http://blog.codeand.fun/2017/11/26/The-Learning-Problem/","excerpt":"","text":"最近看完了Machine-Learning-Foundations的第一个单元，做一个下总结吧。 humman learning acquiring skill with experience accumulated from observation即 observation -&gt; learning -&gt; skill machine learning: auquiring skill with experience accumulated/computed from data skill &lt;=&gt; improve some performance measuresoMachine Learning: improving some performance measure with experience computed from data. The key essence of Machine Learning: exists some underlying pattern can be improved but no programmable (easy) definition somehow there is data about pattern. 形式化机器学习： Input: $x \\in X$ Output: $y \\in Y$ target-func: $X-&gt;Y$ the target-func &lt;=&gt; unknown pattern to be learned. data &lt;=&gt; traning example &lt;=&gt; $D = { (x_1,y_1),(x_2,y_2),… }$ hypothesis &lt;=&gt; skill with hopefully good example. Machine Learning: use data to compute hypothesis g that approximates target f.","categories":[{"name":"Machine-Learning","slug":"Machine-Learning","permalink":"http://blog.codeand.fun/categories/Machine-Learning/"}],"tags":[{"name":"Machine-Learning","slug":"Machine-Learning","permalink":"http://blog.codeand.fun/tags/Machine-Learning/"}]},{"title":"杂记-2017-11-26","slug":"杂记-2017-11-26","date":"2017-11-26T14:40:57.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2017/11/26/杂记-2017-11-26/","link":"","permalink":"http://blog.codeand.fun/2017/11/26/%E6%9D%82%E8%AE%B0-2017-11-26/","excerpt":"","text":"2017-11-26 悠闲的下午（其实只是不想写作业，不想背单词）我觉得写一篇blog来总结一下，毕竟已经过去了大半个学期。 这学期课很多，收获也很多。 从9月份的某一天开始，每天刷LeetCode,每天写Blog,每天背单词。 说实话，习惯的力量真的很强大，其实每天刷道题这种想法早在上学期就有了，但是没错做几天就放弃了，最可怕的是一放弃，再次拿起来的时候就是下一次开始了。 不知道是不是因为这次每天都会写blog来记录刷题的过程，所以一直有个激励，虽然说有时候会因为做题而花很多时间（而且我的课又多），有时候也会因为没有时间而不得不找一道水题来做，不过即使是水题，换成暑假的我估计也做不出来，而且像dp的问题，之前是怎么都想不出来的，现在也慢慢的有了思路。 这种解决问题能力的提升算得上是这学期最大的收获了吧！ 还有一些其他的，比如说上了一门大四的课（虽然个人感觉难度并没有大三的某些课难），进入冯老师的实验室做ML,虽然我什么都不会，恩，一点一点的学吧。 说了那么多好的事情，总要反省一下： 至今没有养成好好看书的好习惯（好像这学期忙到课本都没好好看了） Machine Learning 还菜的要死，虽然现在师兄师姐们不嫌弃（不知道是不是真的不嫌弃），但是还是要好好赶上去啊 一直没能好好锻炼身体，希望身体不要虚下去（这种时候一生病就惨咯） 恩，以后每天晚上都要去自习室学习Machine Learning的东西，每天都要把学到的东西总结一下。（等下就总结之前学的东西） 恍恍惚惚的好像大三又过去了一半，虽然已经决定读研了，但是感觉还是看不清未来的样子，也不知道之后会遇到什么，成为什么，whaterver,慢慢的走下去吧。","categories":[{"name":"杂事一堆","slug":"杂事一堆","permalink":"http://blog.codeand.fun/categories/%E6%9D%82%E4%BA%8B%E4%B8%80%E5%A0%86/"}],"tags":[]},{"title":"House-Robber-III","slug":"House-Robber-III","date":"2017-11-26T09:08:22.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/11/26/House-Robber-III/","link":"","permalink":"http://blog.codeand.fun/2017/11/26/House-Robber-III/","excerpt":"","text":"第60天。 今天的题目是House Robber III： The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night. Determine the maximum amount of money the thief can rob tonight without alerting the police. Example 1: 3 / \\ 2 3 \\ 3 1 Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.Example 2: 3 / \\ 4 5 / \\ 1 3 1 Maximum amount of money the thief can rob = 4 + 5 = 9. 之前有刷过House robber,上次是一道dp的题目，这次看起来有点像是dp的题目，但是其实不是。 我们考虑当前节点root,我们有两种选择： 不偷root:这意味着我们对root的孩子没有限制（即可以偷也可以不偷）。 偷root：这意味着我们不能偷root的孩子。 从上面的分析可以看出，对于一个节点，我们可能需要返回两个值，一个是偷了root所得到的money,一个是不偷root所得到的money.我们可以用一个结构体来表示: 1234typedef struct &#123; int rob; int norob;&#125;Ret; 假设我们现在得到了root左孩子和右孩子的Ret了，我们现在要构建root本身的Ret.显然rob = left.norob + right.norob + root-&gt;val.然后还有norob,这个很容易就写成norob = left.rob + right.rob,这样写就假定了rob &gt; norob的，在上面的分析中，我们是说我们对root的孩子没有限制，既然没有限制，就可以偷也可以不偷，所以norob = max(left.rob,left.norob) + max(right.rob,right.norob). 12345678910111213int rob(TreeNode* root) &#123; Ret ret = robRec(root); return max(ret.rob,ret.norob);&#125;Ret robRec(TreeNode *root) &#123; Ret ret = &#123;0,0&#125;; if (root == nullptr) return ret; Ret left = robRec(root-&gt;left); Ret right = robRec(root-&gt;right); ret.rob = left.norob + right.norob + root-&gt;val; ret.norob = max(left.rob,left.norob) + max(right.rob,right.norob); return ret;&#125; dicuss中的解法大都是这个思路，只是写法不同而已，有一个写法比较有趣： 1234567891011121314public int rob(TreeNode root) &#123; if (root == null) return 0; return Math.max(robInclude(root), robExclude(root));&#125;public int robInclude(TreeNode node) &#123; if(node == null) return 0; return robExclude(node.left) + robExclude(node.right) + node.val;&#125;public int robExclude(TreeNode node) &#123; if(node == null) return 0; return rob(node.left) + rob(node.right);&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"Tree","slug":"Tree","permalink":"http://blog.codeand.fun/tags/Tree/"}]},{"title":"Merge Two Binary Trees","slug":"Merge-Two-Binary-Trees","date":"2017-11-25T11:20:57.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/11/25/Merge-Two-Binary-Trees/","link":"","permalink":"http://blog.codeand.fun/2017/11/25/Merge-Two-Binary-Trees/","excerpt":"","text":"第59天。 今天早上vpn挂了，然后好像学校IP有出现了点问题（貌似被人列入黑名单了）然后就一直出现One more step进行验证，最烦的是这个验证需要翻个墙，然后我就用手机开的wifi来写的题。 今天的题目是Merge Two Binary Trees: Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree. Example 1:Input: Tree 1 Tree 2 1 2 / \\ / \\ 3 2 1 3 / \\ \\ 5 4 7 Output:Merged tree: 3 / \\ 4 5 / \\ \\ 5 4 7 Note: The merging process must start from the root nodes of both trees. 挺简单的问题，对于两个root,大致可以分为4种情况： t1 = nullptr and t2 == nullptr: 直接返回nullptr t1 == nullptr and t2 != nullptr: new 一个新的节点ret ret-&gt;val = t2-&gt;val ret-&gt;left = mergeTrees(t1,t2-&gt;left) ret-&gt;right = mergeTree(t1,t2-&gt;right) t1 != nullptr and t2 == nullptr: 与上面类似 t1 != nullptr and t2 != nullptr: new 一个新的节点ret ret-&gt;val = t1-&gt;val + t1-&gt;val ret-&gt;left = mergeTrees(t1-&gt;left,t2-&gt;left) ret-&gt;right = mergeTrees(t1-&gt;right,t2-&gt;right) 12345678910TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) &#123; if (!t1 &amp;&amp; !t2) return nullptr; TreeNode * ret = new TreeNode(0); ret-&gt;val = ((t2)?t2-&gt;val:0) + ((t1)?t1-&gt;val:0); ret-&gt;left = mergeTrees((t1)?t1-&gt;left:t1 ,(t2)?t2-&gt;left:t2); ret-&gt;right = mergeTrees((t1)?t1-&gt;right:t1 ,(t2)?t2-&gt;right:t2); return ret;&#125; 如果可以不管使用t1和t2的空间的话，可以更简单一点： 12345678TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) &#123; if (!t1) return t2; if (!t2) return t1; TreeNode *ret = new TreeNode(t1-&gt;val + t2-&gt;val); ret-&gt;left = mergeTrees(t1-&gt;left,t2-&gt;left); ret-&gt;right = mergeTrees(t1-&gt;right,t2-&gt;right); return ret;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"Tree","slug":"Tree","permalink":"http://blog.codeand.fun/tags/Tree/"}]},{"title":"Diameter of Binary Tree","slug":"Diameter-of-Binary-Tree","date":"2017-11-24T08:58:25.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/11/24/Diameter-of-Binary-Tree/","link":"","permalink":"http://blog.codeand.fun/2017/11/24/Diameter-of-Binary-Tree/","excerpt":"","text":"第58天。 今天的题目是Diameter of Binary Tree: Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. Example:Given a binary tree 1 / \\ 2 3 / \\ 4 5 Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3]. Note: The length of path between two nodes is represented by the number of edges between them. 很显然，题目已经给出提示了,这个path要么经过root要么不经过root. 如果经过root,那么就是左子树和右子树的高度之和加上2.如果不经过root,就是左子树的diameter或者是右子树的diameter. 那么如何分辨是否经过root呢？ 其实也很简单，反正就要求最大的嘛，我们就把两种情况都算一遍，然后求个max即可。大概可以写出一下递推式： 1234leftH = heightOfHeight(root-&gt;left)rightH = heightOrHeight(root-&gt;right)d = diameterOfBinaryTree(root-&gt;left) + diameterOfBinaryTree(root-&gt;right)return max(d,leftH+rightH+2) 然后我们发现求高度也是类似的需要递归的方式，所以我们可以将他们合并起来： 12345678910111213141516int diameterOfBinaryTree(TreeNode* root) &#123; int h; return diameterOfBinaryTree(root,h);&#125;int diameterOfBinaryTree(TreeNode *root,int &amp;height) &#123; if (root == nullptr) &#123; height = -1; return 0; &#125; int leftH,rightH; int leftD = diameterOfBinaryTree(root-&gt;left,leftH); int rightD = diameterOfBinaryTree(root-&gt;right,rightH); height = max(leftH,rightH) + 1; return max(leftH + rightH + 2,max(leftD,rightD) );&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"Tree","slug":"Tree","permalink":"http://blog.codeand.fun/tags/Tree/"}]},{"title":"Counting Bits","slug":"Counting-Bits","date":"2017-11-23T12:03:11.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/11/23/Counting-Bits/","link":"","permalink":"http://blog.codeand.fun/2017/11/23/Counting-Bits/","excerpt":"","text":"第57天。 今天的题目是Counting Bits: Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array. Example:For num = 5 you should return [0,1,1,2,1,2]. Follow up: It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?Space complexity should be O(n).Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language. 和昨天的题目有点联系。 我们知道要求一个数的二进制表示中1的个数大概需要O(1)的时间，但这里的O(1)其实是O(sizeof(integer)).这里的题目上要求直接用O(n)的算法，而不是O(n*sizeof(int))的算法，这说明我们不能用昨天的算法来对每个数进行求解，我们必须找到一个规律来快速的算出来。 尝试把0~16二进制表示中1的个数算出来： 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 160 1 1 2 1 2 2 3 1 2 2 3 2 3 3 4 1 可以观察到0-1的值和2-3的值刚好差1，4-7的值和0-4的值刚好差1，同样的8-16的值和0-7的值刚好差。 因此，我们可以写出一下递推式： numCount[i] = numCount[i-k] 其中k表示i只保留最高位的1时所代表的数。 比如说i=20时，20的二进制表示是10100,则k的二进制位10000,即16. 知道这个之后，我们就可以很容易的求解出来： 123456789vector&lt;int&gt; countBits(int num) &#123; vector&lt;int&gt; ret(num+1,0); int k = 1; for(int i = 1;i &lt;= num;i++) &#123; if (i == k&lt;&lt;1) k&lt;&lt;=1; ret[i] = ret[i - k] + 1; &#125; return ret;&#125; dicuss中有一些更精妙的递推式： 123456vector&lt;int&gt; countBits(int num) &#123; vector&lt;int&gt; ret(num+1, 0); for (int i = 1; i &lt;= num; ++i) ret[i] = ret[i&amp;(i-1)] + 1; return ret;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"DP","slug":"DP","permalink":"http://blog.codeand.fun/tags/DP/"}]},{"title":"Hamming Distance","slug":"Hamming-Distance","date":"2017-11-22T19:38:40.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/11/22/Hamming-Distance/","link":"","permalink":"http://blog.codeand.fun/2017/11/22/Hamming-Distance/","excerpt":"","text":"第56天。 刷道水题Hamming Distance: The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. Note:0 ≤ x, y &lt; 231. Example: Input: x = 1, y = 4 Output: 2 Explanation:1 (0 0 0 1)4 (0 1 0 0)_ ↑ ↑The above arrows point to positions where the corresponding bits are different. 所谓的humming distance就是两个数在bit位上不同的个数，就int来说，最多就是全部不相同，也就是每个bit位都不一样，即humming distance. 我们可以利用异或来很快的求出来，异或可以让bit位不相同时置1，相同时置0.则两数异或后所得到的数中有bit位中1的个数就是humming distance: 123456789int hammingDistance(int x, int y) &#123; int t = x^y; int ret = 0; while(t!=0) &#123; ret += (t&amp;1); t &gt;&gt;= 1; &#125; return ret;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Find the Duplicate Number","slug":"Find-the-Duplicate-Number","date":"2017-11-21T13:17:18.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/11/21/Find-the-Duplicate-Number/","link":"","permalink":"http://blog.codeand.fun/2017/11/21/Find-the-Duplicate-Number/","excerpt":"","text":"第55天。 今天的题目是Find the Duplicate Number: Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Note:You must not modify the array (assume the array is read only).You must use only constant, O(1) extra space.Your runtime complexity should be less than O(n2).There is only one duplicate number in the array, but it could be repeated more than once. 一开始，没看到说要用O(1)的空间复杂度，就直接用计数的方法去写了： 12345678int findDuplicate1(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; count(nums.size(),0); for(auto i:nums) &#123; count[i]++; if (count[i]&gt;1) return i; &#125; return -1;&#125; 然后是后来想了很久，想着利用异或的方法去做，就是先将nums中的数字进行异或，然后在对[1,n]的数字进行异或，然后就直接是答案了，但是这种问题要限定在重复数字只重复一次的情况下，即需要保证[1:n]的数字都存在： 12345678910int findDuplicate2(vector&lt;int&gt;&amp; nums) &#123; int t = 0; int n = nums.size() - 1; for(auto i:nums) &#123; t ^= i; &#125; for(int i = 1;i &lt;= n;i++) t ^= i; return t;&#125; 最后。。。最后就实在想不出了，只好去看dicuss了： 他是用了一个List Cycle中找环点的方式，这里的链表中的nxet就是用nums的值来表示的。 123456789101112131415int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int slow = n; int fast = n; do &#123; slow = nums[slow-1]; fast = nums[nums[fast-1]-1]; &#125;while(slow != fast); slow = n; while(slow != fast) &#123; slow = nums[slow - 1]; fast = nums[fast - 1]; &#125; return slow;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Perfect Squares","slug":"Perfect-Squares","date":"2017-11-20T12:31:22.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/11/20/Perfect-Squares/","link":"","permalink":"http://blog.codeand.fun/2017/11/20/Perfect-Squares/","excerpt":"","text":"第54天。 今天的题目是Perfect-Squares: Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, …) which sum to n. For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9. 这道题一开始看到还挺懵的，首先，它是需要用square number来做加法的，那我是不是要先判断一个数是不是一个square number,简单的思路就是将所有不大于n的square number生成出来，直接比较即可，假设我们就是用这样的方法，那么现在我们可能就有了所有不大于n的square number的序列。 然后继续回到原来的问题，我好像是不需要求出这个表达式是由什么数组成的，而是只需要求出这个表达式由多少个Square number组成的就好了，这有点像动态规划的问题，我们用动态规划的思路去想这个问题： 我们要求numSquares(n)，我们可以先尝试的假定这个表达式中有一个1,那么就可以写成numSquares(n) = numSquares(n-1)+1,那如果我们假定这个表达式中有一个4,那么就可以写成是numSquares(n) = numSquares(n-4)+1,我们可以按照这样思路写出这样的递推式： numSquares(n) = Min{numSquares(n-k) + 1 | k is square number and k &lt;= n} 这样的话，我们就可以写出这样的表达式： 123456789101112131415def numSquares(self, n): \"\"\" :type n: int :rtype: int \"\"\" dp = [sys.maxsize]*(n+1) dp[0] = 0 for i in range(1,n+1): j = 1 t = j**2 while t &lt;= i: dp[i] = min(dp[i],dp[i-t]+1) j+=1 t = j**2 return dp[-1] 很不幸，这样的方法会在6000之后的数据中超时，然后想了一早上的方式去优化，后来用c++去实现了一遍，然后。。。就过来，花了那么久的时间竟然因为语言的问题而一直解决不了。。。算了，以后还是用c++写吧，反正有时候用python,写的也很乱，还不如c++简洁： 123456789101112int numSquares(int n) &#123; vector&lt;int&gt; dp(n+1,INT_MAX); dp[0] = 0; int t; for(int i = 1;i &lt;= n;i++) &#123; for(int j=1;(t = j*j) &lt;= i;j++)&#123; dp[i] = min(dp[i],dp[i-t]+1); &#125; //cout &lt;&lt; dp[i] &lt;&lt; endl; &#125; return dp[n];&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"DP","slug":"DP","permalink":"http://blog.codeand.fun/tags/DP/"}]},{"title":"House Robber","slug":"House-Robber","date":"2017-11-19T11:07:15.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/11/19/House-Robber/","link":"","permalink":"http://blog.codeand.fun/2017/11/19/House-Robber/","excerpt":"","text":"第53天。 今天的题目是House Robber: You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. 题目很长，大概的意思是给你一组非负数，代表每个房间中有的金额，你可以去任意一个房间取钱，但是不能在两个相邻的房间取，求出能取出的最大金额。 一开始想的很简单，直接在单数号的房间取或者在双数号的房间取，这样的话，我就取了最多次，只要遍历求个和即可，然而这样会有一个问题，例如序列是这样的[2,1,1,2],这样的话，应该是取第一个房间和最后一个房间才对。 突然觉得好像很难求出来才是，因为可能性太多了，而且也不好构造这种可能性，突然想到这会不会是一道dp的题目，然后用dp的思路去想。 如果有k个房间可以取钱，那么是不是对于第k个房间就只有两种可能，即取或不取： 取，那么k-1我们就不能取了，我们只能取k-2个房间的钱，问题转换成求前k-2个房间能取多少 不取，那么问题变成了求前k-1个房间能不能取。 我们可以得到以下递推式： rob(nums,k) = max(rob(num,k-1),rob(nums,k-2) + nums[k]) 这样我们就可以很轻松的写出： 123456789def rob1(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" dp = [0]*(len(nums)+2) for i in range(len(nums)): dp[i+2] = max(dp[i+1],dp[i]+nums[i]) return dp[-1] 很显然我们可以将空间复杂度从O(n)降到O(1): 1234567891011def rob2(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" #dp = [0]*(len(nums)+2) dp1,dp2,dp3 = 0,0,0 for i in nums: dp3 = max(dp2,dp1+i) dp1,dp2 = dp2,dp3 return dp3 我们还可以在减少一点，但是时间复杂度还是O(1): 12345678910def rob(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" #dp = [0]*(len(nums)+2) dp1,dp2 = 0,0 for i in nums: dp1,dp2 = dp2,max(dp2,dp1+i) return dp2","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Course-Schedule","slug":"Course-Schedule","date":"2017-11-18T16:35:54.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/11/18/Course-Schedule/","link":"","permalink":"http://blog.codeand.fun/2017/11/18/Course-Schedule/","excerpt":"","text":"第52天。 昨晚去见了一下一起做东西的研究生师兄师姐们，感觉很nice,不嫌弃我什么都不会还教了我很多东西，恩，等下开始学机器学习的东西。 今天的题目是Course Schedule: There are a total of n courses you have to take, labeled from 0 to n - 1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? For example: 2, [[1,0]]There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible. 2, [[1,0],[0,1]]There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.Note:The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.You may assume that there are no duplicate edges in the input prerequisites. 这个问题可以转化成——有向图是否有环路。 这里是使用拓扑排序做的.拓扑排序是只能在有向无环图中进行排序，如果它有环，那么它进会出错，我们对这个图进行一次拓扑排序就可以知道这个图是不是有环了。 一开始是使用维护一个入度的数组，然后通过不断删除入度为0点的方式来完成拓扑排序的，但是超时了，所以这里用DFS的方法来实现，而且这种方法还比之前的要简单。 原本的DFS需要一个visited，来表示某个节点是否被访问了，这里扩展一下visited，原本的visited只有两个状态：被访问了，未被访问。这里加入一个新的状态访问中,这里用-1来表示。 之所以要加入这个状态，是因为我们需要判断这个图是否有环路。让我们看个例子。 我们尝试着对这个图进行一次DFS: 123423-&gt;8-&gt;9-&gt;105-&gt;117 从上面我们可以知道这个图，需要四次调用DFS的递归函数才能完成整个遍历，我们认为如果某个节点在某次递归中，那么它的状态就是访问中,也就是说在第二次调用DFS的递归函数时如果访问了3,8节点，准备访问9节点时，3,8就是被访问状态，一旦访问完所以节点（也就是访问完10,这是在这条链路中所以节点都被访问了，递归函数开始返回，然后我们可以依次把10,9,8,3的设为已访问的状态。 讲了那么多，如果定义访问中状态，好像还没有提到他的用处，还是刚才的例子，如果上图加上一个9-&gt;3的边，那么我们是不是在访问9时，发现他可以通向一个访问中的节点（即3节点)，这时说明他们之间必定有回路。 大概的思路就是这样吧，其实看代码会简单一点： 1234567891011121314151617181920212223242526272829def helper(self,v,visited,graph): visited[v] = -1 #设置为访问中 for i in graph[v]: if visited[i] == -1: #访问中 return False if visited[i] == 0: #未访问 if self.helper(i,visited,graph) == False: return False visited[v] = 1 # 递归函数开始返回了，设置为已访问的状态 return Truedef canFinish(self, numCourses, prerequisites): \"\"\" :type numCourses: int :type prerequisites: List[List[int]] :rtype: bool \"\"\" visited = [0]*numCourses #初始时，所有节点都未访问 #将边集转化成邻接表 graph = [[] for i in range(numCourses)] for e in prerequisites: graph[e[0]].append(e[1]) #DFS for i in range(numCourses): if visited[i] == False: if self.helper(i,visited,graph) == False: return False return True dicuss中的BFS解法： 12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool canFinish(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) &#123; vector&lt;unordered_set&lt;int&gt;&gt; graph = make_graph(numCourses, prerequisites); vector&lt;int&gt; degrees = compute_indegree(graph); for (int i = 0; i &lt; numCourses; i++) &#123; int j = 0; for (; j &lt; numCourses; j++) if (!degrees[j]) break; if (j == numCourses) return false; degrees[j] = -1; for (int neigh : graph[j]) degrees[neigh]--; &#125; return true; &#125;private: vector&lt;unordered_set&lt;int&gt;&gt; make_graph(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) &#123; vector&lt;unordered_set&lt;int&gt;&gt; graph(numCourses); for (auto pre : prerequisites) graph[pre.second].insert(pre.first); return graph; &#125; vector&lt;int&gt; compute_indegree(vector&lt;unordered_set&lt;int&gt;&gt;&amp; graph) &#123; vector&lt;int&gt; degrees(graph.size(), 0); for (auto neighbors : graph) for (int neigh : neighbors) degrees[neigh]++; return degrees; &#125;&#125;; 好像就是我一开始做的那种想法，但是为什么我的又没通过。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"图","slug":"图","permalink":"http://blog.codeand.fun/tags/%E5%9B%BE/"}]},{"title":"Implement Trie(Prefix Tree)","slug":"Implement-Trie-Prefix-Tree","date":"2017-11-17T09:47:05.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/11/17/Implement-Trie-Prefix-Tree/","link":"","permalink":"http://blog.codeand.fun/2017/11/17/Implement-Trie-Prefix-Tree/","excerpt":"","text":"第51天。 今天的题目是Implement Trie (Prefix Tree): Implement a trie with insert, search, and startsWith methods. Note:You may assume that all inputs are consist of lowercase letters a-z. Tire也就是前缀树，也叫字典树。 它大概是是这样子的： 除了root节点以外，每个节点都有一个字符。 从根节点到某个节点（可以不是叶子节点）的一条路径表示一个字符串。 对于某个节点其孩子节点的字符不唯一 从上图可以看出每个节点都可以唯一对应一个字符串，即使每个节点只存放一个字符，但是root节点到这个节点的路径可以唯一确定一个字符串。 既然说它是前缀树，那肯定和前缀有关啦。两个节点所代表的字符串用公共前缀，那么root节点到他们的路径肯定有公共路径。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class TrieNode: def __init__(self): \"\"\" Initialize the TireNode. \"\"\" self.child = &#123;&#125; self.count = 0class Trie: def __init__(self): \"\"\" Initialize your data structure here. \"\"\" self.root = TrieNode() def insert(self, word): \"\"\" Inserts a word into the trie. :type word: str :rtype: void \"\"\" p = self.root for c in word: q = p.child.get(c,None) if q is None: p.child[c] = TrieNode() q = p.child[c] p = q p.count += 1 def search(self, word): \"\"\" Returns if the word is in the trie. :type word: str :rtype: bool \"\"\" p = self.root for c in word: q = p.child.get(c,None) if q is None: return False p = q return p.count &gt; 0 def startsWith(self, prefix): \"\"\" Returns if there is any word in the trie that starts with the given prefix. :type prefix: str :rtype: bool \"\"\" p = self.root for c in prefix: q = p.child.get(c,None) if q is None: return False p = q return True# Your Trie object will be instantiated and called as such:# obj = Trie()# obj.insert(word)# param_2 = obj.search(word)# param_3 = obj.startsWith(prefix) 因为python中有一些好用的数据结构，比如说dict，所以实现起来并不难。 贴一个dicuss中的c++解法吧，因为他这里限定了字符只是26个，所以写起来也挺方便的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class TrieNode&#123;public: TrieNode *next[26]; bool is_word; // Initialize your data structure here. TrieNode(bool b = false) &#123; memset(next, 0, sizeof(next)); is_word = b; &#125;&#125;;class Trie&#123; TrieNode *root;public: Trie() &#123; root = new TrieNode(); &#125; // Inserts a word into the trie. void insert(string s) &#123; TrieNode *p = root; for(int i = 0; i &lt; s.size(); ++ i) &#123; if(p -&gt; next[s[i] - 'a'] == NULL) p -&gt; next[s[i] - 'a'] = new TrieNode(); p = p -&gt; next[s[i] - 'a']; &#125; p -&gt; is_word = true; &#125; // Returns if the word is in the trie. bool search(string key) &#123; TrieNode *p = find(key); return p != NULL &amp;&amp; p -&gt; is_word; &#125; // Returns if there is any word in the trie // that starts with the given prefix. bool startsWith(string prefix) &#123; return find(prefix) != NULL; &#125;private: TrieNode* find(string key) &#123; TrieNode *p = root; for(int i = 0; i &lt; key.size() &amp;&amp; p != NULL; ++ i) p = p -&gt; next[key[i] - 'a']; return p; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"Tree","slug":"Tree","permalink":"http://blog.codeand.fun/tags/Tree/"}]},{"title":"Maximal-Square","slug":"Maximal-Square","date":"2017-11-16T19:48:47.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/11/16/Maximal-Square/","link":"","permalink":"http://blog.codeand.fun/2017/11/16/Maximal-Square/","excerpt":"","text":"第50天。 恍恍惚惚，就50天了。 今天的题目是Maximal Square: Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area. For example, given the following matrix: 12341 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0 Return 4. 让人很意外，这是一道动态规划的题目。 先说说我的非动态规划的解法： 大概的想法是，做一次遍历，每次遇到1,就向下拓展，如果扩展，扩展的方法是就是只需要看当前正方形的外围是否都是1，如果都是1,那么我们就可以继续向下扩展，这样就可以遍历出一个正方形，然后我们在对matrix进行遍历的时候还可以通过当前的最大面积来提早结束遍历： 1234567891011121314151617181920212223242526272829def expend(self,matrix,i,j,ret): \"\"\" :type matrix: List[List[str]] :type i: int :type j: int :type ret: int :rtype ret \"\"\" if i &gt;= len(matrix) or j &gt;= len(matrix[0]): return ret for k in range(ret+1): if matrix[i][j - k] == '0' or matrix[i-k][j] == '0': return ret return self.expend(matrix,i+1,j+1,ret+1)def maximalSquare1(self, matrix): \"\"\" :type matrix: List[List[str]] :rtype: int \"\"\" ret,i = 0,0 while i + ret &lt; len(matrix): j = 0 while j + ret &lt; len(matrix[0]): if matrix[i][j] == '1': ret = max(ret,self.expend(matrix,i+1,j+1,1)) j += 1 i += 1 return ret*ret 挺暴力的方法，不知道是不是因为可以提前结束，所以这个方法也直接AC了。 然后是DP的解法。 在解决这个问题之前，我们先考虑如果求出以matrix[i][j]为右下角的正方形最大面积。 如果matrix[i][j] = &#39;0&#39;,那么显然size[i][j] = 0如果matrix[i][j] = &#39;1&#39;,那么我们需要考虑其向上，向左，向左上的最大面积。 假设size[i-1][j-1] = 2,则我们至少可以知道： 12345[ [1,1,*] [1,1,*] [*,*,-]] 如果size[i][j-1] = 2,我们至少知道： 12345[ [*,*,*] [1,1,*] [1,1,-]] 如果size[i-1][j] = 2,我们至少知道： 12345[ [*,1,1] [*,1,1] [*,*,-]] 从上面可以看出来，只有当size[i-1][j-1] == 2 and size[i][j-1] == 2 and size[i-1][j-1] == 2时，size[i][j] == 3, 则我们可以得出以下递推式： size[i][j] = min(size[i-1][j-1],size[i][j-1],size[i-1][j])+1 if matrix[i][j] == &#39;1&#39;size[i][j] = 0 if matrix[i][j] == &#39;0&#39; 然后我们还需要考虑一下边界条件，因为当i=0或j=0时，上面的递推式是没有考虑到的，我们再加上： size[i][j] = (matrix[i][j] == &#39;1&#39;) where i == 0 or j == 0 然后我们就可以写出以下解法： 12345678910111213141516171819def maximalSquare(self,matrix): if len(matrix) == 0: return 0 dp1 = [] ret = 0 for i in range(len(matrix[0])): t = int(matrix[0][i] == '1') dp1.append(t) ret = max(ret,t) for i in range(1,len(matrix)): dp2 = [ 0 for i in range(len(matrix[0])) ] dp2[0] = int(matrix[i][0] == '1') ret = max(dp2[0],ret) for j in range(1,len(matrix[0])): if matrix[i][j] == '1': dp2[j] = min(min(dp1[j-1],dp1[j]),dp2[j-1]) + 1 ret = max(ret,dp2[j]) dp1 = dp2 return ret*ret","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://blog.codeand.fun/tags/DP/"}]},{"title":"Best Time to Buy and Sell Stock","slug":"Best-Time-to-Buy-and-Sell-Stock","date":"2017-11-15T08:05:42.000Z","updated":"2020-04-02T14:43:48.831Z","comments":true,"path":"2017/11/15/Best-Time-to-Buy-and-Sell-Stock/","link":"","permalink":"http://blog.codeand.fun/2017/11/15/Best-Time-to-Buy-and-Sell-Stock/","excerpt":"","text":"第49天。 今天的题目是Best Time to Buy and Sell Stock: Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Example 1:Input: [7, 1, 5, 3, 6, 4]Output: 5 max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)Example 2:Input: [7, 6, 4, 3, 1]Output: 0 In this case, no transaction is done, i.e. max profit = 0. 之前好像做过一道类似的题目，但是那道题比这道题难多了，那道题是可以多次买入卖出的，而成每次交易是需要支付一定费用的，这道就简单多了，我们只需要记录当前最小元素，然后每次更新最小元素，然后记录当前元素与最小元素的差值即可。 12345678910111213def maxProfit(self, prices): \"\"\" :type prices: List[int] :rtype: int \"\"\" profit,minElem = 0,sys.maxsize for p in prices: if p &lt; minElem: minElem = p t = p - minElem if t &gt; profit: profit = t return profit 然后是c++的解： 123456789int maxProfit(vector&lt;int&gt; &amp;prices) &#123; int maxPro = 0; int minPrice = INT_MAX; for(int i = 0; i &lt; prices.size(); i++)&#123; minPrice = min(minPrice, prices[i]); maxPro = max(maxPro, prices[i] - minPrice); &#125; return maxPro;&#125; 以及在dicuss中看到的： 12345678public int maxProfit(int[] prices) &#123; int maxCur = 0, maxSoFar = 0; for(int i = 1; i &lt; prices.length; i++) &#123; maxCur = Math.max(0, maxCur += prices[i] - prices[i-1]); maxSoFar = Math.max(maxCur, maxSoFar); &#125; return maxSoFar;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Symmetric Tree","slug":"Symmetric-Tree","date":"2017-11-14T10:49:31.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2017/11/14/Symmetric-Tree/","link":"","permalink":"http://blog.codeand.fun/2017/11/14/Symmetric-Tree/","excerpt":"","text":"第48天。 今天的题目是Symmetric Tree: Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 12345 1 / \\ 2 2 / \\ / \\3 4 4 3 But the following [1,2,2,null,3,null,3] is not: 12345 1 / \\2 2 \\ \\ 3 3 刚看的时候还有点懵，要怎么递归的去求解这种问题呢，要比较的两个节点隔得有点远啊。后来是上课时突然想到对称其实和根节点的左子树和右子树有关，我们把他当成两个树来求解就好了，递归时需要两个TreeNode: 123456789101112131415161718192021222324def isSymmetric1(self, root): \"\"\" :type root: TreeNode :rtype: bool \"\"\" if root is None: return True else: return self.isSymmetricRec(root.left,root.right)def isSymmetricRec(self,left,right): \"\"\" :type left: TreeNode :type right: TreeNode :rtype: bool \"\"\" if left is None and right is None: return True elif left is not None and right is not None: return left.val == right.val \\ and self.isSymmetricRec(left.left,right.right) \\ and self.isSymmetricRec(left.right,right.left) else: return False 然后是迭代解，这里是用层次遍历去做的： 1234567891011121314151617181920212223242526272829def isSymmetricBFS(self,root): \"\"\" :type root:TreeNode :rtype: bool \"\"\" if root is None: return True leftqueue = Queue() rightqueue = Queue() leftqueue.put(root.left) rightqueue.put(root.right) while not leftqueue.empty(): left = leftqueue.get() right = rightqueue.get() if left is None and right is None: continue elif left is not None and right is not None: if left.val != right.val: return False leftqueue.put(left.left) leftqueue.put(left.right) rightqueue.put(right.right) rightqueue.put(right.left) else: return False return True 然后是在dicuss中看到的c++解法，思路其实是一样的： 123456789101112131415161718bool isSymmetric(TreeNode *root) &#123; if (!root) return true; return helper(root-&gt;left, root-&gt;right);&#125;bool helper(TreeNode* p, TreeNode* q) &#123; if (!p &amp;&amp; !q) &#123; return true; &#125; else if (!p || !q) &#123; return false; &#125; if (p-&gt;val != q-&gt;val) &#123; return false; &#125; return helper(p-&gt;left,q-&gt;right) &amp;&amp; helper(p-&gt;right, q-&gt;left); &#125; 1234567891011121314151617181920212223242526bool isSymmetric(TreeNode *root) &#123; TreeNode *left, *right; if (!root) return true; queue&lt;TreeNode*&gt; q1, q2; q1.push(root-&gt;left); q2.push(root-&gt;right); while (!q1.empty() &amp;&amp; !q2.empty())&#123; left = q1.front(); q1.pop(); right = q2.front(); q2.pop(); if (NULL == left &amp;&amp; NULL == right) continue; if (NULL == left || NULL == right) return false; if (left-&gt;val != right-&gt;val) return false; q1.push(left-&gt;left); q1.push(left-&gt;right); q2.push(right-&gt;right); q2.push(right-&gt;left); &#125; return true;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"Tree","slug":"Tree","permalink":"http://blog.codeand.fun/tags/Tree/"}]},{"title":"Balanced Binary Tree","slug":"Balanced-Binary-Tree","date":"2017-11-13T21:08:54.000Z","updated":"2020-04-02T14:43:48.831Z","comments":true,"path":"2017/11/13/Balanced-Binary-Tree/","link":"","permalink":"http://blog.codeand.fun/2017/11/13/Balanced-Binary-Tree/","excerpt":"","text":"第47天。 今天的题目是Balanced Binary Tree: Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. 题目意思是对这个树的每个结点来说它左子树和右子树的高度差都不大于1,我们可以把它转换成一个求高度的问题： 123456789101112131415bool isBalanced(TreeNode* root) &#123; int h = 0; return isBalanced(root,h);&#125;bool isBalanced(TreeNode *root,int &amp;height) &#123; if (root == nullptr) &#123; height = 0; return true; &#125; int left,right; if (!isBalanced(root-&gt;left,left) || !isBalanced(root-&gt;right,right)) return false; if (abs(left - right) &gt; 1) return false; height = max(left,right) + 1; return true;&#125; 准备把主力语言往python和c上靠，所以以后都会写多一个python的解法。 123456789101112131415161718192021222324class Solution: def isBalanced(self,root): \"\"\" :type root: TreeNode :rtype: bool \"\"\" res,height = self.isBalancedRec(root) return res def isBalancedRec(self, root): \"\"\" :type root: TreeNode :rtype: bool,int \"\"\" if root is None: return True,0 leftRes,leftH = self.isBalancedRec(root.left) rightRes,rightH = self.isBalancedRec(root.right) if leftRes == False or rightRes == False: return False,max(leftH,rightH) else: return abs(leftH-rightH) &lt;= 1,max(leftH,rightH)+1","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"Tree","slug":"Tree","permalink":"http://blog.codeand.fun/tags/Tree/"}]},{"title":"Climbing Stairs","slug":"Climbing-Stairs","date":"2017-11-12T16:22:52.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/11/12/Climbing-Stairs/","link":"","permalink":"http://blog.codeand.fun/2017/11/12/Climbing-Stairs/","excerpt":"","text":"第46天。 今天的题目是Climbing Stairs: You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. Example 1: Input: 2Output: 2Explanation: There are two ways to climb to the top. 1 step + 1 step 2 stepsExample 2: Input: 3Output: 3Explanation: There are three ways to climb to the top. 1 step + 1 step + 1 step 1 step + 2 steps 2 steps + 1 step 首先，要到达第n个台阶，我们需要先到n-1或n-2台阶，只要到达n-1和n-2台阶处，我们就能够通过一步到达第n个台阶，这时可以写出这样的递推式: 12climbStairs(n) = climbStairs(n-1) + climbStairs(n-2);climbStairs(0) = climbStairs(1) = 1; 熟悉的话，可以一眼看出这是斐波那契数列. 这样的话，我们可以很容易写出: 1234int climbStairs(int n) &#123; if (n == 0 || n == 1) return 1; return climbStairs(n-1) + climbStairs(n-2);&#125; 但是这样会出现超时的情况，我们可以用一个数组来记录整个斐波那契数列，然后返回适当的值即可: 1234567int climbStairs(int n) &#123; vector&lt;int&gt; vec(n+1,1); for(int i = 2;i &lt;= n;i++) &#123; vec[i] = vec[i-1] + vec[i-2]; &#125; return vec[n];&#125; 这样的时间复杂度和空间复杂度都是O(n). 我们可以把空间复杂度降到O(1): 123456789int climbStairs(int n) &#123; int a = 0,b = 1,t; while(n--) &#123; t = a+b; a = b; b = t; &#125; return b;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Linked-List-Cycle","slug":"Linked-List-Cycle-1","date":"2017-11-12T16:07:12.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/11/12/Linked-List-Cycle-1/","link":"","permalink":"http://blog.codeand.fun/2017/11/12/Linked-List-Cycle-1/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Maximum Depth of Binary Tree","slug":"Maximun-Depth-of-Binary-Tree","date":"2017-11-11T08:25:23.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/11/11/Maximun-Depth-of-Binary-Tree/","link":"","permalink":"http://blog.codeand.fun/2017/11/11/Maximun-Depth-of-Binary-Tree/","excerpt":"","text":"第46天。 今天出游，挑到水题Maximum Depth of Binary Tree: Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 说是水题，就不讲怎么做了，直接上代码吧: 1234567int maxDepth(TreeNode* root) &#123; return maxDepth(root,0);&#125;int maxDepth(TreeNode *root,int depth) &#123; if (root == nullptr) return depth; return max(maxDepth(root-&gt;left,depth+1),maxDepth(root-&gt;right,depth+1));&#125; 恩，突然发现好像没必要写的那么长: 1234int maxDepth(TreeNode *root) &#123; if (root == nullptr) return 0; return max(maxDepth(root-&gt;left),maxDepth(root-&gt;right))+1;&#125; 恩，送上一个dicuss中BFS的解法： 12345678910111213141516171819202122232425int maxDepth(TreeNode *root)&#123; if(root == NULL) return 0; int res = 0; queue&lt;TreeNode *&gt; q; q.push(root); while(!q.empty()) &#123; ++ res; for(int i = 0, n = q.size(); i &lt; n; ++ i) &#123; TreeNode *p = q.front(); q.pop(); if(p -&gt; left != NULL) q.push(p -&gt; left); if(p -&gt; right != NULL) q.push(p -&gt; right); &#125; &#125; return res;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"Tree","slug":"Tree","permalink":"http://blog.codeand.fun/tags/Tree/"}]},{"title":"Majority Element","slug":"Majority-Element","date":"2017-11-10T08:33:00.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/11/10/Majority-Element/","link":"","permalink":"http://blog.codeand.fun/2017/11/10/Majority-Element/","excerpt":"","text":"第45天。 今天的题目是Majority Element: Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. 最简单的想法就是，遍历一遍序列，记录出现的次数，然后在遍历一遍刚才记录的次数，如果大于k就直接返回，这种时候一般会用到hash table，在c++中就是unordered_map: 1234567int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); int k = size/2; unordered_map&lt;int,int&gt; map; for(auto i:nums) map[i]++; for(auto p:map) if (p.second &gt; k) return p.first;&#125; 这种方法的时间复杂度是O(n),空间复杂度也是O(n). 虽然很简单，但是这道题目在dicuss中也有很多有趣的解法: 因为Majority Element在序列中存在n/2个，所以假如这个序列时有序的话，他一定会出现在中间: 1234int majorityElement(vector&lt;int&gt;&amp; nums) &#123; nth_element(nums.begin(), nums.begin() + nums.size() / 2, nums.end()); return nums[nums.size() / 2];&#125; 很nice的学到了一个新的函数。 同样是因为出现了k/2次，所以我们如果随机选取一个元素的话，有一半的概率可以直接选到Majority Element: 12345678910111213int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); srand(unsigned(time(NULL))); while (true) &#123; int idx = rand() % n; int candidate = nums[idx]; int counts = 0; for (int i = 0; i &lt; n; i++) if (nums[i] == candidate) counts++; if (counts &gt; n / 2) return candidate; &#125;&#125; Moore Voting Algorithm，这个方法的正确性我也不是很确定: 1234567891011int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int major, counts = 0, n = nums.size(); for (int i = 0; i &lt; n; i++) &#123; if (!counts) &#123; major = nums[i]; counts = 1; &#125; else counts += (nums[i] == major) ? 1 : -1; &#125; return major;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Move-Zeroes","slug":"Move-Zeroes","date":"2017-11-09T08:07:21.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/11/09/Move-Zeroes/","link":"","permalink":"http://blog.codeand.fun/2017/11/09/Move-Zeroes/","excerpt":"","text":"第44天。 今天的题目是Move Zeroes: Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements. For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0]. Note:You must do this in-place without making a copy of the array.Minimize the total number of operations. 这道题目要求我们原地的移动元素，而且还要保持序列本身的顺序。 我们可以利用一下计数排序的思想，反正最后都是0,我只要算出有几个0要放在最后，我就可以很方便的产生后缀啦，所以这里先遍历一遍序列记录0的个数，然后我们发现其实每个元素向前移动多少格是和它前面有多少个0有关的,so ： 12345678910void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int zero = 0,size = nums.size(),i,j; for(i = 0;i &lt; size;i++) &#123; if (nums[i] == 0) zero++; else if (zero != 0) nums[i-zero] = nums[i]; &#125; j = size - 1; size -= zero; while(j &gt;= size) nums[j--] = 0;&#125; 虽然写的不是很优雅的样子，但是这个思路是正确的，还有dicuss中的解法也是这个思路。 123456789101112void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int j = 0; // move all the nonzero elements advance for (int i = 0; i &lt; nums.size(); i++) &#123; if (nums[i] != 0) &#123; nums[j++] = nums[i]; &#125; &#125; for (;j &lt; nums.size(); j++) &#123; nums[j] = 0; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Product of Array Except Self","slug":"Product-of-Array-Except-Self","date":"2017-11-08T22:55:58.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/11/08/Product-of-Array-Except-Self/","link":"","permalink":"http://blog.codeand.fun/2017/11/08/Product-of-Array-Except-Self/","excerpt":"","text":"第43天。 今天的题目是Product of Array Except Self: Given an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Solve it without division and in O(n). For example, given [1,2,3,4], return [24,12,8,6]. Follow up:Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.) 这里说不能使用除法，我的想法就是自己实现一个除法: 123456789101112131415161718192021int Div(unsigned a,unsigned b) &#123; int x,y; int ans = 0; while(a &gt;= b) &#123; x = b; y = 1; while( a &gt;= (x&lt;&lt;1)) &#123; x &lt;&lt;= 1; y &lt;&lt;= 1; &#125; a -= x; ans += y; &#125; return ans;&#125;int div(int a,int b) &#123; if (a &gt; 0 &amp;&amp; b &gt; 0) return Div(a,b); else if (a &lt; 0 &amp;&amp; b &lt; 0) return Div(-a,-b); else if (a &lt; 0) return -Div(-a,b); else return -Div(a,-b);&#125; 然后剩下的东西就是将0这个特例排除掉了： 12345678910111213141516171819202122232425vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; ret(nums.size(),0); long long product = 1; int zero_count = 0; for(auto i:nums) if (i != 0) product*=i; else zero_count++; cout &lt;&lt; zero_count &lt;&lt; endl; if (zero_count &gt; 1) return ret; if (zero_count == 1) &#123; for(int i = 0;i &lt; nums.size();i++) &#123; if (nums[i] != 0) ret[i] = 0; else ret[i] = product; &#125; return ret; &#125; for(int i = 0;i &lt; ret.size();i++) &#123; // if (nums[i] == 0) ret[i] = product[i]; ret[i] = div((int)product,nums[i]); &#125; return ret;&#125; 但是看了dicuss的做法，我感觉的理解是错的： 123456789101112def productExceptSelf(self, nums): p = 1 n = len(nums) output = [] for i in range(0,n): output.append(p) p = p * nums[i] p = 1 for i in range(n-1,-1,-1): output[i] = output[i] * p p = p * nums[i] return output 恩，今天写的有点急，因为我周五安全导论还要考试，然而我还一堆东西不会。。。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Lowest Common Ancestor of a Binary Tree","slug":"Lowest-Common-Ancestor-of-a-Binary-Tree","date":"2017-11-07T10:22:40.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/11/07/Lowest-Common-Ancestor-of-a-Binary-Tree/","link":"","permalink":"http://blog.codeand.fun/2017/11/07/Lowest-Common-Ancestor-of-a-Binary-Tree/","excerpt":"","text":"第42天。 今天的题目是Lowest Common Ancestor of a Binary Tree: Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).” 1234567 _______3______ / \\ ___5__ ___1__/ \\ / \\6 _2 0 8 / \\ 7 4 For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition. 额，怎么说呢。好久没有在上课前就AC掉了呢。 恩，题目的意思是，找最近的公共祖先。 考虑根节点，如果不考虑特殊的情况（比如说只用一个节点或干脆就没有节点），那么如果我们对其左子树和右子树递归的调用lowestCommonAncestor，那么其返回值就有以下几种情况: left和right都非空，那么说明root节点就是lowestCommonAncestor，那我们就返回root 只有left非空，那么说明lowestCommonAncestor在左子树中,那么我们就返回left 只有right非空，与上面类似，我们就直接返回right 两个都是空，说明p和q都不在这棵子树中，那其lowestCommonAncestor就是nullptr. 然后我们再考虑一下特殊情况： root是nullptr,那么就说明到了最底部了，直接返回nullptr即可 root和p或q相等,说明我们找到了其一个祖先，则返回p或q. 然后将上面的思路写出来就是: 123456789101112TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (root == nullptr || root == p || root == q) return root; TreeNode *left = lowestCommonAncestor(root-&gt;left,p,q); TreeNode *right = lowestCommonAncestor(root-&gt;right,p,q); if (left &amp;&amp; right) return root; else if (left) return left; else if (right) return right; else return nullptr;&#125; 其实上面有一个问题没考虑到，要是只有p在这棵子树中，而q不在，那怎么办。 emmmm，但是上面的解法是过了测试的。 如果要考虑这个问题的话，上面就有一些假设就是错的了，因为在lowestCommonAncestor在某些情况返回非空只是说明，这棵子树中有一个节点是与p和q相同的。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"Tree","slug":"Tree","permalink":"http://blog.codeand.fun/tags/Tree/"}]},{"title":"Palindrome Linked List","slug":"Palindrome-Linked-List","date":"2017-11-06T09:30:54.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/11/06/Palindrome-Linked-List/","link":"","permalink":"http://blog.codeand.fun/2017/11/06/Palindrome-Linked-List/","excerpt":"","text":"第42天。 今天的题目是Palindrome Linked List: Given a singly linked list, determine if it is a palindrome. Follow up:Could you do it in O(n) time and O(1) space? 如果不考虑O(1)的空间复杂度的话，可以直接用一个栈保存，然后在对比，不过我没有实现这个方法。我的解法是先用快慢指针求链表中点，然后在翻转后面的链表（只需要O(n)的时间复杂度和O(1)的空间复杂度），然后在对比。 12345678910111213141516171819202122232425262728293031323334353637bool isPalindrome(ListNode* head) &#123; if (!head || !head-&gt;next) return true; ListNode *fast = head; ListNode *slow = head; ListNode *pre = slow; while(fast &amp;&amp; fast-&gt;next) &#123; fast = fast-&gt;next-&gt;next; pre = slow; slow = slow-&gt;next; &#125; fast = pre-&gt;next; pre-&gt;next = nullptr; fast = revertList(fast); while(fast &amp;&amp; head) &#123; if (fast-&gt;val != head-&gt;val) return false; fast = fast-&gt;next; head = head-&gt;next; &#125; return true;&#125;ListNode *revertList(ListNode *head) &#123; if(!head || !head-&gt;next) return head; ListNode *pre = head; ListNode *cur = head; while(cur) &#123; ListNode *t = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = t; &#125; head = head-&gt;next; return pre;&#125; 然后是在dicuss中看到的解法，相当有趣的技巧： 123456789101112ListNode* temp;bool isPalindrome(ListNode* head) &#123; temp = head; return check(head);&#125;bool check(ListNode* p) &#123; if (NULL == p) return true; bool isPal = check(p-&gt;next) &amp; (temp-&gt;val == p-&gt;val); temp = temp-&gt;next; return isPal;&#125; 刚开始看的时候感觉好像是错的，但是仔细想想，这个方法相当美妙，利用函数调用来做栈，首先是递归调用check(p-&gt;next),这样的话会一直到最后一个节点才开始比较temp-&gt;val == p-&gt;val，又因为temp = temp-&gt;next始终没有执行到，所以现在temp指向第一个元素，而p指向最后一个元素，判断完后，会执行到temp = temp-&gt;next，然后check会返回，返回后p就指向了倒数第二个元素，就这样一直迭代下去。 不过这个方法的空间复杂度是O(n).","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"LinkedList","slug":"LinkedList","permalink":"http://blog.codeand.fun/tags/LinkedList/"}]},{"title":"Invert Binary Tree","slug":"Invert-Binary-Tree","date":"2017-11-05T09:18:33.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/11/05/Invert-Binary-Tree/","link":"","permalink":"http://blog.codeand.fun/2017/11/05/Invert-Binary-Tree/","excerpt":"","text":"第41天。 今天的题目是Invert Binary Tree: Invert a binary tree. 12345 4 / \\ 2 7 / \\ / \\1 3 6 9 to 12345 4 / \\ 7 2 / \\ / \\9 6 3 1 Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off. emmmm，挺出名的一道题目。 其实挺简单： 12345678TreeNode* invertTre1e(TreeNode* root) &#123; if (root == nullptr) return root; TreeNode *left = invertTree(root-&gt;right); TreeNode *right = invertTree(root-&gt;left); root-&gt;left = left; root-&gt;right = right; return root;&#125; 然后是迭代的方法: 1234567891011121314151617TreeNode* invertTree(TreeNode *root) &#123; stack&lt;TreeNode *&gt; st; st.push(root); TreeNode *ret =root; while(!st.empty()) &#123; root = st.top(); st.pop(); if (root) &#123; st.push(root-&gt;left); st.push(root-&gt;right); TreeNode *t = root-&gt;left; root-&gt;left = root-&gt;right; root-&gt;right = t; &#125; &#125; return ret;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"Tree","slug":"Tree","permalink":"http://blog.codeand.fun/tags/Tree/"}]},{"title":"Reverse Linked List","slug":"Reverse-Linked-List","date":"2017-11-04T19:01:34.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2017/11/04/Reverse-Linked-List/","link":"","permalink":"http://blog.codeand.fun/2017/11/04/Reverse-Linked-List/","excerpt":"","text":"第40天。 今天的题目是Reverse Linked List: Reverse a singly linked list.Hint:A linked list can be reversed either iteratively or recursively. Could you implement both? 简单的想法就是直接用一个栈来完成这种后进先出的操作: 12345678910111213ListNode* reverseList1(ListNode* head) &#123; ListNode ret(0); ListNode *p = &amp;ret; stack&lt;ListNode *&gt; st; while(head!=nullptr) &#123; st.push(head); head = head-&gt;next; &#125; while(!st.empty()) &#123; p-&gt;next = st.top(); st.pop(); p = p-&gt;next; &#125; p-&gt;next = nullptr; return ret.next;&#125; 但是这种方法效率不高，下面是迭代的方法： 1234567891011ListNode* reverseList(ListNode* head) &#123; ListNode *pre = nullptr; ListNode *cur = head; while(cur != nullptr) &#123; ListNode *t = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = t; &#125; return pre;&#125; 以及递归的方法: 1234567ListNode *reverseList(ListNode *head) &#123; if (head==nullptr || head-&gt;next == nullptr) return head; ListNode *ret = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = nullptr; return ret;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"LinkedList","slug":"LinkedList","permalink":"http://blog.codeand.fun/tags/LinkedList/"}]},{"title":"Kth Largest Element in an array","slug":"Kth-Largest-Element-in-an-array","date":"2017-11-03T08:28:57.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/11/03/Kth-Largest-Element-in-an-array/","link":"","permalink":"http://blog.codeand.fun/2017/11/03/Kth-Largest-Element-in-an-array/","excerpt":"","text":"第39天。 今天的题目是Kth Largest Element in an Array: Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. For example,Given [3,2,1,5,6,4] and k = 2, return 5. Note:You may assume k is always valid, 1 ≤ k ≤ array’s length. 简单的做法就是先对无序的数组进行倒序排序，然后返回nums[k-1]即可。 1234int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; sort(nums.begin(),nums.end(),[](int a,int b )&#123; return a &gt; b; &#125;); return nums[k-1];&#125; 时间复杂度是O(nlog(n)).然后是利用partition的方法: 12345678910111213141516171819202122int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; return findKthLargest(nums,0,nums.size() - 1,k-1); &#125;int findKthLargest(vector&lt;int&gt; &amp;nums,int first,int last,int k) &#123; int p = partition(nums,first,last); if (k &gt; p) return findKthLargest(nums,p+1,last,k); else if (k &lt; p) return findKthLargest(nums,first,p-1,k); else return nums[p];&#125;int partition(vector&lt;int&gt; &amp;nums,int first,int last) &#123; if (first == last) return first; swap(nums[first],nums[(random() % (last-first) + first)]); int k = nums[first]; while(first &lt; last) &#123; while(first &lt; last &amp;&amp; nums[last] &lt;= k) last--; nums[first] = nums[last]; while(first &lt; last &amp;&amp; nums[first] &gt;= k) first++; nums[last] = nums[first]; &#125; nums[first] = k; return first;&#125; 显然和上面快排的方法一样时间复杂度都是O(nlogn). 然后是在dicuss中看到的用堆排的方法: 12345678910111213141516171819202122232425262728293031int heap_size;inline int left(int idx) &#123; return (idx &lt;&lt; 1) + 1;&#125;inline int right(int idx) &#123; return (idx &lt;&lt; 1) + 2;&#125;void max_heapify(vector&lt;int&gt;&amp; nums, int idx) &#123; int largest = idx; int l = left(idx), r = right(idx); if (l &lt; heap_size &amp;&amp; nums[l] &gt; nums[largest]) largest = l; if (r &lt; heap_size &amp;&amp; nums[r] &gt; nums[largest]) largest = r; if (largest != idx) &#123; swap(nums[idx], nums[largest]); max_heapify(nums, largest); &#125;&#125;void build_max_heap(vector&lt;int&gt;&amp; nums) &#123; heap_size = nums.size(); for (int i = (heap_size &gt;&gt; 1) - 1; i &gt;= 0; i--) max_heapify(nums, i);&#125;int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; build_max_heap(nums); for (int i = 0; i &lt; k; i++) &#123; swap(nums[0], nums[heap_size - 1]); heap_size--; max_heapify(nums, 0); &#125; return nums[heap_size];&#125; 还有用STL中priority_queue的： 123456int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; priority_queue&lt;int&gt; pq(nums.begin(), nums.end()); for (int i = 0; i &lt; k - 1; i++) pq.pop(); return pq.top();&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Intersection of Two Linked Lists","slug":"Intersection-of-Two-Linked-Lists","date":"2017-11-02T20:29:24.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/11/02/Intersection-of-Two-Linked-Lists/","link":"","permalink":"http://blog.codeand.fun/2017/11/02/Intersection-of-Two-Linked-Lists/","excerpt":"","text":"第38天。 今天课贼多，突然发现贼多作业没写完。。。 今天的题目是Intersection of Two Linked Lists: Write a program to find the node at which the intersection of two singly linked lists begins. For example, the following two linked lists: 12345A: a1 → a2 ↘ c1 → c2 → c3 ↗B: b1 → b2 → b3 begin to intersect at node c1. Notes: If the two linked lists have no intersection at all, return null.The linked lists must retain their original structure after the function returns.You may assume there are no cycles anywhere in the entire linked structure.Your code should preferably run in O(n) time and use only O(1) memory. 最简单的方法就是先遍历一遍第一个链表所有的节点，然后记录下来，然后在遍历第二个链表节点的使用进行 查找即可，虽然很简单，但是时间复杂度很高和空间复杂度都挺高的： 123456789101112ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; vector&lt;ListNode *&gt; vec; while(headA) &#123; vec.push_back(headA); headA = headA-&gt;next; &#125; while(headB) &#123; if (find(vec.begin(),vec.end(),headB) != vec.end()) return headB; headB = headB-&gt;next; &#125; return nullptr;&#125; 然后是另一种方法，观察下图： 12345A: a1 → a2 ↘ c1 → c2 → c3 ↗B: b1 → b2 → b3 如果我们可以不断的把c3,c2,c1去掉，到最后，我们就会找到交点,这个方法只需要O(1)的空间复杂度以及O(n*k)的时间复杂度，k是两个链表共同拥有的节点。 12345678910111213ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; //if (headA == nullptr || headB == nullptr) return nullptr; ListNode *end = nullptr; while(1) &#123; if (headA == end || headB == end) return end; ListNode *pa = headA; ListNode *pb = headB; while(pa-&gt;next != end) pa = pa-&gt;next; while(pb-&gt;next != end) pb = pb-&gt;next; if (pa != pb) return end; else end = pa; &#125;&#125; 然后是在dicuss中看到的： 12345678ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; ListNode *cur1 = headA, *cur2 = headB; while(cur1 != cur2)&#123; cur1 = cur1?cur1-&gt;next:headB; cur2 = cur2?cur2-&gt;next:headA; &#125; return cur1;&#125; 第一眼看，没看懂，后来仔细看看才发现，cur1原本是headA开始的，但是在循环里面却被换成了headB,cur2同理。 所以他们其实会走同样多的距离并到达交点,如果没有交点，就同时到达nullptr。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"Linked-List","slug":"Linked-List","permalink":"http://blog.codeand.fun/tags/Linked-List/"}]},{"title":"Number of Islands","slug":"Number-of-Islands","date":"2017-11-01T10:25:07.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/11/01/Number-of-Islands/","link":"","permalink":"http://blog.codeand.fun/2017/11/01/Number-of-Islands/","excerpt":"","text":"第37天。 今天的题目Number of Islands比较简单，而且感觉好像做过的样子： Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: 11110110101100000000Answer: 1 Example 2: 11000110000010000011Answer: 3 解法相当简单，只要遍历所有点，然后如何当前点是1,就将计数加一，然后进行扩展，所谓的扩展就是将当前点的值至为0,然后向上下左右进行查找，如果还是1就递归调用扩展。 ```c++ int numIslands(vector&lt;vector&gt;&amp; grid) { if (grid.size() == 0 || grid[0].size() == 0) return 0; int count = 0; for(int i = 0;i &lt; grid.size();i++) { for(int j = 0;j &lt; grid[0].size();j++) { if (grid[i][j] == &apos;1&apos;) { cout &lt;&lt; &quot;(&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)\\n&quot;; count++; expend(grid,i,j); } } } return count; } void expend(vector&lt;vector&lt;char&gt; &gt; &amp;grid,int x,int y) { if ( x &lt; 0 || y &lt; 0 || x &gt;= grid.size() || y &gt;= grid[0].size() || grid[x][y] == &apos;0&apos; ) return; //cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl; grid[x][y] = &apos;0&apos;; expend(grid,x-1,y); expend(grid,x+1,y); expend(grid,x,y-1); expend(grid,x,y+1); }`` 因为dicuss中的做法都是一样的，所以就不贴dicuss的代码了。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Sort List","slug":"Sort-List","date":"2017-10-31T10:35:28.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2017/10/31/Sort-List/","link":"","permalink":"http://blog.codeand.fun/2017/10/31/Sort-List/","excerpt":"","text":"第36天。 今天的题目好像是之前就做过的了，Sort List: Sort a linked list in O(n log n) time using constant space complexity. 要O(nlogn)的算法，显然就是要用归并或快排啦，但是因为他是链表，所以只能是归并排序。 归并排序首先要解决的问题就是，如何分成两半，这里用的方法是快慢指针： 12345678910111213141516171819202122232425262728293031ListNode* sortList(ListNode* head) &#123; if (head == nullptr || head-&gt;next == nullptr ) return head; ListNode *slow = head; ListNode *fast = head; ListNode *pre = head; while(fast &amp;&amp; fast-&gt;next) &#123; pre = slow; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; pre-&gt;next = nullptr; head = sortList(head); slow = sortList(slow); return mergeList(head,slow);&#125;ListNode *mergeList(ListNode *p1,ListNode *p2) &#123; ListNode ret(0); ListNode *p = &amp;ret; while(p1&amp;&amp;p2) &#123; if (p1-&gt;val &gt; p2-&gt;val) &#123; p-&gt;next = p2; p2 = p2-&gt;next; &#125; else &#123;p-&gt;next = p1; p1 = p1-&gt;next; &#125; p = p-&gt;next; &#125; if (p1) p-&gt;next = p1; if (p2) p-&gt;next = p2; return ret.next;&#125; 因为是之前做过的，而且好像还写过Blog,所以就不详细写了。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"List","slug":"List","permalink":"http://blog.codeand.fun/tags/List/"}]},{"title":"Linked List Cycle","slug":"Linked-List-Cycle","date":"2017-10-30T09:18:19.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/10/30/Linked-List-Cycle/","link":"","permalink":"http://blog.codeand.fun/2017/10/30/Linked-List-Cycle/","excerpt":"","text":"第35天。 今天的题目是Linked List Cycle II: Given a linked list, return the node where the cycle begins. If there is no cycle, return null. Note: Do not modify the linked list. Follow up:Can you solve it without using extra space? 这道题是判断链表是否有环的升级版。 首先肯定需要fast和slow指针来先判断是否有环，如果没有，就直接返回nullptr即可。 然后就是怎么计算出环的入口了。 先来个暴力的方法: 123456789101112131415161718192021222324ListNode *detectCycle(ListNode *head) &#123; vector&lt;ListNode *&gt; lvec; ListNode *fast = head; ListNode *slow = head; while(fast &amp;&amp; fast-&gt;next) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; //lvec.push_back(slow); if (slow == fast) &#123; lvec.push_back(slow); slow = slow-&gt;next; while(slow != fast) &#123; lvec.push_back(slow); slow=slow-&gt;next; &#125; for(auto t:lvec) cout &lt;&lt; t-&gt;val &lt;&lt; endl; while(find(lvec.begin(),lvec.end(),head) == lvec.end()) head = head-&gt;next; return head; &#125; &#125; return nullptr;&#125; 当然实际的方法不用那么麻烦： 12345678910111213141516171819ListNode *detectCycle(ListNode *head) &#123; vector&lt;ListNode *&gt; lvec; ListNode *fast = head; ListNode *slow = head; while(fast &amp;&amp; fast-&gt;next) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if (fast == slow) &#123; slow = head; while(slow != fast) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; return fast; &#125; &#125; return nullptr;&#125; emmmm,一直很好奇为什么可以这样判断，就去搜了一下，发现了这个判断单向链表是否有环及求环入口的算法数学证明.","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"Linked-List","slug":"Linked-List","permalink":"http://blog.codeand.fun/tags/Linked-List/"}]},{"title":"Partition to K Equal Sum Subsets","slug":"Partition-to-K-Equal-Sum-Subsets","date":"2017-10-29T11:16:55.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/10/29/Partition-to-K-Equal-Sum-Subsets/","link":"","permalink":"http://blog.codeand.fun/2017/10/29/Partition-to-K-Equal-Sum-Subsets/","excerpt":"","text":"第35天。 又一次一个早上没做出来，难道要跪在DP上了吗？ 今天的题目是Partition to K Equal Sum Subsets: Given an array of integers nums and a positive integer k, find whether it’s possible to divide this array into k non-empty subsets whose sums are all equal. Example 1:Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4Output: TrueExplanation: It’s possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.Note: 1 &lt;= k &lt;= len(nums) &lt;= 16.0 &lt; nums[i] &lt; 10000. 虽然一开始思路是对的，但是就是没想出来做递归，先讲讲我想到的： 首先，他要我们分辨一组数字是否能被划分成K个相同的子集，我们可以对这个数组进行求和，如果和是K的倍数，那么这个倍数a就是每个子集的和，如果不是K的倍数，则肯定没法分成和相同的K个子集。 现在问题变成了，找出k个子集使得它的和为a. 然后，我就不会做了。 然后是在dicuss中看到的方法，前面的思路是完全一样的，所以这里只讲讲他是怎么做求出k个子集使得和为a的. 其实方法很简单，暴力搜而已。 我们用一个大小为k的vector来记录每个子集的和（或者还差多少），然后我们从后面向前搜索，每次尝试将一个元素放入第i个vector中，然后考虑下一个元素，emmm，其实不好讲出来，但是代码挺简单的。 btw,这里好像没有制表啊，然后我还一直想着要怎么制表。算了，明天还是按顺序直接刷吧。 1234567891011121314151617181920212223242526272829bool canPartitionKSubsets(vector&lt;int&gt;&amp; nums, int k) &#123; if ( k &lt;= 1 ) return true; //return canPartitionKSubsets(nums.begin(),k/2); sort(nums.begin(),nums.end()); int sum = 0; for(auto i:nums) sum +=i; if (sum % k != 0) return false; int a = sum / k; vector&lt;int&gt; kdq(k,a); return possible(nums,kdq,nums.size() - 1);&#125;bool possible(vector&lt;int&gt; &amp;nums,vector&lt;int&gt; &amp;kdq,int index) &#123; if (index &lt; 0) &#123; for(int i:kdq) if (i != 0) return false; return true; &#125; int n = nums[index]; for(auto &amp;a:kdq) &#123; if (a &gt;= n) &#123; a -= n; if (possible(nums,kdq,index-1)) return true; a += n; &#125; &#125; return false;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"DP","slug":"DP","permalink":"http://blog.codeand.fun/tags/DP/"}]},{"title":"Best Time to Buy and Sell Stock with Transaction Fee","slug":"Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee","date":"2017-10-28T13:34:16.000Z","updated":"2020-04-02T14:43:48.831Z","comments":true,"path":"2017/10/28/Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee/","link":"","permalink":"http://blog.codeand.fun/2017/10/28/Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee/","excerpt":"","text":"第34天。 今天又没做出来，sad，同样是一道DP的题目： Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.) Return the maximum profit you can make.Example 1:Input: prices = [1, 3, 2, 8, 4, 9], fee = 2Output: 8Explanation: The maximum profit can be achieved by:Buying at prices[0] = 1Selling at prices[3] = 8Buying at prices[4] = 4Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.Note:0 &lt; prices.length &lt;= 50000.0 &lt; prices[i] &lt; 50000.0 &lt;= fee &lt; 50000. 先理解一下题意先，大概是输入是一个表示股票价格的数组prices以及一个表示交易费用的fee,这个fee在每次交易的时候都需要支付。 然后很自然的我们会用一个profit的数组来记录，每天能达到的最大profit，然后我们也比较容易写出一个递推式：profit[i] = max(profit[j],profit[j] + prices[i] - prices[j] -fee) for j in range(0,i) 然后就写出了一个O(n^2)的算法： 12345678910111213int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123; if (prices.size() == 0) return 0; vector&lt;int&gt; profit(prices.size(),0); profit[0] = 0; for(int i = 1;i &lt; profit.size();i++) &#123; for(int j = i-1;j&gt;=0;j--) &#123; profit[i] = max(profit[i],profit[j]); int t = profit[j] + prices[i] - prices[j] - fee; profit[i] = max(profit[i],t); &#125; &#125; return *profit.rbegin();&#125; 然后就时间超限了。 想了一个早上也没能解决，很好又一次被KMP的next误导了，又是打算用加快内层循环的方式去做，但是还是会出现时间超限的问题。 哎，还是来看看dicuss中的解法吧： 123456789int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123; int s0 = 0,s1 = INT_MIN; for(auto p:prices) &#123; int t = s0; s0 = max(s0,s1+p); //sell s1 = max(s1,t-p-fee); //buy &#125; return s0;&#125; 前面的解法之所以会出现超时，就是因为他的时间复杂度为O(n^2),而dicuss中的解法却是O(n)的，这里的s0和第一个方法的profit是一样的，重要的s1. 我们知道一次交易可以分为buy和sell,他们消耗一次fee，那么我们可以将这个fee归入到buy的时候，如果当前操作是buy,那么必须保证我们当前没有股票，也就是说上一次操作是sell,这里的s0就是表示没有股票的状态，s1表示是有股票的状态。 对于s0,我们想要更新它，就只有将上一个s1卖出，然后取最大值对于s1，我们要更新它，就只有将当前股票买入，然后取最大值。 所以就得到了上面的两条式子。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"DP","slug":"DP","permalink":"http://blog.codeand.fun/tags/DP/"}]},{"title":"Word Break","slug":"Word-Break","date":"2017-10-27T20:27:53.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2017/10/27/Word-Break/","link":"","permalink":"http://blog.codeand.fun/2017/10/27/Word-Break/","excerpt":"","text":"第33天。 做了超级久。。。还是没做出来，我真是菜啊，明明已经想到了要用动态规划来做了。 今天的题目是:Word Break: Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words. For example, givens = “leetcode”,dict = [“leet”, “code”]. Return true because “leetcode” can be segmented as “leet code”. 因为没做出来，所以只能讲别人的思路了。。。 首先这里是要用动态规划去做的，我们需要一个vector&lt;bool&gt; db来记录s.substr(0,i+1)的子串是否能用wordDict进行break,如果我们要求db[i]我们是否能利用db[0:i]的值呢，比如，如果0&lt;= k &lt; i，且db[k]==true,那么我们是不是只需要在wordDict中查找是否有s.substr(i,k-i)就可了呢： 1234567891011121314151617bool wordBreak(string s,vector&lt;string&gt; &amp;wordDict) &#123; if(wordDict.size() == 0) return false; vector&lt;bool&gt; dp(s.size() + 1,false); dp[0] = true; for(int i = 1;i &lt;= s.size();i++) &#123; for(int j = i-1;j &gt;= 0;j--) &#123; if (dp[j]) &#123; string word = s.substr(j,i-j); if (find(wordDict.begin(),wordDict.end(),word) != wordDict.end()) &#123; dp[i] = true; break; &#125; &#125; &#125; &#125; return dp[s.size()];&#125; 因为是别人的思路，所以也没法复现思考的过程了，总结一下没做出来的原因吧。虽然说算法课上刚讲了DP,当时他讲的时候我还觉得挺简单的，还以为自己已经会了，因为之前已经做过好几次DP的题目了，现在想想上课我就记得他吐槽了DP的恋爱观，什么总是找局部最优解巴拉巴拉的。哎，这种东西还是要自己体会才行，恩，决定了，这几天刷会DP的题目先。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"动态规划","slug":"动态规划","permalink":"http://blog.codeand.fun/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Flatten Binary Tree to Linked List","slug":"Flatten-Binary-Tree-to-Linked-List","date":"2017-10-26T11:02:31.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/10/26/Flatten-Binary-Tree-to-Linked-List/","link":"","permalink":"http://blog.codeand.fun/2017/10/26/Flatten-Binary-Tree-to-Linked-List/","excerpt":"","text":"第32天。 今天的题目是Flatten Binary Tree to Linked List: Given a binary tree, flatten it to a linked list in-place. For example,Given 12345 1 / \\ 2 5 / \\ \\3 4 6 The flattened tree should look like: 12345678910111 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 通过观察结果，我们可以发现它的顺序其实是一个先序遍历,那么我们可以先对树做一个先序遍历并记录节点指针，然后我们只需要将所有节点连接起来即可 1234567891011121314151617181920212223void flatten2(TreeNode *root) &#123; if (root == nullptr) return ; stack&lt;TreeNode *&gt; st; vector&lt;TreeNode *&gt; tvec; while(true) &#123; while(root)&#123; st.push(root); tvec.push_back(root); root = root-&gt;left; &#125; if (st.empty() ) break; root = st.top(); st.pop(); root = root-&gt;right; &#125; int i; for(i = 0;i &lt; tvec.size() - 1;i++) &#123; tvec[i]-&gt;left = nullptr; tvec[i]-&gt;right = tvec[i+1]; &#125; tvec[i]-&gt;left = nullptr; tvec[i]-&gt;right = nullptr;&#125; 考虑一下递归的去完成整个问题，我们可以先对左孩子和右孩子做一次flatten,然后再讲他们按照适当的顺序连接起来: 1234567891011121314void flatten(TreeNode* root) &#123; if (root==NULL) return ; flatten(root-&gt;left); flatten(root-&gt;right); auto right = root-&gt;right; auto left = root-&gt;left; if (left)&#123; root-&gt;right = left; root-&gt;left = NULL; while(left-&gt;right) left = left-&gt;right; left-&gt;right = right; &#125;&#125; 上面的做法由于每次都需要对左孩子有一个一直往右的遍历，所以耗时还是挺大的，可以加入一个last指针，去表示最后一个被访问的节点的位置,为了保证正确性，我们必须先对右孩子进行flatten再对左孩子进行flatten. 123456789TreeNode *last;void flatten(TreeNode* root) &#123; if (root==NULL) return ; flatten(root-&gt;right); flatten(root-&gt;left); root-&gt;right = last; root-&gt;left = nullptr; last = root;&#125; 然后是在dicuss中看到的迭代算法： 123456789101112131415void flatten(TreeNode *root) &#123; while (root) &#123; if (root-&gt;left &amp;&amp; root-&gt;right) &#123; TreeNode* t = root-&gt;left; while (t-&gt;right) t = t-&gt;right; t-&gt;right = root-&gt;right; &#125; if(root-&gt;left) root-&gt;right = root-&gt;left; root-&gt;left = NULL; root = root-&gt;right; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"Tree","slug":"Tree","permalink":"http://blog.codeand.fun/tags/Tree/"}]},{"title":"List","slug":"List","date":"2017-10-26T11:01:30.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/10/26/List/","link":"","permalink":"http://blog.codeand.fun/2017/10/26/List/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Construct Binary Tree from Preorder and Inorder Traversal","slug":"Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal","date":"2017-10-25T11:07:13.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/10/25/Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/","link":"","permalink":"http://blog.codeand.fun/2017/10/25/Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/","excerpt":"","text":"第32天。 其实早在很久之前了就想着坚持了一个月之后要发票圈纪念一下的，后来想想其实也没啥必要的，感觉每天早上起来开电脑看题目已经成了习惯了，习惯有啥好纪念的（其实到100天的时候应该还是挺有意义的）。 今天的题目是Construct Binary Tree from Preorder and Inorder Traversal： Given preorder and inorder traversal of a tree, construct the binary tree. Note:You may assume that duplicates do not exist in the tree. 一开始没看到Note，还觉得会有点麻烦，不过既然没有重复元素，写出一个递归解法就很简单了: 123456789101112TreeNode* buildTree1(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; return bulidTreeIter(preorder.begin(),preorder.end(),inorder.begin(),inorder.end());&#125;TreeNode *bulidTreeIter(vector&lt;int&gt;::iterator pBeg,vector&lt;int&gt;::iterator pEnd,vector&lt;int&gt;::iterator iBeg,vector&lt;int&gt;::iterator iEnd) &#123; if (pEnd == pBeg) return nullptr; TreeNode *root = new TreeNode(*pBeg); auto it = find(iBeg,iEnd,*pBeg); int size = it - iBeg; root-&gt;left = bulidTreeIter(pBeg+1,pBeg + size + 1,iBeg,it); root-&gt;right = bulidTreeIter(pBeg+size+1,pEnd,it+1,iEnd); return root;&#125; 恩，貌似是第一次一次Submit就直接过。 然后是在dicuss中看到的迭代算法，但是感觉很复杂的样子,而且效率也不一定比递归版的高。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152TreeNode *buildTree(vector&lt;int&gt; &amp;preorder, vector&lt;int&gt; &amp;inorder) &#123; if(preorder.size()==0) return NULL; stack&lt;int&gt; s; stack&lt;TreeNode *&gt; st; TreeNode *t,*r,*root; int i,j,f; f=i=j=0; s.push(preorder[i]); root = new TreeNode(preorder[i]); st.push(root); t = root; i++; while(i&lt;preorder.size()) &#123; if(!st.empty() &amp;&amp; st.top()-&gt;val==inorder[j]) &#123; t = st.top(); st.pop(); s.pop(); f = 1; j++; &#125; else &#123; if(f==0) &#123; s.push(preorder[i]); t -&gt; left = new TreeNode(preorder[i]); t = t -&gt; left; st.push(t); i++; &#125; else &#123; f = 0; s.push(preorder[i]); t -&gt; right = new TreeNode(preorder[i]); t = t -&gt; right; st.push(t); i++; &#125; &#125; &#125; return root;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"Tree","slug":"Tree","permalink":"http://blog.codeand.fun/tags/Tree/"}]},{"title":"Binary Tree Level Order Traversal","slug":"Binary-Tree-Level-Order-Traversal","date":"2017-10-24T10:29:00.000Z","updated":"2020-04-02T14:43:48.831Z","comments":true,"path":"2017/10/24/Binary-Tree-Level-Order-Traversal/","link":"","permalink":"http://blog.codeand.fun/2017/10/24/Binary-Tree-Level-Order-Traversal/","excerpt":"","text":"第31天。 今天的题目是之前好像就做过的了,Binary Tree Level Order Traversal: Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). For example:Given binary tree [3,9,20,null,null,15,7], 12345 3 / \\9 20 / \\ 15 7 return its level order traversal as: 12345[ [3], [9,20], [15,7]] emmm，简单来讲就是层次遍历. 一般来说，层次遍历都是用队列来实现: 先让root入队，这时我们队列里面就有第一层的所有元素了 我们记录当前层次所拥有的元素的个数size，然后出队size个元素，对于每一个出队的元素，我们遍历它一次，然后将它的左右孩子入队。 1234567891011121314151617181920vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt; &gt; ret; if (root == NULL) return ret; queue&lt;TreeNode *&gt; q; q.push(root); int size = 0; int last = 0; while((size = q.size())) &#123; ret.push_back(vector&lt;int&gt;()); while(size--) &#123; root = q.front(); q.pop(); ret[last].push_back(root-&gt;val); if (root-&gt;left) q.push(root-&gt;left); if (root-&gt;right) q.push(root-&gt;right); &#125; last++; &#125; return ret;&#125; 然后因为这里是返回vector&lt; vector&lt;int&gt; &gt;，而不是直接输出，所以我们可以取个巧，写出一个递归算法出来: 123456789101112131415vector&lt;vector&lt;int&gt; &gt; ret;vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; leverlOrder(root,0); return ret;&#125;void levelOrder(TreeNode* root,int level) &#123; if (root==NULL) return; if (level &gt;= ret.size() ) &#123; ret.push_back(vector&lt;int&gt;()); &#125; ret[level].push_back(root-&gt;val); levelOrder(root-&gt;left,level+1); levelOrder(root-&gt;right,level+1);&#125; 这里其实是先序遍历，但是因为我们一直记录着层数，所以我们还是可以保证vector&lt;vector&lt;int&gt; &gt;的顺序是正确的。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"Tree","slug":"Tree","permalink":"http://blog.codeand.fun/tags/Tree/"}]},{"title":"Validate Binary Search Tree","slug":"Validate-Binary-Search-Tree","date":"2017-10-23T08:39:55.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2017/10/23/Validate-Binary-Search-Tree/","link":"","permalink":"http://blog.codeand.fun/2017/10/23/Validate-Binary-Search-Tree/","excerpt":"","text":"第30天。 恍恍惚惚就一个月了。 今天的题目是Validate Binary Search Tree: Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key.The right subtree of a node contains only nodes with keys greater than the node’s key.Both the left and right subtrees must also be binary search trees.Example 1: 123 2 / \\1 3 Binary tree [2,1,3], return true.Example 2: 123 1 / \\2 3 Binary tree [1,2,3], return false. 昨天的题目也是和BST有关的，但是这里的定义和昨天有点不用，它这里要求左子树的所有节点都比根节点的值要小，右子树的所有的节点的值都比根节点的值大. 我们可以发现这样定义的BST的中序遍历一定是升序的，所以我们可以用先序遍历的方式来做: 12345678long long vmax = LLONG_MIN;bool isValidBST1(TreeNode* root) &#123; if (root == NULL) return true; if ( !isValidBST(root-&gt;left) ) return false; if (root-&gt;val &lt;= vmax) return false; vmax = root-&gt;val; return isValidBST(root-&gt;right); &#125; 既然使用中序遍历做的，那么我们就可以用非递归版的先序遍历来加快: 1234567891011121314151617181920long long vmax = LLONG_MIN;bool isValidBST(TreeNode* root) &#123; stack&lt;TreeNode *&gt; st; while(true) &#123; while(root)&#123; st.push(root); root = root-&gt;left; &#125; if (st.empty()) break; root = st.top(); st.pop(); if (vmax &gt;= root-&gt;val) return false; vmax = root-&gt;val; root = root-&gt;right; &#125; return true;&#125; 上面都是用long long来记录最大值，这时因为如果用INT_MIN来做的话，[INT_MIN,INT_MIN]这样的测例就会出错，我是用long long来解决这个问题的，但是dicuss中有一些其他方法: 1234567891011bool isValidBST(TreeNode* root) &#123; TreeNode* prev = NULL; return validate(root, prev);&#125;bool validate(TreeNode* node, TreeNode* &amp;prev) &#123; if (node == NULL) return true; if (!validate(node-&gt;left, prev)) return false; if (prev != NULL &amp;&amp; prev-&gt;val &gt;= node-&gt;val) return false; prev = node; return validate(node-&gt;right, prev);&#125; 12345678910bool isValidBST(TreeNode* root) &#123; return isValidBST(root, NULL, NULL);&#125;bool isValidBST(TreeNode* root, TreeNode* minNode, TreeNode* maxNode) &#123; if(!root) return true; if(minNode &amp;&amp; root-&gt;val &lt;= minNode-&gt;val || maxNode &amp;&amp; root-&gt;val &gt;= maxNode-&gt;val) return false; return isValidBST(root-&gt;left, minNode, root) &amp;&amp; isValidBST(root-&gt;right, root, maxNode);&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Unique Binary Search Tree","slug":"Unique-Binary-Search-Tree","date":"2017-10-22T08:48:53.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2017/10/22/Unique-Binary-Search-Tree/","link":"","permalink":"http://blog.codeand.fun/2017/10/22/Unique-Binary-Search-Tree/","excerpt":"","text":"第29天。 今天的题目是Unique Binary Search Trees: Given n, how many structurally unique BST’s (binary search trees) that store values 1…n? For example,Given n = 3, there are a total of 5 unique BST’s. 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 对于这种问题一般都可以用递归去做的，我们尝试的找一下递归式。 n=1 -&gt; 1n=2 -&gt; 2n=3 -&gt; 5 我们考虑n=3时的情况,这时这棵树种包含三个值1,2,3,这说明树根的可能是1,2,3中的一个值： 当root=1时，2,3只能放在右子树。现在只考虑2,3两个值，由于BST的性质,右子树也必须是BST，则此时问题转换成求numsTrees(2). 当root=2时，左边必定是1,右边必定是3. 当root=3时，左边必定是1,2，同样转换成numsTrees(2). 我们再考虑一下n=5时的情况： root=3，左子树必定是是包含1,2的BST，右子树必定是包含4,5的BST，此时种类为numsTree(5-3)*numsTrees(3-1)。 所以我们可以找到递推式： n &lt; 2 -&gt; numsTrees(n) = 1 n &gt;= 2 -&gt; numsTrees(n) = numsTrees(1)*numsTrees(n-1) + numsTrees(2)*numTree(n-2) + ... + numsTree(n-1)*numsTrees(1); 所以我们写出一个递归的解决方案: 1234567891011int numTrees(int n) &#123; if (n &lt;= 1) return 1; int ret = 0; for(int i = 1;i &lt;= n;i++) &#123; int left = i-1; int right = n-i; ret += numTrees(left)*numTrees(right); &#125; return ret;&#125; 但是这里会超时，很明显这里可以用动态规划来优化: 12345678910int numTrees(int n) &#123; vector&lt;int&gt; ret(n+1); ret[0] = 1; ret[1] = 1; for(int i = 2;i &lt;= n;i++) &#123; for(int j = 1;j &lt;= i;j++) ret[i] += ret[j-1]*ret[i-j]; &#125; return ret[n];&#125; dicuss中基本都是和上面类似的解法，除了一个: 123456789int numTrees(int n) &#123; //cantalan树 //C(2n,n)/(n+1) long long ans =1; for(int i=n+1;i&lt;=2*n;i++)&#123; ans = ans*i/(i-n); &#125; return ans/(n+1);&#125; emmm,说实话，我没看懂，但是这个方法的确是最快的，只需要O(n)的时间，O(1)的空间。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"动态规划","slug":"动态规划","permalink":"http://blog.codeand.fun/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Word Search","slug":"Word-Search","date":"2017-10-21T11:21:03.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2017/10/21/Word-Search/","link":"","permalink":"http://blog.codeand.fun/2017/10/21/Word-Search/","excerpt":"","text":"第28天。 今天的题目是Word Search： Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. For example,Given board = 12345[ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']] word = “ABCCED”, -&gt; returns true,word = “SEE”, -&gt; returns true,word = “ABCB”, -&gt; returns false. 这道题想起来不难，就是有点繁琐，有几个要点需要考虑： 每个元素只能用一次 字符只要求是临接的，即可能有四个方向需要考虑。 因为每个元素只能用一次，所以我们需要一个方式来记录这个位置是否被使用，简单的方法就是直接用一个二维数组来记录，然后我们需要考虑是否越过边界: 12345678910111213141516171819202122232425262728293031323334353637bool search(vector&lt;vector&lt;char&gt; &gt; &amp;board,vector&lt;vector&lt;bool&gt; &gt; &amp;used,string &amp;word,int beg,int i,int j) &#123; //找到了 if (beg == word.size() ) return true; //边界检测 if (i &lt; 0 || j &lt; 0 || i &gt;= board.size() || j &gt;= board[0].size() ) return false; //检测是否被使用了 if (used[i][j]) return false; //检测是否是想要的字符 if (word[beg] != board[i][j]) return false; //假设这就是正确的路径 used[i][j] = true; //向四个方向查找 if( search(board,used,word,beg+1,i-1,j) || search(board,used,word,beg+1,i+1,j) || search(board,used,word,beg+1,i,j-1) || search(board,used,word,beg+1,i,j+1) ) return true; else &#123; //如果四个方法都失败了，说明了这个路径是错的，所以回溯。 used[i][j] = false; return false; &#125;&#125;bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; //保证至少有一个元素 if (board.size() == 0 || board[0].size() == 0) return false; //创建一个二维数组来记录是否字符是否被使用 vector&lt;bool&gt; vec(board[0].size(),false); vector&lt;vector&lt;bool&gt; &gt; used ( board.size(),vec ); //以每一个点为起点进行查找 for(int i = 0;i &lt; board.size();i++) for(int j = 0;j &lt; board[0].size();j++) &#123; if (word[0] == board[i][j] &amp;&amp; search(board,used,word,0,i,j)) return true; &#125; return false;&#125; 上面的方法使用了一个二维数组来记录元素是否被使用,其实可以直接在board中记录是否被使用: 1234567891011121314151617181920212223242526int m;int n;bool exist(vector&lt;vector&lt;char&gt; &gt; &amp;board, string word) &#123; m=board.size(); n=board[0].size(); for(int x=0;x&lt;m;x++) for(int y=0;y&lt;n;y++) &#123; if(isFound(board,word.c_str(),x,y)) return true; &#125; return false;&#125;bool isFound(vector&lt;vector&lt;char&gt; &gt; &amp;board, const char* w, int x, int y)&#123; if(x&lt;0||y&lt;0||x&gt;=m||y&gt;=n||board[x][y]=='\\0'||*w!=board[x][y]) return false; if(*(w+1)=='\\0') return true; char t=board[x][y]; board[x][y]='\\0'; if(isFound(board,w+1,x-1,y)||isFound(board,w+1,x+1,y)||isFound(board,w+1,x,y-1)||isFound(board,w+1,x,y+1)) return true; board[x][y]=t; return false;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Subsets","slug":"Subsets","date":"2017-10-20T09:28:46.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2017/10/20/Subsets/","link":"","permalink":"http://blog.codeand.fun/2017/10/20/Subsets/","excerpt":"","text":"第27天 今天的题目是Subsets: Given a set of distinct integers, nums, return all possible subsets. Note: The solution set must not contain duplicate subsets. For example,If nums = [1,2,3], a solution is: 12345678910[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 我的做法是用递归的方法去做: 12345678910111213141516171819vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt; vector&lt;int&gt; &gt; ret; vector&lt;int&gt; vec; ret.push_back(vec); subsetsIter(ret,nums,vec,0); return ret;&#125;void subsetsIter(vector&lt; vector&lt;int&gt; &gt; &amp;ret,vector&lt;int&gt; &amp;nums,vector&lt;int&gt; now,int beg) &#123; //if (now.size() == nums.size()) return ; now.push_back(-1); auto rbeg = now.rbegin(); for(int i = beg;i &lt; nums.size();i++) &#123; *rbeg = nums[i]; ret.push_back(now); subsetsIter(ret,nums,now,i+1); &#125; now.pop_back();&#125; 然后是在dicuss中看到的迭代的方法和利用二进制的方法： 123456789101112vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; subs(1, vector&lt;int&gt;()); for (int i = 0; i &lt; nums.size(); i++) &#123; int n = subs.size(); for (int j = 0; j &lt; n; j++) &#123; subs.push_back(subs[j]); subs.back().push_back(nums[i]); &#125; &#125; return subs;&#125; 12345678910vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); int num_subset = pow(2, nums.size()); vector&lt;vector&lt;int&gt; &gt; res(num_subset, vector&lt;int&gt;()); for (int i = 0; i &lt; nums.size(); i++) for (int j = 0; j &lt; num_subset; j++) if ((j &gt;&gt; i) &amp; 1) res[j].push_back(nums[i]); return res; &#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Sort Colors","slug":"Sort-Colors","date":"2017-10-19T12:28:34.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2017/10/19/Sort-Colors/","link":"","permalink":"http://blog.codeand.fun/2017/10/19/Sort-Colors/","excerpt":"","text":"第26天。 今天的题目是个排序问题，经过算法的实验一后，这个问题其实就比较简单啦。 Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note:You are not suppose to use the library’s sort function for this problem. 题目的意思是他会给你一个只包含0,1,2三个数字的数组，你要对他进行排序。 因为里面的值只有三种可能，所以显然要用计数排序,他的时间复杂度是O(n). 用这个例子大概的说明一下计数排序的原理： 现在待排数组里的值只能是0,1,2，所以我们通过一个长度为3的数组来记录0,1,2在待排序列中出现的次数（所以这个排序才叫计数排序），计算各个元素出现的次数我们只需要简单的遍历一遍序列即可，这里的时间复杂度是O(n)。 假如对于一个长度为10的序列，0出现了3次，1出现了4次，2出现了3次，我们又知道0&lt;1&lt;2，所以排完序之后序列的前3个元素一定是0,紧接着的四个元素一定是1，最后三个元素一定是2. 所以计数排序就两个步骤： 遍历待排数组，记录元素出现的次数 通过元素出现的次数，修改待排数组 1234567891011121314void sortColors(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; count(3,0); for(auto i:nums) count[i]++; int i = 0,k = 0; while(k &lt; nums.size()) &#123; while (count[i] == 0) i++; nums[k] = i; k++; count[i]--; &#125;&#125; 然后是在dicuss中看到的，模仿了快排的patition的方法： 1234567void sortColors(int A[], int n) &#123; int second=n-1, zero=0; for (int i=0; i&lt;=second; i++) &#123; while (A[i]==2 &amp;&amp; i&lt;second) swap(A[i], A[second--]); while (A[i]==0 &amp;&amp; i&gt;zero) swap(A[i], A[zero++]); &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"sort","slug":"sort","permalink":"http://blog.codeand.fun/tags/sort/"}]},{"title":"Unique Paths","slug":"Unique-Paths","date":"2017-10-18T10:55:35.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2017/10/18/Unique-Paths/","link":"","permalink":"http://blog.codeand.fun/2017/10/18/Unique-Paths/","excerpt":"","text":"第25天。 感冒真难受！ 今天的题目是Unique Paths: A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there?Note: m and n will be at most 100. 如果自己尝试几次去找的话，我们可以发现在m=1时或n=1时，只要一种可能，然后我们考虑我们现在位于(m,n)点（m!=1,n!=1)，现在要走向(0,0),因为我们被限制到只能向下或下右走，即只能n-1或m-1，所以我们可以找到这样一个等式uniquePaths(m,n) = uniquePaths(m-1,n) + uniquePaths(m,n-1)，当m!=1,n!=1时，所以我们可以很快的写出下面的解决方案： 1234int uniquePaths(int m, int n) &#123; if (m == 1 || n == 1) return 1; return uniquePaths(m-1,n) + uniquePaths(m,n-1);&#125; 但是这个会时间超限，因为我们做了很多重复的计算，因为我们计算uniquePaths(3,2)时需要计算uniquePaths(2,2),而uniquePaths(2,1)也需要计算一遍，这就导致了很多重复计算。 我们考虑使用一个表来记录uniquePaths值，这样就可以减少每次计算的值了: 12345678910111213int uniquePaths(int m, int n) &#123; int *p = new int[m*n]; for(int i = 0;i &lt; n;i++) p[i] = 1; for(int j = 0;j &lt; m;j++) p[n*j] = 1; for(int i = 1;i &lt; m;i++) for(int j = 1;j &lt; n;j++) p[i*n+j] = p[ (i-1)*n +j ] + p[i*n + j - 1]; return p[m*n-1]; &#125; 这样就不会时间超限了。 然后是在dicuss中看到的： 1234567int uniquePaths(int m, int n) &#123; vector&lt;vector&lt;int&gt; &gt; path(m, vector&lt;int&gt; (n, 1)); for (int i = 1; i &lt; m; i++) for (int j = 1; j &lt; n; j++) path[i][j] = path[i - 1][j] + path[i][j - 1]; return path[m - 1][n - 1];&#125; (捂脸)我一直不知道怎么用vector来快速的构造二维数组。 上面的两个的空间复杂度都是O(m*n)，下面的方法可以降成O(2*min(m,n))，因为我们计算某一层的时候其实只需要前一行即可： 1234567891011int uniquePaths(int m, int n) &#123; if (m &gt; n) return uniquePaths(n, m); vector&lt;int&gt; pre(m, 1); vector&lt;int&gt; cur(m, 1); for (int j = 1; j &lt; n; j++) &#123; for (int i = 1; i &lt; m; i++) cur[i] = cur[i - 1] + pre[i]; swap(pre, cur); &#125; return pre[m - 1];&#125; 然后其实还可以继续降低到O(min(m,n)),只需要一个一维数组即可: 12345678int uniquePaths(int m, int n) &#123; if (m &gt; n) return uniquePaths(n, m); vector&lt;int&gt; cur(m, 1); for (int j = 1; j &lt; n; j++) for (int i = 1; i &lt; m; i++) cur[i] += cur[i - 1]; return cur[m - 1];&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"动态规划","slug":"动态规划","permalink":"http://blog.codeand.fun/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Merge-Intervals","slug":"Merge-Intervals","date":"2017-10-17T11:13:24.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/10/17/Merge-Intervals/","link":"","permalink":"http://blog.codeand.fun/2017/10/17/Merge-Intervals/","excerpt":"","text":"第24天 emmm，又是一道10分钟刷完的题目——Merge Intervals Given a collection of intervals, merge all overlapping intervals. For example,Given [1,3],[2,6],[8,10],[15,18],return [1,6],[8,10],[15,18]. 这个题目要考虑的就是怎么才能避免不断的插入删除。 其实再后来尝试优化的时候，就是陷入这个误区，尝试的写一个O(n)的算法出来，但是发现要不断的遍历和插入和删除元素，我们知道这对vector来说时比较耗时的。 我们先确定什么时候两个Intervals需要merge,考虑i1,i2,只有i1.end &gt; i2.start，这时i1和i2就应该merge成{i1.start,i2.end} 先对intervals按start排序 将第一个元素放入ret，因为这时start是最小的，我们现在只需要寻找end即可 我们考察第二个元素，如果第二个元素的start小于第一个元素的end，我们就将修改end,并考察第三个元素，如果不成立，说明当前元素的end就已经找到了（因为start &lt; end） 12345678910111213141516171819202122vector&lt;Interval&gt; merge1(vector&lt;Interval&gt;&amp; intervals) &#123; if (intervals.size() &lt;= 1) return intervals; sort(intervals.begin(),intervals.end(),[](const Interval &amp;a,const Interval b) -&gt; bool&#123; return a.start &lt; b.start; &#125;); vector&lt;Interval&gt; ret; ret.push_back(intervals[0]); int last = 0; for(int i = 1;i &lt; intervals.size();i++) &#123; if (ret[last].end &gt;= intervals[i].start) ret[last].end = max(intervals[i].end,ret[last].end); else &#123; ret.push_back(intervals[i]); last++; &#125; &#125; return ret;&#125; 还有在dicuss中看到的答案，但是这个需要做两次sort，所以效率不会比上面的方法高: 123456789101112131415161718192021public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; // sort start&amp;end int n = intervals.size(); int[] starts = new int[n]; int[] ends = new int[n]; for (int i = 0; i &lt; n; i++) &#123; starts[i] = intervals.get(i).start; ends[i] = intervals.get(i).end; &#125; Arrays.sort(starts); Arrays.sort(ends); // loop through List&lt;Interval&gt; res = new ArrayList&lt;Interval&gt;(); for (int i = 0, j = 0; i &lt; n; i++) &#123; // j is start of interval. if (i == n - 1 || starts[i + 1] &gt; ends[i]) &#123; res.add(new Interval(starts[j], ends[i])); j = i + 1; &#125; &#125; return res;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Jump-Game","slug":"Jump-Game","date":"2017-10-16T09:27:29.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/10/16/Jump-Game/","link":"","permalink":"http://blog.codeand.fun/2017/10/16/Jump-Game/","excerpt":"","text":"第23天 又是周一，心塞，一周过去的真快。 今天的题目是Jump Game. Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. For example:A = [2,3,1,1,4], return true. A = [3,2,1,0,4], return false. 这道题，主要先理解到，他存放的是maximum jump length,也就是说，你可以跳小于这个值的步数。然后自然而然的就想到用递归去做啊： 从后向前考虑，用一个值来记录可以从最后一个位置回去的最小index. 在每一个index中，把当前的index当成是自己的要到达的点，再递归调用自己。 123456789101112bool canJump1(vector&lt;int&gt;&amp; nums) &#123; return canJump1(nums,nums.size() - 1);&#125;bool canJump1(vector&lt;int&gt; &amp;nums,int last) &#123; if (last == 0) return true; int k = 1; for(int i = last-1;i &gt;= 0;i--,k++) &#123; if (nums[i] &gt;= k &amp;&amp; canJump1(nums,i)) return true; &#125; return false;&#125; 然后，这个方法就超时了，做了很多重复的操作。 恩，再仔细看看题目的话，它其实只要求我们返回能否到达，不要求给出跳的方法，所以我们可以换一种思路来考虑，用一个last值来记录当前能到达的最远位置（初始值当然是0啦），然后遍历所有能到的点然后更新当前能到的最远点，如果当前能到的点已经大于nums.size() - 1了，那么说明我们可以到达，如果遍历完所有的点之后还没有大于，说明到不了： 12345678bool canJump2(vector&lt;int&gt; &amp;nums) &#123; int last = 0; for(int i = 0;i &lt;= last &amp;&amp; i &lt; nums.size();i++) &#123; last = max(last,i+nums[i]); if (last &gt;= nums.size()-1) return true; &#125; return false;&#125; 这个的时间复杂度是O(n),尝试过优化，但是没能成功。 最后是在dicuss中看到的方法，其实和上面的想法是一样的，只不过它是从后往前考虑: 123456789bool canJump4(vector&lt;int&gt; &amp;nums) &#123; int last = nums.size() - 1; for(int i=nums.size() - 1;i &gt;= 0;i--) &#123; if (i + nums[i] &gt;= last) &#123; last = i; &#125; &#125; return last &lt;= 0;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Group-Anagrams","slug":"Group-Anagrams","date":"2017-10-15T10:32:00.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/10/15/Group-Anagrams/","link":"","permalink":"http://blog.codeand.fun/2017/10/15/Group-Anagrams/","excerpt":"","text":"第22天，今天刷回了Medium，果然这个难度才适合我。 Given an array of strings, group anagrams together. For example, given: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],Return: 12345[ [\"ate\", \"eat\",\"tea\"], [\"nat\",\"tan\"], [\"bat\"]] Note: All inputs will be in lower-case. 题目很简短，主要的难点是怎样判断两个字符串是同组的（即s1是s2的一个置换），我的想法是利用hash来区分，不过这个hash函数写起来就比较麻烦了，主要是要考虑碰撞： 12345678910unsigned hashString(string &amp;s) &#123; int sum = 1; int count[26]&#123;0&#125;; for(auto c:s) count[c-'a']++; for(int i = 0;i &lt; 26;i++)&#123; sum = sum*133 + count[i]; &#125; return sum;&#125; 然后就是一些细节问题了： 12345678910111213141516vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; vector&lt;vector&lt;string&gt; &gt; ret; unordered_map&lt;unsigned,int&gt; mRet; int now = 0; for(auto &amp;s:strs) &#123; unsigned h = hashString(s); cout &lt;&lt; h &lt;&lt; endl; if (mRet.find(h) == mRet.end())&#123; ret.push_back(&#123;&#125;); mRet[h] = now; now++; &#125; ret[mRet[h]].push_back(s); &#125; return ret;&#125; dicuss中有另外一种hash的方法: 123456789101112131415161718192021public static List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; int[] prime = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103&#125;;//最多10609个z List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (String s : strs) &#123; int key = 1; for (char c : s.toCharArray()) &#123; key *= prime[c - 'a']; &#125; List&lt;String&gt; t; if (map.containsKey(key)) &#123; t = res.get(map.get(key)); &#125; else &#123; t = new ArrayList&lt;&gt;(); res.add(t); map.put(key, res.size() - 1); &#125; t.add(s); &#125; return res; &#125; 额，说实话，里面的数学依据我没看懂，是因为素数只能被1和它本身整除吗？ 然后同样是在dicuss中看到的，对字符串sort来判断是否在同一组的方法： 1234567891011vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; unordered_map&lt;string, vector&lt;string&gt; &gt; anagrams; for (string s: strs) &#123; string sorted = s; sort(sorted.begin(), sorted.end()); anagrams[sorted].push_back(s); &#125; vector&lt;vector&lt;string&gt; &gt; res; for (auto p: anagrams) res.push_back(p.second); return res;&#125; 没想到这道题还有solution,里面有两个方法，一个是用sort的，和上面的差不多。另一个有趣点，通过计数来生成一个新的字符串，然后在hash: 12345678910111213141516171819public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; if (strs.length == 0) return new ArrayList(); Map&lt;String, List&gt; ans = new HashMap&lt;String, List&gt;(); int[] count = new int[26]; for (String s : strs) &#123; Arrays.fill(count, 0); for (char c : s.toCharArray()) count[c - 'a']++; StringBuilder sb = new StringBuilder(\"\"); for (int i = 0; i &lt; 26; i++) &#123; sb.append('#'); sb.append(count[i]); &#125; String key = sb.toString(); if (!ans.containsKey(key)) ans.put(key, new ArrayList()); ans.get(key).add(s); &#125; return new ArrayList(ans.values());&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Median Of Two Sorted Arrays","slug":"MedianOfTwoSortedArrays","date":"2017-10-14T12:47:24.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/10/14/MedianOfTwoSortedArrays/","link":"","permalink":"http://blog.codeand.fun/2017/10/14/MedianOfTwoSortedArrays/","excerpt":"","text":"第21天，尝试了一下hard，结果是完全没做出来。。。从早上8点多到11点半，一直没能AC，最后只好看dicuss中的解法了，然后理解还理解了很久。。。看了现在的我还不适合做hard级别的。 There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).Example 1:nums1 = [1, 3]nums2 = [2] The median is 2.0Example 2:nums1 = [1, 2]nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 因为没做出来，所以只能写写别人的思路了。 我们现在要找的是中位数，那么就有两种情况： 整体长度是奇数，那么中位数是序列中的数 整体长度是偶数，那么中位数是序列中两个数的平均值。 先考虑奇数的情况，因为是序列中的数，所以我们现在要求的就是在两个序列中第（size)/2 + 1大的数。 现在问题转换成在两个序列中求第k个数： 不断的将k减半，并把小的数从序列中排出，每次都能排出掉k/2. 1234567891011121314151617double getKth(vector&lt;int&gt; &amp;nums1,int beg1,int size1,vector&lt;int&gt; &amp;nums2,int beg2,int size2,int k) &#123; //cout &lt;&lt; beg1&lt;&lt;\" \" &lt;&lt;size1&lt;&lt;\"\\t\"&lt;&lt;beg2&lt;&lt;\" \"&lt;&lt;size2&lt;&lt;\"\\t\"&lt;&lt;k&lt;&lt;endl; if (size1 &gt; size2) &#123; return getKth(nums2,beg2,size2,nums1,beg1,size1,k); &#125; if (size1 == 0) &#123; return nums2[beg2 + k-1];&#125; if (k == 1) return min(nums1[beg1],nums2[beg2]); int i = min(size1,k/2); int j = min(size2,k/2); if (nums1[beg1 + i-1] &gt; nums2[beg2 + j-1]) &#123; return getKth(nums1,beg1,size1,nums2,beg2+j,size2-j,k-j); &#125; else return getKth(nums1,beg1+i,size1-i,nums2,beg2,size2,k-i); &#125; 考虑偶数的情况，我们只要找出第(size)/2 + 1和(size)/2的大的数的平均值即可。 将两者统一一下： 123456789double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int l = (nums1.size() + nums2.size() + 1) &gt;&gt; 1; int r = (nums1.size() + nums2.size() + 2) &gt;&gt; 1; //cout &lt;&lt; \"#\" &lt;&lt; l &lt;&lt; r &lt;&lt; endl; double dl = getKth(nums1,0,nums1.size(),nums2,0,nums2.size(),l); double dr = getKth(nums1,0,nums1.size(),nums2,0,nums2.size(),r); //cout &lt;&lt; dl &lt;&lt;dr &lt;&lt; endl; return (dr+dl)/2;&#125; 恩，等下次感觉有能力做了，在来尝试一次！！！","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Permutations","slug":"Permutations","date":"2017-10-13T09:17:05.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/10/13/Permutations/","link":"","permalink":"http://blog.codeand.fun/2017/10/13/Permutations/","excerpt":"","text":"第20天，第二次超级快的刷完了一道题。。。要不明天试试刷hard 今天的题目是Permutations,emmm,之前好像好几次都忘记加地址了。 Given a collection of distinct numbers, return all possible permutations.For example,[1,2,3] have the following permutations: 12345678[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 总感觉之前遇到过类似的题目，然后思路也是很简单的，直接递归的做就好了： 这里如果不算是push_back中的拷贝数组，应该已经是拷贝数组次数最少的了，做的时候以为push_back不会拷贝，不过在dicuss中看的做法是只在push_back中进行拷贝。 123456789101112131415161718vector&lt;vector&lt;int&gt; &gt; ret;vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; //if (nums.size() == 0 || nums.size() == 1) return &#123;nums&#125;; permute(nums,0); return ret;&#125;void permute(vector&lt;int&gt; &amp;nums,int beg) &#123; if (nums.size() - beg &lt;= 1) &#123; ret.push_back(nums); return ; &#125; permute(nums,beg+1); for(int i = beg+1;i&lt;nums.size();i++) &#123; vector&lt;int&gt; vec = nums; swap(vec[beg],vec[i]); permute(vec,beg+1); &#125;&#125; dicuss中的做法： 1234567891011121314151617181920212223vector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; result; permuteRecursive(num, 0, result); return result;&#125;// permute num[begin..end]// invariant: num[0..begin-1] have been fixed/permutedvoid permuteRecursive(vector&lt;int&gt; &amp;num, int begin, vector&lt;vector&lt;int&gt; &gt; &amp;result) &#123; if (begin &gt;= num.size()) &#123; // one permutation instance result.push_back(num); return; &#125; for (int i = begin; i &lt; num.size(); i++) &#123; swap(num[begin], num[i]); permuteRecursive(num, begin + 1, result); // reset swap(num[begin], num[i]); &#125;&#125; 他的做法和我一开始的时候类似，但是我没想到可以换回来。。。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Combination-Sum","slug":"Combination-Sum","date":"2017-10-12T11:24:59.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/10/12/Combination-Sum/","link":"","permalink":"http://blog.codeand.fun/2017/10/12/Combination-Sum/","excerpt":"","text":"第19天 这道题是在起床到去上课前AC出来的，emmm，大概就10多分钟的样子。。。 虽然后来尝试优化了一下，但是感觉效果都不怎么好。。 题目描述： Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. For example, given candidate set [2, 3, 6, 7] and target 7,A solution set is: 1234[ [7], [2, 2, 3]] 其实想法很简单，我既然想求combinationSum(7)，通过遍历数组，我们现在有了一个[2]，我只需要在求combinatiomSum(7-2)即可，然后组合起来： 12345678910111213141516171819202122232425vector&lt;int&gt; cand;vector&lt;vector&lt;int&gt; &gt; ret;vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; cand = candidates; sort(cand.begin(),cand.end()); vector&lt;int&gt; now; combinationSumIter(now,0,target); return ret;&#125;void combinationSumIter(vector&lt;int&gt; &amp;now,int beg,int target)&#123; //cout &lt;&lt; \"target\" &lt;&lt; target &lt;&lt; endl; for(int i = beg;i &lt; cand.size();++i) &#123; if (target &lt; cand[i]) break; else if (target == cand[i]) &#123; vector&lt;int&gt; vec = now; vec.push_back(cand[i]); ret.push_back(vec); &#125; else if (target - cand[i] &gt;= cand[0] )&#123; vector&lt;int&gt; vec = now; vec.push_back(cand[i]); combinationSumIter(vec,i,target-cand[i]); &#125; &#125;&#125; 然后在dicuss中看到的也是类似的想法： 12345678910111213141516171819202122class Solution &#123;public: std::vector&lt;std::vector&lt;int&gt; &gt; combinationSum(std::vector&lt;int&gt; &amp;candidates, int target) &#123; std::sort(candidates.begin(), candidates.end()); std::vector&lt;std::vector&lt;int&gt; &gt; res; std::vector&lt;int&gt; combination; combinationSum(candidates, target, res, combination, 0); return res; &#125;private: void combinationSum(std::vector&lt;int&gt; &amp;candidates, int target, std::vector&lt;std::vector&lt;int&gt; &gt; &amp;res, std::vector&lt;int&gt; &amp;combination, int begin) &#123; if (!target) &#123; res.push_back(combination); return; &#125; for (int i = begin; i != candidates.size() &amp;&amp; target &gt;= candidates[i]; ++i) &#123; combination.push_back(candidates[i]); combinationSum(candidates, target - candidates[i], res, combination, i); combination.pop_back(); &#125; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Search for a Range","slug":"search-for-a-range","date":"2017-10-11T12:42:31.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2017/10/11/search-for-a-range/","link":"","permalink":"http://blog.codeand.fun/2017/10/11/search-for-a-range/","excerpt":"","text":"第18天！！！ 又是一道二分查找的题目： Given an array of integers sorted in ascending order, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. For example,Given [5, 7, 7, 8, 8, 10] and target value 8,return [3, 4]. 时间复杂度要求为O(logn),直接就暗示我们要用二分查找去做啊，但是这个又有限定条件，就是它需要求出范围，自然而然的就想到先用二分查找，然后从找到的点向两边去寻找边界。 相当简单的方法，但是如果遇到1,2,2,2,2,2,2,2,3这样的序列，就变成了O(n)的时间复杂度。 然后就可以自然而然的想到，做多两次二分查找,在序列nums[0:mid]中寻找左边界，nums[mid:]中寻找右边界，不然如果要是用二分查找的方法去做的话，就需要转换一下，我们找左边界的前一个元素，右边界的后一个元素，这样会方便一点。 1234567891011121314151617181920212223242526272829303132333435363738vector&lt;int&gt; searchRange1(vector&lt;int&gt;&amp; nums, int target) &#123; int first = 0,last = nums.size() - 1,mid; vector&lt;int&gt; ret&#123;-1,-1&#125;; while(first &lt;= last) &#123; mid = (first + last)/2; if (nums[mid] == target)&#123; break; &#125; else if (nums[mid] &lt; target) first = mid+1; else last = mid - 1; &#125; int l = mid,f = mid; ret[0] = first; ret[1] = last; while(first &lt;= l) &#123; int m = (first + l)/2; if (nums[m] == nums[mid]) l = m - 1; else if (nums[m+1] != nums[mid]) first = m + 1; else &#123; ret[0] = m+1; break; &#125; &#125; while(f &lt;= last) &#123; int m = (f + last)/2; if (nums[m] == nums[mid]) f = m + 1; else if (nums[m-1] != nums[mid]) last = m - 1; else &#123; ret[1] = m - 1; break; &#125; &#125; return ret;&#125; 这个思路很简单，也很好实现，就是代码会复杂一点，三个循环其实长得差不多，但是你不能合并起来，所以换一种思路尝试一下： 我们找到一个与target相等的值nums[mid]，我们对nums[0,mid-1]再进行一次二分查找： 如果查找失败， 那么说明当前mid就是左边界 如果找到了，我们就更新mid，再对nums[0:mid-1]进行查找，直到查找失败。 对右边界做同样的事，我们就得到答案了。 123456789101112131415161718192021vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; ret&#123;-1,-1&#125;; int mid = nums.size(); while( (mid = searchRangeIter(nums,0,mid-1,target) ) != -1) ret[0] = mid; //mid = -1; while( (mid = searchRangeIter(nums,mid+1,nums.size() - 1,target)) != -1) ret[1] = mid; return ret;&#125;int searchRangeIter(vector&lt;int&gt; nums,int first,int last,int target) &#123; while(first &lt;= last) &#123; int mid = (first + last)/2; if (nums[mid] == target)&#123; return mid; &#125; else if (nums[mid] &lt; target) first = mid+1; else last = mid - 1; &#125; return -1;&#125; 在dicuss中看到一个更简洁的迭代的方法： 123456789101112131415161718192021222324vector&lt;int&gt; searchRange(int A[], int n, int target) &#123; int i = 0, j = n - 1; vector&lt;int&gt; ret(2, -1); // Search for the left one while (i &lt; j) &#123; int mid = (i + j) /2; if (A[mid] &lt; target) i = mid + 1; else j = mid; &#125; if (A[i]!=target) return ret; else ret[0] = i; // Search for the right one j = n-1; // We don't have to set i to 0 the second time. while (i &lt; j) &#123; int mid = (i + j) /2 + 1;// Make mid biased to the right if (A[mid] &gt; target) j = mid - 1; else i = mid;// So that this won't make the search range stuck. &#125; ret[1] = j; return ret;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"查找","slug":"查找","permalink":"http://blog.codeand.fun/tags/%E6%9F%A5%E6%89%BE/"}]},{"title":"Next-Permutation","slug":"Next-Permutation","date":"2017-10-10T12:50:17.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/10/10/Next-Permutation/","link":"","permalink":"http://blog.codeand.fun/2017/10/10/Next-Permutation/","excerpt":"","text":"打卡，第17天 恩，又是一道有趣的题目，不知不觉刷了12道Medium级别的题目了，要不要找个时间试试hard的？？ Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place, do not allocate extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 我们再观察几个示例： 1,2,5,4,3 -&gt; 1,3,2,4,51,3,2,5,4 -&gt; 1,3,4,2,5 我们的目的是：让这个序列变大一点，显然从后向前考虑会比较容易得出结果。 对于1,2,5,4,3，观察序列的最后，我们可以发现4,3是降序的，我们要让整个序列变得大一点，显然如果只修改对于5,4,3这个序列的顺序，我们是没法让整个序列变大的，所以我们要引入下一个数字，但是5,4,3也是降序的，所以我们也无法只修改后三个数字来是的序列变大，但是如果考虑2,5,4,3，这个序列再变大一点就是3,2,4,5,如果多试几次的话，就可以找出规律了： 我们从后向前找一个最长升序序列nums[i:] 如果i=0，按照题目要求，我们就应该给出一个最小的组合，就直接对nums进行排序即可。 如果i!=0，那么我们从后向前找第一个比nums[i-1]大的数字nums[k]，而且我们肯定能找出。交换nums[i-1]和nums[k],然后再对nums[i:]进行一个排序即可。 123456789101112131415void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; for(int i = nums.size() - 1;i &gt; 0;i--)&#123; if (nums[i-1] &lt; nums[i])&#123; int key = nums[i -1]; int j; for(j = i;j &lt; nums.size() &amp;&amp; nums[j] &gt; key;j++) /*do nothing*/; cout &lt;&lt; nums[j-1] &lt;&lt;\" \" &lt;&lt; nums[i-1]; swap(nums[j-1],nums[i-1]); sort(nums.begin() + i,nums.end()); return ; &#125; &#125; sort(nums.begin(),nums.end());&#125; 这样的话，时间复杂度是O(nlogn)了。其实我们要排序的序列，在某种程度上来说，他其实是降序的，我们只需要把降序换成升序即可。 123456789101112131415161718192021void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int i,j = -1; for(i = nums.size() - 1;i &gt; 0 &amp;&amp; nums[i-1]&gt;= nums[i] ;i--) /*do nothing*/; int first = i,last = nums.size()-1; while(first &lt;= last) &#123; if (i &gt; 0 &amp;&amp; nums[last] &gt; nums[i-1]) &#123; swap(nums[i-1],nums[last]); break; &#125; else if (i &gt; 0 &amp;&amp; nums[first+1] &lt;= nums[i-1] ) &#123; swap(nums[i-1],nums[first]); break; &#125; swap(nums[first++],nums[last--]); &#125; while(first &lt; last) swap(nums[first++],nums[last--]); return ;&#125; 还可以先对nums[i:]进行reverse,在找出第一个比nums[i-1]大的数和nums[i-1]进行交换。 123456789101112131415161718192021void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() &lt; 2) return ; int i,j = -1; for(i = nums.size() - 1;i &gt; 0 &amp;&amp; nums[i-1]&gt;= nums[i] ;i--) /*do nothing*/; int first = i,last = nums.size()-1; while(first &lt; last) swap(nums[first++],nums[last--]); //cout &lt;&lt; i &lt;&lt; endl; if (i &gt; 0) &#123; auto beg = nums.begin() + i; auto it = lower_bound(beg,nums.end(),nums[i-1]); //cout &lt;&lt; *it &lt;&lt; endl; while (*it == nums[i-1]) it++; //cout &lt;&lt; *it &lt;&lt; nums[i-1] &lt;&lt; endl; swap(*it,nums[i-1]); &#125; return ;&#125; 由于dicuss中的都大同小异，所以就不贴dicuss中的算法了。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Search-in-Rotated-Sorted-Array","slug":"Search-in-Rotated-Sorted-Array","date":"2017-10-09T20:47:01.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2017/10/09/Search-in-Rotated-Sorted-Array/","link":"","permalink":"http://blog.codeand.fun/2017/10/09/Search-in-Rotated-Sorted-Array/","excerpt":"","text":"打卡，第16天 失眠的感觉真难受。。。一天都想睡觉，但是却睡不着，sad。 Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. 在有序的数组中进行查找，显然第一个想到的就是二分查找啦，不过题目给的数组是多了一个限定条件，就是这个数组被rotated了，所以，显然直接用二分查找是不行的。 观察4 5 6 7 0 1 2，我们可以发现如果我们可以找到7这个位置，我们就可以得到两个有序数组，可以进行二分查找，所以一个简单直观的想法就是： 1234567if (nums[first] &gt; nums[last]) &#123; while(last &gt;= 0 &amp;&amp; nums[first] &gt; nums[last] &amp;&amp; nums[last] &lt; target) last--; while(first &lt;= last &amp;&amp; nums[first] &gt; nums[last] &amp;&amp; nums[first] &gt; target) first++;&#125;//binarySearch 但是这样的时间复杂度就是O(n)了，显然不是我们想要的结果，我们可以对这个转折点进行一次二分查找： 123456789101112131415if(nums[first] &gt; nums[last]) &#123; int f= first,l = last; //找转折点 while(f &lt;= l) &#123; mid = (f + l)/2; if (nums[mid] &gt; nums[mid + 1]) break; else if (nums[mid] &gt; nums[first]) f = mid + 1; else if (nums[mid] &lt; nums[last]) l = mid; &#125; if (target &gt; nums[last]) last = mid; else if (target &lt; nums[first]) first = mid + 1; else if (target == nums[first]) return first; else return last;&#125;//binary Serarch 这样的时间复杂度就是O(2*logn)了。 完整代码： 123456789101112131415161718192021222324252627282930int search(vector&lt;int&gt;&amp; nums, int target) &#123; int first = 0,last = nums.size() - 1; int mid; if (last &lt; 0) return -1; if(nums[first] &gt; nums[last]) &#123; int f= first,l = last; //找转折点 while(f &lt;= l) &#123; mid = (f + l)/2; if (nums[mid] &gt; nums[mid + 1]) break; else if (nums[mid] &gt; nums[first]) f = mid + 1; else if (nums[mid] &lt; nums[last]) l = mid; &#125; if (target &gt; nums[last]) last = mid; else if (target &lt; nums[first]) first = mid + 1; else if (target == nums[first]) return first; else return last; &#125; cout &lt;&lt; first &lt;&lt; last; //binary search while(first &lt;= last) &#123; int mid = (first + last)/2; if (nums[mid] == target) return mid; else if (nums[mid] &lt; target) first = mid + 1; else last = mid - 1; &#125; return -1;&#125; 不过显然这不是最优的方法啦，毕竟要O(2*logn),事实上只需要对二分查找进行修改，就可以直接运用了,恩，这是在dicuss中看到的方法： 1234567891011121314151617181920212223public int search(int[] A, int target) &#123; int lo = 0; int hi = A.length - 1; while (lo &lt; hi) &#123; int mid = (lo + hi) / 2; if (A[mid] == target) return mid; if (A[lo] &lt;= A[mid]) &#123; if (target &gt;= A[lo] &amp;&amp; target &lt; A[mid]) &#123; hi = mid - 1; &#125; else &#123; lo = mid + 1; &#125; &#125; else &#123; if (target &gt; A[mid] &amp;&amp; target &lt;= A[hi]) &#123; lo = mid + 1; &#125; else &#123; hi = mid - 1; &#125; &#125; &#125; return A[lo] == target ? lo : -1;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"Search","slug":"Search","permalink":"http://blog.codeand.fun/tags/Search/"}]},{"title":"Generate Parentheses","slug":"Generate-Parentheses","date":"2017-10-08T11:16:45.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/10/08/Generate-Parentheses/","link":"","permalink":"http://blog.codeand.fun/2017/10/08/Generate-Parentheses/","excerpt":"","text":"打卡，第15天 今天做了一道比较好玩的题，之前有做个一个括号匹配的题目，今天的题目刚好反过来，不是验证括号是否正确，而是生成正确括号——Generate Parentheses. 题目描述： Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: 1234567[ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"] 再看看n = 2时： 1234[ \"(())\", \"()()\",] 我们观察上面的例子，可以发现n=3,其实是由n=2加上一个()组合起来的，可以分成三种情况： 在前面加上(), 在后面加上(), 在前面加上(后面加上) 我们大概可以写出这样的代码： 12345678910111213vector&lt;string&gt; generateParenthesis1(int n) &#123; if (n == 1) return &#123;\"()\"&#125;; set&lt;string&gt; ret; vector&lt;string&gt; r = generateParenthesis(n-1); for(auto s:r)&#123; ret.insert(s+\"()\"); ret.insert(\"()\" + s); ret.insert(\"(\" + s + \")\"); &#125; return &#123;ret.begin(),ret.end()&#125;;&#125; 这样在n &lt;= 3时是ok的，但是如果n = 4还有一种可能，就是(())(()),这时由两个n=2的括号组合而成的，以及n = 5时，可以由n = 3和n = 2组合而成，也可以由n = 1和n = 4组合而成。 故我们可以做以下改进，得到正确答案： 1234567891011121314151617181920212223vector&lt;string&gt; generateParenthesis1(int n) &#123; if (n == 1) return &#123;\"()\"&#125;; set&lt;string&gt; ret; vector&lt;string&gt; r = generateParenthesis(n-1); for(auto s:r)&#123; ret.insert(s+\"()\"); ret.insert(\"()\" + s); ret.insert(\"(\" + s + \")\"); &#125; for(int i = n/2;i &gt; 1;i--) &#123; vector&lt;string&gt; r1 = generateParenthesis(n - i); vector&lt;string&gt; r2 = generateParenthesis(i); for(auto s1:r1) for(auto s2:r2) &#123; ret.insert(s1+s2); ret.insert(s2+s1); &#125; &#125; return &#123;ret.begin(),ret.end()&#125;;&#125; 可以发现，这里出现了很多次重复计算，可以用动态规划去做： 1234567891011121314151617181920212223242526272829vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;vector&lt;string&gt; &gt; par&#123; &#123;\"\"&#125; &#125;; for(int i = 1;i &lt;= n;i++) &#123; set&lt;string&gt; now; for(auto s:par[i-1]) &#123; now.insert(s + \"()\"); now.insert(\"()\" + s); now.insert(\"(\" + s + \")\"); &#125; int l = 1; int r = i - l; while(r &gt;= l) &#123; //cout &lt;&lt; l &lt;&lt; \" \" &lt;&lt; r &lt;&lt; endl; for(auto s1:par[l]) for(auto s2:par[r])&#123; //cout &lt;&lt; s1 &lt;&lt; \" \" &lt;&lt; s2 &lt;&lt; endl; now.insert(s1+s2); now.insert(s2+s1); &#125; l++; r--; &#125; par.push_back(&#123;now.begin(),now.end()&#125;); &#125; return par[n];&#125; 然后是在discuss中看到的另一种思路： 123456789101112131415161718192021222324252627vector&lt;string&gt; result;vector&lt;string&gt; generateParenthesis(int n) &#123; helper(\"\", n, 0); return result;&#125;/* this hepler function insert result strings to \"vector&lt;string&gt; result\" When number of '(' less than \"n\", can append '('; When number of '(' is more than number of ')', can append ')'; string s : current string; int leftpare_need : number of '(' that have not put into \"string s\"; int moreleft : number of '(' minus number of ')' in the \"string s\";*/void helper(string s, int leftpare_need, int moreleft)&#123; if(leftpare_need == 0 &amp;&amp; moreleft == 0) &#123; result.push_back(s); return; &#125; if(leftpare_need &gt; 0) helper(s + \"(\", leftpare_need - 1, moreleft+1); if(moreleft &gt; 0) helper(s + \")\", leftpare_need, moreleft - 1);&#125; 这个的想法是，不断的生成左括号，有左括号，后面就一定会生成一个右括号。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Remove Nth Node From End of List","slug":"Remove-Nth-Node-From-End-of-List","date":"2017-10-07T13:57:00.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/10/07/Remove-Nth-Node-From-End-of-List/","link":"","permalink":"http://blog.codeand.fun/2017/10/07/Remove-Nth-Node-From-End-of-List/","excerpt":"","text":"打卡，第14天 今天的题目是Remove Nth Node From End of List,一开始以为是道很简单的题目，后来看dicuss时才发现是自己没看清题目。 Given a linked list, remove the nth node from the end of list and return its head. For example,Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.Note:Given n will always be valid.Try to do this in one pass. 一开始没看到Try to do this in one pass.,然后就用两遍遍历方法去做了: 1234567891011121314151617181920212223int getRightN(ListNode *head,int n) &#123; ListNode *p = head; int size = 0; while(p != nullptr) &#123; p = p-&gt;next; size++; &#125; return size - n;&#125;ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode h(0); h.next = head; ListNode *p = &amp;h; int k = getRightN(p,n); while(--k) p=p-&gt;next; head = p-&gt;next; p-&gt;next = head-&gt;next; delete head; return h.next;&#125; 上面这个方法太简单了，还是看看在dicuss中的方法吧： 1234567891011121314151617181920212223242526ListNode *removeNthFromEnd(ListNode *head, int n) &#123; if (!head) return nullptr; ListNode new_head(-1); new_head.next = head; ListNode *slow = &amp;new_head, *fast = &amp;new_head; for (int i = 0; i &lt; n; i++) fast = fast-&gt;next; while (fast-&gt;next) &#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; ListNode *to_de_deleted = slow-&gt;next; slow-&gt;next = slow-&gt;next-&gt;next; delete to_be_deleted; return new_head.next;&#125; 这个看起来会比较简单，想法就是利用快慢指针去做，先让fast指针先走n步，然后在fast指针和slow指针一起移动，这样fast和slow始终保持着n个节点的距离，当fast为最后一个节点时，slow就指向倒数第n+1个节点，这时就可以把倒数第n个节点删掉了。 有一个更简洁的版本，不过有点难懂就是了： 123456789101112131415ListNode* removeNthFromEnd(ListNode* head, int n)&#123; ListNode** t1 = &amp;head, *t2 = head; for(int i = 1; i &lt; n; ++i) &#123; t2 = t2-&gt;next; &#125; while(t2-&gt;next != NULL) &#123; t1 = &amp;((*t1)-&gt;next); t2 = t2-&gt;next; &#125; *t1 = (*t1)-&gt;next; return head;&#125; 这个和上一个的思路其实是完全一样的，只是实现方法思路不一样就是，这里的t1是指向某个节点(包括一开始时虚拟的头结点）的next指针的指针。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"链表","slug":"链表","permalink":"http://blog.codeand.fun/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"Letter Combinations of a Phone Number","slug":"Letter-Combinations-of-a-Phone-Number","date":"2017-10-06T16:33:22.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/10/06/Letter-Combinations-of-a-Phone-Number/","link":"","permalink":"http://blog.codeand.fun/2017/10/06/Letter-Combinations-of-a-Phone-Number/","excerpt":"","text":"打卡，第13天 昨晚贼晚睡，然后今天就快吃午饭才起来，然后我又躺尸了一个下午。。。 今天刷了一道Medium的题目—— Letter Combinations of a Phone Number，不过感觉好水，就和学校oj一样水。。。 Given a digit string, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below.Input:Digit string “23”Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].Note:Although the above answer is in lexicographical order, your answer could be in any order you want. 恩，大概思路就是要求letterCombinations(digits),我们就需要求letterCombinations(digits.substr(0,n-1). 然后把这个思路转换迭代的方式就成了： 123456789101112131415vector&lt;string&gt; letterCombinations(string digits) &#123; static vector&lt;string&gt; sMap &#123;\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"&#125;; vector&lt;string&gt; ret; if (digits.size() == 0) return ret; ret.push_back(\"\"); for(int i = 0;i &lt; digits.size();i++) &#123; vector&lt;string&gt; now; for(auto c:sMap[digits[i] - '0']) &#123; for(auto s:ret) now.push_back(s+c); &#125; ret.swap(now); &#125; return ret;&#125; 思路很简单，实现起来也很简单，没什么好提的，而且dicuss中的思路也很这个差不多，不过还是总结一下吧： c++ 中 char转string真心麻烦: 用stringstream很优雅，但是也很麻烦，而且只适用于要平凡从尾部插入的情况,不过这个方法结合io可以做很多漂亮的转换 用&quot;&quot; + c,之前的时候用的时候好像是可以的，但是刚才在做题的时候是不行的会出现一些奇怪的字符串。 最后是比较简单，可以常用的方法：string(1,c),可以把1换成其他数字以获取有重复字符的字符串。 然后是在dicuss中看到的vector的swap方法，有些情况应该还是不错的，可以提高效率，它应该是直接交换底层指针。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"串","slug":"串","permalink":"http://blog.codeand.fun/tags/%E4%B8%B2/"}]},{"title":"Longest SubString with At Least K Repeating Characters","slug":"Longest-SubString-with-At-Least-K-Repeating-Characters","date":"2017-10-05T13:22:54.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/10/05/Longest-SubString-with-At-Least-K-Repeating-Characters/","link":"","permalink":"http://blog.codeand.fun/2017/10/05/Longest-SubString-with-At-Least-K-Repeating-Characters/","excerpt":"","text":"打卡，第12天 今天刷的题目是Longest Substring with At Least K Repeating Characters: Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times. Input:s = “aaabb”, k = 3 Output:3 The longest substring is “aaa”, as ‘a’ is repeated 3 times. Input:s = “ababbc”, k = 2 Output:5 The longest substring is “ababb”, as ‘a’ is repeated 2 times and ‘b’ is repeated 3 times. 本来是以为像Longest Substring Without Repeating Characters一样用两个下标去遍历，然后动态规划的去做（问题来了？动态规划是什么。。。我竟然还没有去翻，拖延症又犯了），一开始发现我可能需要在遍历前先知道当前字符是否会出现k次啊，恩，那就先用一个unordered_map去遍历一遍字符串来记录出现的次数吧： 123unordered_map&lt;char,int&gt; count;for(auto c:s) ++count[c]; 然后就开始思考什么时候i应该向前移动了，当s[j]出现的次数小于k时,i就应该变成j+1了，恩，这个时候我就应该计算s[i,j]的长度,显然不能直接是j-i来算长度啦，因为在以下情况时，它就失灵了： Input: s = “ababacb” k = 3 如果直接j-i的话，就会得出5，但是显然在这个子串中，b只出现了两次，所以我们还要回去检查一遍，然后就开始想要怎么计算长度，大概需要一个下标t从i一直往j移动，遍移动遍计算，那么问题来了，我怎么知道什么时候t应该往前走，什么时候应该计算，恩，干脆先遍历一遍计算一下出现次数，然后我才能知道什么计算。。。突然发现有点不对，我好像写的代码是重复的，恩，按照这个逻辑一直走下去，好像我会一直递归这个过程，想了想就写成递归的形式吧，看起来好像就莫名其妙的写出了一个用分治法的解法了： 先遍历一遍计算整个串中出现的次数 然后开始从头遍历，找出一个t使得count[ s[t] ] &lt; k 找到了，我们就分别计算s[i:t]和s[t+1:j]的最大长度即可 没找到，那么说明整个串是符合的，我们直接返回串长度即可 递归结束的条件就是当串长度比k小的时候啦。 123456789101112131415161718192021222324252627string s; //为了减少递归传递而设置的全局变量int t;int longestSubstring(string ss, int tt) &#123; if (tt &lt;= 1) return ss.size(); s = ss; t = tt; unordered_map&lt;char,int&gt; count; for(auto c:s) ++count[c]; return longestSubString(0,s.size(),count);&#125;int longestSubString(int beg,int end,unordered_map&lt;char,int&gt; &amp;imap )&#123; if (end - beg &lt; t) return 0; int j; for(j = beg;j &lt; end &amp;&amp; imap[s[j]] &gt;= t;j++) /*do nothing*/; if (j == end) return end - beg; unordered_map&lt;char,int&gt; right; for(int k = beg;k &lt; j;k++)&#123; --imap[ s[k] ];//重复利用imap，减少空间复杂度 ++right[ s[k] ]; &#125; return max(longestSubString(beg,j,right), longestSubString(j+1,end,imap));&#125; 有一点要注意的就是：如果是使用map而不是unordered_map的话，时间是会超限的。 然后是在dicuss中看到的解法： 下面这个的解法和我的类似，他的会比较简洁，不过应该没我的快，因为他每次都需要递归都是直接传递string的，而且调用s.substr其实挺耗费时间的，应该每次都是深拷贝。 1234567891011121314int longestSubstring(string s, int k) &#123; if(s.size() == 0 || k &gt; s.size()) return 0; if(k == 0) return s.size(); unordered_map&lt;char,int&gt; Map; for(int i = 0; i &lt; s.size(); i++)&#123; Map[s[i]]++; &#125; int idx =0; while(idx &lt;s.size() &amp;&amp; Map[s[idx]] &gt;= k) idx++; if(idx == s.size()) return s.size(); int left = longestSubstring(s.substr(0 , idx) , k); int right = longestSubstring(s.substr(idx+1) , k); return max(left, right); &#125; 第二个是用迭代的方法做的，比较快点，但是好像最坏情况是会出现O(n^2)的时间复杂度： 123456789101112131415161718192021int longestSubstring(string s, int k) &#123; int max_len = 0; for (int first = 0; first+k &lt;= s.size();) &#123; int count[26] = &#123;0&#125;; int mask = 0; int max_last = first; for (int last = first; last &lt; s.size(); ++last) &#123; int i = s[last] - 'a'; count[i]++; if (count[i]&lt;k) mask |= (1 &lt;&lt; i); else mask &amp;= (~(1 &lt;&lt; i)); if (mask == 0) &#123; max_len = max(max_len, last-first+1); max_last = last; &#125; &#125; first = max_last + 1; &#125; return max_len;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"串","slug":"串","permalink":"http://blog.codeand.fun/tags/%E4%B8%B2/"}]},{"title":"Characters","slug":"Characters","date":"2017-10-05T13:21:03.000Z","updated":"2020-04-02T14:43:48.831Z","comments":true,"path":"2017/10/05/Characters/","link":"","permalink":"http://blog.codeand.fun/2017/10/05/Characters/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"4Sum_2","slug":"4Sum-2","date":"2017-10-04T10:59:17.000Z","updated":"2020-04-02T14:43:48.831Z","comments":true,"path":"2017/10/04/4Sum-2/","link":"","permalink":"http://blog.codeand.fun/2017/10/04/4Sum-2/","excerpt":"","text":"打卡,第11天。 今天刷的题是4Sum II, Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero. To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -2^28 to 2^28 - 1 and the result is guaranteed to be at most 2^31 - 1. Example: Input:A = [ 1, 2]B = [-2,-1]C = [-1, 2]D = [ 0, 2]Output:2 Explanation: The two tuples are: (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0 (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0 这道题如果贼容易写出一个时间超限的题目，比如简单的四重循环。 一开始老是会出现时间超限的情况，想着要把时间复杂度将下来，就想着把他转换成2Sum去做，于是就用就先把A和B的和放在一个vector中，同理也把C和D的和放在一个vector中。天真的以为这样就可以把时间复杂度降下来了。。。然而这两个vector的大小分别是A.size()*B.size()和C.size()*D.size(),然后一直没想出来怎么搞，突然想起来昨天在《像程序员一样思考》中看到的削减问题的方法，就开始考虑两个数组的的情况。 显然如果不对数组进行排序的话，肯定是要用两个循环对所有元素遍历的，然后就考虑如果数组是排好序的话，要怎么才能减少一些不必要的遍历，如果一个较小的数一定需要一个较大的数才能使得和为0，所以一个数组从前向后遍历，一个数组从后向前进行遍历。因为数组已经有序了，所以第一个数组越前面的元素（越小）就需要第二个数组越后面的的元素（越大），可以找到一下规律： sum &gt; 0 -&gt; j– sum &lt; 0 -&gt; i++ sum == 0 -&gt; count++;j–,i++ 当然如果直接这样写的话可能会漏掉一些重复元素，所以还需要一些修改,但是大体的思路已经出来了，所以直接上代码把： 123456789101112131415161718192021222324252627282930313233int fourSumCount(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C, vector&lt;int&gt;&amp; D) &#123; int count = 0; vector&lt;int&gt; v1 (A.size()*B.size() ), v2(C.size()*D.size()); int k = 0; for(auto c:C) for(auto d:D) v2[k++] = c+d; k = 0; for(auto a:A) for(auto b:B) v1[k++] = a+b; sort(v1.begin(),v1.end()); sort(v2.begin(),v2.end()); int i = 0,j = v2.size() - 1; int sum; while(i &lt; v1.size() &amp;&amp; j &gt;= 0)&#123; sum = v1[i] + v2[j]; if (sum &gt; 0) j--; else if (sum &lt; 0) i++; else &#123; int k1 = 1,k2 = 1; //处理重复元素的情况 while(i + 1&lt; v1.size() &amp;&amp; v1[i + 1 ] == v1[i])&#123; k1++; i++; &#125; while(j &gt; 0 &amp;&amp; v2[j-1] == v2[j]) &#123; k2++; j--; &#125; i++; j--; count += k1*k2; &#125; &#125; return count;&#125; 然后是看看dicuss中别人的解法： 123456789101112131415161718 int fourSumCount(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C, vector&lt;int&gt;&amp; D) &#123; unordered_map&lt;int, int&gt; abSum; for(auto a : A) &#123; for(auto b : B) &#123; ++abSum[a+b]; &#125; &#125; int count = 0; for(auto c : C) &#123; for(auto d : D) &#123; auto it = abSum.find(0 - c - d); if(it != abSum.end()) &#123; count += it-&gt;second; &#125; &#125; &#125; return count;&#125; 他使用unordered_map来完成的耶,在c++的STL中，map是用的红黑树，find的时间复杂度是O(nlogn),而unordered_map是hash table,所以find的时间复杂度是O(1)，突然发现一个好用的东西。。。 貌似今天是中秋，恩，中秋快乐！！ 可惜喉咙发炎没法吃月饼。。。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"LongestPalindromicSubString","slug":"LongestPalindromicSubString","date":"2017-10-03T11:14:39.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/10/03/LongestPalindromicSubString/","link":"","permalink":"http://blog.codeand.fun/2017/10/03/LongestPalindromicSubString/","excerpt":"","text":"打卡，第10天 今天刷的题是Longest Palindromic Substring,开始想着用动态规划做，但是我好像连动态规划是什么我都不知道。。。 题目: Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example: Input: “babad” Output: “bab” Note: “aba” is also a valid answer.Example: Input: “cbbd” Output: “bb” 所以一如既往的想到了分治法: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748bool isPalindrome(string &amp;s,int first,int last)&#123; while(first &lt; last &amp;&amp; s[first] == s[last])&#123; first++; last--; &#125; if (first &gt;= last) return true; else return false;&#125;string longestPalindrome(string s) &#123; int retF,retL; int l = longestPalindrome(s,0,s.size() -1 ,retF); return s.substr(retF,l);&#125;int longestPalindrome(string &amp;s,int first,int last,int &amp;retF)&#123; if (first &lt; last)&#123; int lF,rF,mF; int mid = (first + last)/2; //分 //治 int l = longestPalindrome(s,first,mid,lF); int r = longestPalindrome(s,mid + 1,last,rF); int ret = max(l,r); //合，已知 int midMax = ret; for(int i = first;i &lt;=mid ;i++) for(int j = mid + 1;j &lt;= last;j++)&#123; if (j-i +1 &gt; midMax &amp;&amp; isPalindrome(s,i,j))&#123; midMax = j-i+1; mF = i; &#125; &#125; if (midMax &gt; ret)&#123; retF = mF; return midMax; &#125; else if (ret == l)&#123; retF = lF; &#125; else&#123; retF = rF; &#125; return ret; &#125; else if (first == last ) &#123; retF = first; return 1; &#125; else &#123; retF = first; return 0; &#125;&#125; 大概的思路是： 先用分治法将问题规模不断减半，那么现在只需要考虑如何“合”了 这里”合”的时间复杂度是O(n^2)，没能找出更快的，嗯，不对，好像是O(n^3)…. whatever，这里的合就是用穷举法去做的，不过不知道为什么还是过了测试 然后是dicuss中的解法： 123456789101112131415string longestPalindrome(string s) &#123; if (s.empty()) return \"\"; if (s.size() == 1) return s; int min_start = 0, max_len = 1; for (int i = 0; i &lt; s.size();) &#123; if (s.size() - i &lt;= max_len / 2) break; int j = i, k = i; while (k &lt; s.size()-1 &amp;&amp; s[k+1] == s[k]) ++k; // Skip duplicate characters. i = k+1; while (k &lt; s.size()-1 &amp;&amp; j &gt; 0 &amp;&amp; s[k + 1] == s[j - 1]) &#123; ++k; --j; &#125; // Expand. int new_len = k - j + 1; if (new_len &gt; max_len) &#123; min_start = j; max_len = new_len; &#125; &#125; return s.substr(min_start, max_len);&#125; emmm,这里好像也是用点穷举的感觉。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"串","slug":"串","permalink":"http://blog.codeand.fun/tags/%E4%B8%B2/"},{"name":"分治法","slug":"分治法","permalink":"http://blog.codeand.fun/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"}]},{"title":"Maximum Product Subarray","slug":"MaximumProductSubarray","date":"2017-10-02T14:58:46.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/10/02/MaximumProductSubarray/","link":"","permalink":"http://blog.codeand.fun/2017/10/02/MaximumProductSubarray/","excerpt":"","text":"打卡，第9天 今天这道题做了好久。。。 Find the contiguous subarray within an array (containing at least one number) which has the largest product. For example, given the array [2,3,-2,4],the contiguous subarray [2,3] has the largest product = 6. 看到这道题，就让我想起了昨天做得那道Longest Substring Without Repeating Characters。 看起来很像是同一类的题目，想着用同一种方法去做，然后就考虑了好多奇奇怪怪的情况，最后代码写的及其混乱。 123456789101112131415161718192021222324int maxProduct(vector&lt;int&gt;&amp; nums) &#123; int i = 0,j = 0; int ret = INT_MIN; int now = 0; for(j = 0;j &lt; nums.size();j++)&#123; if (nums[j] == 0)&#123; while(now &lt; 0 &amp;&amp; i &lt; j -1) now /= nums[i++]; ret = max(ret,now); if (ret &lt; 0) ret = 0; now = 0; i = j+1; &#125; else &#123; now = (now)?now*nums[j]:nums[j]; ret = max(ret,now); &#125; &#125; while(now &lt; 0 &amp;&amp; i &lt; j - 1) now /= nums[i++]; ret = max(ret,now); return ret;&#125; 这还是做完后进行了一些删减的答案，看起来很复杂，要我现在去解释它都有点困难。 先提提我的思路： 和昨天的一样，我用两个下标来标识当前Subarray,也就是说，然后让j不断向前去遍历。 我需要考虑的就是什么时候i向前，我的想法是： 当我们遇到一个0时，我们需要把i改成j+1,因为正常情况下Subarray中如果有个0，那么Subarray的乘积就必定是0，为什么说是正常情况呢，因为如果当前最大乘积小于0的话，那么我们遇到一个0，要把最大乘积改成0. 但是如果我们遇到这样的数组2 -1 4 0,我们当前的策略的返回值是2，但真正应该是4，因此另一个i向前的情况是： 遇到一个0或遍历完整个数组，我们需要让i向前移动，直到让当前乘积变成大于0，或者到达j。 最后将这一大段思路变成代码就成了我上面写的了，其实仔细想想，这些思路其实并不复杂，只是有点繁琐，如果心能静点的话，应该可以更快的AC掉这道题。 下面是dicuss中的方法： 12345678910111213141516171819202122int maxProduct(int A[], int n) &#123; // store the result that is the max we have found so far int r = A[0]; // imax/imin stores the max/min product of // subarray that ends with the current number A[i] for (int i = 1, imax = r, imin = r; i &lt; n; i++) &#123; // multiplied by a negative makes big number smaller, small number bigger // so we redefine the extremums by swapping them if (A[i] &lt; 0) swap(imax, imin); // max/min product for the current number is either the current number itself // or the max/min by the previous number times the current one imax = max(A[i], imax * A[i]); imin = min(A[i], imin * A[i]); // the newly computed max value is a candidate for our global result r = max(r, imax); &#125; return r;&#125; 把注释去掉话，其实没几句话，说实话，第一次看没看懂，分析一下他的思路： 同样是遍历，但是它维护的不是下标，而是在A[0:j]中的子数组的最大值imax和子数组最小值imin. 他用的是减治法，大概的想法是，我们知道A[0:n-1]imax和imin，我们如果求出A[0:n]的imax,imin。 如果A[n]&gt;=0,那么imax = max(A[n],imax*A[n]);imin = min(A[n],imin*A[n]) 如果A[n] &lt; 0，那么imin = min(A[n],imax*A[n]);imax = max(A[n],imin*A[n])","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"动态规划","slug":"动态规划","permalink":"http://blog.codeand.fun/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"VBO_and_VAO.md","slug":"VBO-and-VAO-md","date":"2017-10-01T16:37:52.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2017/10/01/VBO-and-VAO-md/","link":"","permalink":"http://blog.codeand.fun/2017/10/01/VBO-and-VAO-md/","excerpt":"","text":"最近在写计算机图形学的期中作业，写一个简易的俄罗斯方块。在写的过程中感觉好像之前暑假看的OpenGL的东西都忘光光了，所以还是及时的写写笔记吧！ 顶点数组对象： Vertex Array Object,vao 顶点缓冲对象：Vertex Buffer Object,vbo 在敲代码的时候就觉得老是会搞混这两个概念，所以今天就总结一下。 先来段代码： 1234567891011121314151617181920212223242526void init() &#123; const int VERTICES_NUM = 3; vec3 vertices[VERTICES_NUM] = &#123; &#123;1.0,1.0,1.0&#125;, &#123;0.0,1.0,0.0&#125;, &#123;0.0,0.0,1.0&#125; &#125; GLuint vao[1]; glGenVertexArrays(1,vao); glBindVertexArray(vao[0]); GLuint buffer; glGenBuffers(1,&amp;buffer); glBindBuffer(GL_ARRAY_BUFFER, buffer); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices),vertices,CL_STATIC_DRAW); GLuint program = InitShader(\"vshader.glsl\",\"fshader.glsl\"); glUseProgram(program); GLuint location = glGetAttribLocation(program,\"vPosition\"); glEnableVertexAttribArray(location); glVertexAttribPointer(location,3,GL_FLOAT,GL_FALSE,0,BUFFER_OFFSET(0)); glClearColor(1.0,1.0,1.0,1.0);&#125; OpenGL里的对象都是通过id来管理的,有的地方叫做名字，或者说标识符，whatever,我们在这里统一用id。我们需要用glGen*模式的函数来获取未使用的id，这里的id可以想成是指针。 123GLuint vao[1]; //用来存放id的数组glGenVertexArrays(1,vao); //获取id，第一个参数是想要获取的个数 //第二个参数是存放这些id的数组 现在我们有了顶点数组对象的id了（换句话说，我们有了一个可以存放地址的指针），我们就需要真正的new一个对象出来。 1glBindVertexArray(vao); 如果vao非0，并且是glGenVertexArrays()返回的，那么它创建一个新的顶点数组，并且==并且与其名称向关联== 如果vao已经被绑定到一个顶点数组对象中，那么这个函数的作用就是激活这个顶点数组。 如果为0，那么OpenGL将不再使用程序所分配的顶点数组对象，并且OpenGL状态将重设为顶点数组的默认状态。 第一个很好理解就是等价于new,第二个作用可以理解为根据id获取对象（对指针解引用），第三个作用是在每次对某个顶点数组对象操作完后对当前顶点数组对象进行解绑。 有new就会有delete 12//void glDeleteVertexArray(GLsizei n,GLuint *arrays);glDeleteVertexArray(1,vao); 我们还可以判断一个id是否是一个用glGenVertexArray()创建并且没有被删除的顶点数组对象的id: 1GLboolean glIsVertexArray(GLuint array); 现在我们已经有一个vao了，但是我们好像还不知道vao有什么用，要回答这个问题，我们还需要一些其他的背景知识，所以这个问题放到后面再回答。 我们之所以需要VAO与VBO是因为我们想要把某些顶点数组发送给图像渲染pipeline，而pipleline需要接受一些Vertex Data,然后再进行一些变换或修改并渲染。 我们在定义了顶点数据之后，我们需要把他发送给顶点着色器，我们的顶点数据通常是放在GPU的内存中的，我们利用顶点缓冲对象(vertext buffer objects,vbo)进行管理 vbo也有相应的函数进行申请id，绑定等等，与vao类似： 12345678void glGenBuffers(GLsizei n,GLuint *buffers);void glBindBuffers(GLenum traget,GLuint buffer);//target 的值可以为：// GL_ARRAY_BUFFER// GL_ELEMENT_ARRAY_BUFFER// ...void glDeleteBuffers(GLsizei n,const GLuint *buffers);GLboolean glIsBuffers(GLuint buffer); 在申请完id并绑定后，我们可以想GPU的内存发送数组: 123456void glBufferData(GLenum target,GLsizeiptr size,cons GLvoid *data,GLenum usage);//target 与上面glBindBuffers的类似，//usage 是设置读取和写入的方式// GL_STREAM_DRAM// GL_DYNAMICDRAM// ... 在我们向GPU内存中发送完数据后，我们可能需要告诉OpenGL如何解释我们的数据: 123GLuint location = glGetAttribLocation(program,\"vPosition\");glEnableVertexAttribArray(location);glVertexAttribPointer(location,3,GL_FLOAT,GL_FALSE,0,BUFFER_OFFSET(0)); 我们先要向着色器程序获取顶点属性的位置值，即GLuint location = glGetAttribLocation(program,&quot;vPosition&quot;);我们应该可以在vshader.glsl中看到这样一句话in vec3 vPosition,他表示的是我们会给他一个类型为vec3的输入值，而glGetAttribLocation可以获取这个输入值的位置，这样我们才可以把我们的数据和这里的vPosition绑定起来。 glEnableVertexAttribArray(location)启用顶点属性（默认是禁用的) 而glVertexAttribPointer(location,3,GL_FLOAT,GL_FALSE,0,BUFFER_OFFSET(0));才是真正告诉OpenGL如何解释的函数。 他的参数解释分别为： 顶点属性的位置值 顶点属性大小，因为我们传入的是vec3,所以是3 数组类型 是否归一化 两个元素之间的偏移值 起始位置地址 有了这些东西，我们就可以绘制某个物体了，但是如果我们需要绘制多个物体呢，这时VAO的作用就出来了。 如果我们只使用VBO，我们可能需要重复的调用glVertexAttribPointer等。 我们可以通过VAO来管理这些琐碎的设置，一个VAO会存储以下内容： glEnableVertexAttribArray和glDisableVertexAttribArray的调用。 通过glVertexAttribPointer设置的顶点属性配置。 通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。 有了vao后，我们只需要在每次绘制前glBindVertexArray(vao)即可。","categories":[{"name":"Note","slug":"Note","permalink":"http://blog.codeand.fun/categories/Note/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://blog.codeand.fun/tags/OpenGL/"},{"name":"note","slug":"note","permalink":"http://blog.codeand.fun/tags/note/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://blog.codeand.fun/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"quickSort效率分析以及改进","slug":"quickSort效率分析以及改进","date":"2017-10-01T14:02:37.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2017/10/01/quickSort效率分析以及改进/","link":"","permalink":"http://blog.codeand.fun/2017/10/01/quickSort%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E6%94%B9%E8%BF%9B/","excerpt":"","text":"终于找到时间来写这个了。 上半个月一直在做算法课的实验，实验的大概内容是实现几个基本的排序算法，分别用不同的规模去测试然后进行分析。 恩，当然现在我只想扯扯快排。 先放段代码： 1234567891011121314151617181920212223void quicksort(int a[], int first, int last) &#123; //注意待排序列为: a[first,last] if (first &lt; last) &#123; //递归结束条件：first &gt;= last int mid = partition(a,first,last); //找出枢点 quicksort(a, first, q1 - 1); quicksort(a, q2 + 1, last); &#125;&#125;int partition(int a[], int first, int last) &#123; //O(last-first + 1) int key = a[first]; while (first &lt; last) &#123; //在两个循环中，当last在动时，first所指向的元素是多余的，反之亦然。 //所以当first和last指向同一个元素时，这个元素显然是多余的，而这个位置就是key最后的位置。 while (first &lt; last &amp;&amp; a[last] &gt;= key) last--; //注意要满足的是x &lt;= k &lt;= y a[first] = a[last]; while (first &lt; last &amp;&amp; a[first] &lt;= key) first++; //如果内层循环中的条件缺少=，会出现死循环。 a[last] = a[first]; &#125; a[first] = key; return first;&#125; 首先是测出的数据和利用比值的方法（基准是n=100000）计算的出来的理论值（单位是ms): 画成散点图： 由于n的差距过大，导致大部分点看不清，所以进行对数化在进行绘图： 从前面的数据我们可以发现快排时间复杂度是O(nlogn)，但是他其实是不稳定的。 我们向排序算法喂入一些比较极端的数据： 快排有一个比较奇葩的特性就是序列越乱越快。 我们对原来的算法进行一些改进： 12345678910111213141516int partition(int a[], int first, int last) &#123; //O(last-first + 1) swap(a[first],a[ rand() % (last - first + 1) ]); //让key的选取随机化 int key = a[first]; while (first &lt; last) &#123; //在两个循环中，当last在动时，first所指向的元素是多余的，反之亦然。 //所以当first和last指向同一个元素时，这个元素显然是多余的，而这个位置就是key最后的位置。 while (first &lt; last &amp;&amp; a[last] &gt;= key) last--; //注意要满足的是x &lt;= k &lt;= y a[first] = a[last]; while (first &lt; last &amp;&amp; a[first] &lt;= key) first++; //如果内层循环中的条件缺少=，会出现死循环。 a[last] = a[first]; &#125; a[first] = key; return first;&#125; 改进后，快排的在遇到顺序和倒序的序列时就不会出现最坏情况了： 但是对于重复序列，这个算法仍然不能很好的解决。 在《算法导论》快排那一章的习题中有提到一个算法去解决这种情况，大概的想法是每次分的时候把序列分成三个区域，第一个区域是小于key的值，第二个区域是等于key的值，第三个区域是大于key的值，这样遇到大量重复元素的时候，partition能够很好处理这种情况。 但是看完这个算法就想着实现以下： 1234567891011121314151617181920212223242526272829303132void partition(int a[], int first, int last, int &amp;q1, int &amp;q2) &#123; swap(a[first], a[first + rand() % (last - first + 1)]);//使得轴点的选取随机化，减少最坏情况的出现的概率 q1 = first; q2 = last; int key = a[first]; while (q1 &lt; q2) &#123; //在两个循环中，当last在动时，first所指向的元素是多余的，反之亦然。 //所以当first和last指向同一个元素时，这个元素显然是多余的，而这个位置就是key最后的位置。 while (q1 &lt; q2 &amp;&amp; a[q2] &gt;= key) q2--; //注意要满足的是x &lt;= k &lt;= y a[q1] = a[q2]; while (q1 &lt; q2 &amp;&amp; a[q1] &lt;= key) q1++; //如果内层循环中的条件缺少=，会出现死循环。 a[q2] = a[q1]; &#125; a[q1] = key; while (q1 &gt;= first &amp;&amp; a[q1 - 1] == key) q1--; //解决重复元素 while (q2 &lt;= last &amp;&amp; a[q2 + 1] == key) q2++;&#125;void quicksort(int a[], int first, int last) &#123; //注意待排序列为: a[first,last] if (first &lt; last) &#123; //递归结束条件：first &gt;= last int q1, q2; partition(a, first, last,q1,q2); //找出轴点的位置 //q1 = q2 = partition(a, first, last); quicksort(a, first, q1 - 1); quicksort(a, q2 + 1, last); int *b = new int[last - first + 1]; for (int i = first; i &lt;= last; i++) b[i - first] = a[i]; delete[] b; &#125;&#125; 其实仔细看的话，我这样写是没能达到三分的，不过他在处理大量重复数据的时候也能很好工作。 然后是真正实现三分的算法： 1234567891011121314151617181920void quickSort3Way(int a[], int lo, int hi) &#123; if (lo &lt; hi) return; int lt = lo; int i = lo + 1; int gt = hi; swap(a[lo], a[rand() % (hi - lo + 1)]); int v = a[lo]; while (i &lt;= gt) &#123; if (a[i] &lt; v) swap(a[lt++], a[i++]); else if (a[i] &gt; v) swap(a[i], a[gt--]); else i++; &#125; quickSort3Way(a,lo, lt - 1); quickSort3Way(a,gt + 1, hi);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.codeand.fun/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://blog.codeand.fun/tags/%E7%AE%97%E6%B3%95/"},{"name":"sort","slug":"sort","permalink":"http://blog.codeand.fun/tags/sort/"}]},{"title":"Longest Substring Without Repeating Characters","slug":"LongestSubstringWithoutRepeatingCharacters","date":"2017-10-01T13:20:00.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/10/01/LongestSubstringWithoutRepeatingCharacters/","link":"","permalink":"http://blog.codeand.fun/2017/10/01/LongestSubstringWithoutRepeatingCharacters/","excerpt":"","text":"Longest Substring Without Repeating Characters打卡，第8天 今天国庆，然而不会家，找了一道之前不敢做的题目做了——Longest Substring Without Repeating Characters,开始又是想着用分治法去完成（因为算法课在讲分治法），然而并没有做出来，又是同一个原因，在治的时候复杂度降不下来。 题目描述： Given a string, find the length of the longest substring without repeating characters. Examples: Given “abcabcbb”, the answer is “abc”, which the length is 3. Given “bbbbb”, the answer is “b”, with the length of 1. Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring. 先放code吧： 1234567891011121314int lengthOfLongestSubstring(string s) &#123; int i = 0,j = 0; int ret = 0; map&lt;char,bool&gt; cbmap; while( j &lt; s.size() )&#123; while(j &lt; s.size() &amp;&amp; cbmap[s[j]] == false) cbmap[ s[j++] ] = true; ret = max(j-i,ret); while(i &lt; j &amp;&amp; cbmap[s[j]] != false) cbmap[ s[i++] ] = false; cbmap[ s[j++] ] = true; &#125; return ret;&#125; 大概的思路是： 用两个下标来标识Substring的位置，s[i,j)就是我们当前的Substring. 用j去遍历整个串，如果当前子串中没有s[j]，j就继续往下遍历，如果有，这时就可以计算一下当前子串的长度和之前的最长子串长度进行对比。 在j停止遍历后，我们就让i向前移动，直到，当前子串不包含s[j],这样我们就可以把s[j]加入当前子串，并继续进行遍历。 写着写着突然发现，有个地方可以改： 123456789101112int lengthOfLongestSubstring(string s) &#123; int ret = 0; map&lt;char,bool&gt; cbmap; for(int i = 0,j = 0; j &lt; s.size();j++ )&#123; while(j &lt; s.size() &amp;&amp; cbmap[s[j]] == false) cbmap[ s[j++] ] = true; ret = max(j-i,ret); while(i &lt; j &amp;&amp; s[i++] != s[j]) cbmap[ s[i - 1] ] = false; &#125; return ret;&#125; 思路还是一样的，只不过写的更加精炼了罢了。 然后看看dicuss中别人写的： 12345678910111213int lengthOfLongestSubstring(string s) &#123; // for ASCII char sequence, use this as a hashmap vector&lt;int&gt; charIndex(256, -1); int longest = 0, m = 0; for (int i = 0; i &lt; s.length(); i++) &#123; m = max(charIndex[s[i]] + 1, m); // automatically takes care of -1 case charIndex[s[i]] = i; longest = max(longest, i - m + 1); &#125; return longest;&#125; 他这里用的是vector&lt;int&gt;去记录最大的下标，而我是用的是map去记录当前子串中是否有这个字符，用他这种方法可以把i向前移的循环给去掉。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"串","slug":"串","permalink":"http://blog.codeand.fun/tags/%E4%B8%B2/"}]},{"title":"Add Two Numbers","slug":"AddTwoNumbers","date":"2017-09-30T00:00:00.000Z","updated":"2020-04-02T14:43:48.831Z","comments":true,"path":"2017/09/30/AddTwoNumbers/","link":"","permalink":"http://blog.codeand.fun/2017/09/30/AddTwoNumbers/","excerpt":"","text":"打卡，第7天 You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8 从示例来看，这里的digits应该是倒过来的，即2-&gt;4-&gt;3表示的是342 如果它不是倒过来的话，我们可能还需要用栈去将元素取出来。 虽然这是一道Medium的题目，但是难度其实很小，思路大概是： 将当期指针所指向的值相加得到一个数x，那么x%10就是这个位应该为的数，x/10就是进位，所以算法思路很简单： 12345678910111213141516171819202122232425262728293031ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; int ans,add = 0; ListNode ret(0); //头结点让单链表操作变简单 ListNode *p = &amp;ret; while(l1 != nullptr &amp;&amp; l2 != nullptr)&#123; ans = (l1-&gt;val + l2-&gt;val) + add; //记得加上进位 add = ans/10; //求出进位 p-&gt;next = new ListNode(ans%10); p = p-&gt;next; l1 = l1-&gt;next; l2 = l2-&gt;next; &#125; while(l1)&#123; ans = l1-&gt;val + add; add = ans/10; p-&gt;next = new ListNode(ans%10); p = p-&gt;next; l1 = l1-&gt;next; &#125; while(l2)&#123; ans = l2-&gt;val + add; add = ans/10; p-&gt;next = new ListNode(ans%10); p = p-&gt;next; l2 = l2-&gt;next; &#125; if (add != 0) p-&gt;next = new ListNode(add);//记得出来进位不为0的情况 return ret.next;&#125; dicuss中还有一个更精炼的写法： 1234567891011121314ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode ret(0); ListNode *p = &amp;ret; int add = 0,sum; while(l1 || l2 || add)&#123; sum = (l1?l1-&gt;val:0) + (l2?l2-&gt;val:0) + add; add = sum/10; p-&gt;next = new ListNode(sum%10); p = p-&gt;next; l1 = (l1?l1-&gt;next:nullptr); l2 = (l2?l2-&gt;next:nullptr); &#125; return ret.next;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://blog.codeand.fun/tags/%E9%93%BE%E8%A1%A8/"},{"name":"算法","slug":"算法","permalink":"http://blog.codeand.fun/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"加一","slug":"加一","date":"2017-09-29T21:55:00.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2017/09/29/加一/","link":"","permalink":"http://blog.codeand.fun/2017/09/29/%E5%8A%A0%E4%B8%80/","excerpt":"","text":"打卡，第6天 今天不知道为什么网速特别慢，LeetCode几乎没法用，所以就改成在LintCode上刷了。 给定一个非负数，表示一个数字数组，在该数的基础上+1，返回一个新的数组。 该数字按照大小进行排列，最大的数在列表的最前面。 因为今晚出去浪了，就找了一道Easy的题目。 实现代码： 12345678910vector&lt;int&gt; plusOne(vector&lt;int&gt; &amp;digits) &#123; // write your code here int a = 1; for(auto it = digits.rbegin();it != digits.rend();++it) &#123; if ((*it += a) &lt; 10) return digits; *it = 0; &#125; digits.insert(digits.begin(),1); return digits;&#125; 思路很简单，而且因为只是加一，所以for循环里面的东西可以写的简单一点。 今天终于把算法实验课的演示搞定了，明天或后天把东西整理一下，把排序算法的分析放出来。","categories":[{"name":"LintCode","slug":"LintCode","permalink":"http://blog.codeand.fun/categories/LintCode/"}],"tags":[{"name":"LintCode","slug":"LintCode","permalink":"http://blog.codeand.fun/tags/LintCode/"}]},{"title":"约瑟夫环","slug":"约瑟夫环实现","date":"2017-09-28T19:12:00.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2017/09/28/约瑟夫环实现/","link":"","permalink":"http://blog.codeand.fun/2017/09/28/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"今天上数据结构实验课，有道题是约瑟夫环，感觉挺好玩的，就拿出来总结一下（今天的LeetCode那道题真的是太Easy了）。 约瑟夫环是一个数学的应用问题：已知n个人（以编号1，2，3…n分别表示）围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列。 这里是用双向循环链表实现的： 先是类的申明： 1234567891011121314151617181920212223242526class JCircle;class ListNode&#123; int val; ListNode *next,*prior;public: ListNode(int v,ListNode *n = NULL,ListNode *p = NULL) :val(v),next(n),prior(p)&#123;&#125; friend class JCircle; int getVal()&#123; return val; &#125; ListNode *getNext() &#123; return next; &#125; ListNode *getPrior() &#123; return prior; &#125;&#125;;class JCircle&#123; ListNode *head; int size; public: JCircle(int n); ~JCircle(); void move(int k); //向前移动k步 int del(); //删除head所指向的ListNode并返回其 val int count(int k); //报数 friend ostream &amp;operator&lt;&lt;(ostream&amp; out,JCircle &amp;jc); bool empty() &#123; return size == 0; &#125;&#125;; 类的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768JCircle::JCircle(int n) :head(NULL),size(0)&#123; if (n &lt;= 0) return; size = n; head = new ListNode(1,NULL,NULL); head-&gt;next = head; head-&gt;prior = head; ListNode *p = head; for(int i = 2;i &lt;= n;i++) &#123; p-&gt;next = new ListNode(i,p-&gt;next); p-&gt;next-&gt;prior = p; p = p-&gt;next; &#125; head-&gt;prior = p;&#125;JCircle::~JCircle()&#123; ListNode *p; while(size--)&#123; p = head; head = head-&gt;next; delete p; &#125;&#125;void JCircle::move(int k)&#123;// cout &lt;&lt; \"move\"; for(int i = 1;i &lt; k;i++) head = head-&gt;next;// cout &lt;&lt; \" over\\n\";&#125;int JCircle::del()&#123; if (size == 2)&#123; ListNode *p = head; int ret = p-&gt;val; head = head-&gt;next; delete p; head-&gt;next = head-&gt;prior = head; size--; return ret; &#125; size--; head-&gt;next-&gt;prior = head-&gt;prior; head-&gt;prior-&gt;next = head-&gt;next; ListNode *p = head; int t = p-&gt;val; head = head-&gt;next; delete p; return t;&#125; int JCircle::count(int k)&#123; move(k);// cout &lt;&lt; \"count\"; return del();&#125;ostream &amp;operator&lt;&lt;(ostream&amp; out,JCircle &amp;jc)&#123; ListNode *p = jc.head; int n = jc.size; while(n--)&#123; out &lt;&lt; p-&gt;getVal() &lt;&lt; \" \"; p = p-&gt;getNext(); &#125; //out &lt;&lt; \"asdsad\\n\"; return out;&#125; 测试： 12345678910111213141516int main() &#123; //test //人数 开始位置 报数 int n, k, m; while(cin &gt;&gt; n &gt;&gt; k &gt;&gt; m)&#123; JCircle jc(n); jc.move(k); //cout &lt;&lt; jc &lt;&lt; endl; while(!jc.empty()) cout &lt;&lt; jc.count(m) &lt;&lt; \" \"; cout &lt;&lt; endl; &#125; return 0;&#125; 想写这个的原因是，我写了很久，事实上回到宿舍写多一遍的时候，我也写了很久（现在是20:16:00），写了一个多小时了，感觉自己还不怎么熟悉一些的基本数据结构（虽然已经在之前的学院上过一次了，恩，相当水的一门课）。 重写一遍的感觉是，该掉的坑，我还是掉下去了，之前写了的一遍的效果就是，我能比较快的爬出来，而且不会纠结于选择双向链表还是单向链表。 写的过程中，也体会了一下双向链表的坑点： size==2时，不能用常规方法delete掉自己。 加入size会减少一些常见的错误，一些实现敲起来也会简单点（唯一一个一开始就选择正确的点）。 感觉以后要多总结一些一些基本的数据结构，不然做算法题的时候，会很难找到适合的数据结构。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://blog.codeand.fun/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"循环链表，双向链表，数据结构","slug":"循环链表，双向链表，数据结构","permalink":"http://blog.codeand.fun/tags/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%EF%BC%8C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Merge Two Sorted List","slug":"MergeTwoSortedList","date":"2017-09-28T11:06:00.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/09/28/MergeTwoSortedList/","link":"","permalink":"http://blog.codeand.fun/2017/09/28/MergeTwoSortedList/","excerpt":"","text":"打卡，第五天 今天偷个懒，找下自信先，做个Easy的题目——Merge Two Sorted List （我也没想到是这么简单的题目） 之前在 LintCode做个一个链表排序，也写过一篇blog解这道题时用的是MergeSort去做.所以已经写过一次Merge Two Sorted List了，之前的写法是这样的： 123456789101112131415161718192021ListNode *mergeList(ListNode *l1,ListNode *l2)&#123; if (!l1) return l2; else if (!l2) return l1; ListNode* ret = new ListNode(0); ListNode*p = ret; while(l1 &amp;&amp; l2) &#123; if (l1-&gt;val &gt; l2-&gt;val) &#123; ret-&gt;next = l2; ret = ret-&gt;next; l2 = l2-&gt;next; &#125; else &#123; ret-&gt;next = l1; ret = ret-&gt;next; l1 = l1-&gt;next; &#125; &#125; ret-&gt;next = (l1)?l1:l2; ret = p-&gt;next; delete p; return ret;&#125; 这次做一个小改进（可能时间复杂度上没有改进）： 123456789101112131415161718ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode* head = new ListNode(0); ListNode* ret = head; while(l1 || l2) &#123; if ((l1 &amp;&amp; l2 &amp;&amp; l1-&gt;val &gt; l2-&gt;val )|| !l1) &#123; head-&gt;next = l2; head = head-&gt;next; l2 = l2-&gt;next; &#125;else &#123; head-&gt;next = l1; head = head-&gt;next; l1 = l1-&gt;next; &#125; &#125; head = ret-&gt;next; delete ret; return head; &#125; 恩，细细想想，这个思路效率可能跟慢，不过用在对数组的Merge的情况还是可以的（起码比较简洁）。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"链表","slug":"链表","permalink":"http://blog.codeand.fun/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"Container With Most Water","slug":"Container_With_Most_Water","date":"2017-09-27T13:47:00.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/09/27/Container_With_Most_Water/","link":"","permalink":"http://blog.codeand.fun/2017/09/27/Container_With_Most_Water/","excerpt":"","text":"打卡，第四天 今天的题目是Container With Most Water Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.Note: You may not slant the container and n is at least 2. 很烦，今天老是时间超限，就是不能想出一个时间复杂度小的算法来。 先理解一下题目先，大概就是给你一个数组height，你要找出两个i，j使得min(height[i],height[j])*(j - i)最大。 很容易写出一个$ O(n^{2}) $ 的算法出来： 123456789int maxArea(vector&lt;int&gt; &amp;height) &#123; int water = 0; for(int i = 0;i &lt; height.size(); ++i) for (int j = 0;j &lt; height.size(); ++j) &#123; int h = min(height[i],height[j]); water = max(water,h*(j - i)); &#125; return water;&#125; 但是这个算法是不能过最后一个测例的。 想了一个小时都没想出一个好方法来减少他的复杂度,后来就去翻dicuss，看到这样一个算法： 12345678910int maxArea(vector&lt;int&gt; &amp;height) &#123; int water = 0; int i = 0,j = height.size() - 1; while(i &lt; j) &#123; int h = min(height[i],height[j]); water = max(water,h*(j - i)); while(height[i] &lt;= h &amp;&amp; i &lt; j) i++; while(height[j] &lt;= h &amp;&amp; i &lt; j) j++; &#125;&#125; 这里是先取最宽的容器，假设他就是我们要的结果。因为i不断变大,j不断变小，这样wide就不断变小，因为wide在变小，要比当前最大的容器还大的话就只能比当前高度高，这就是那两个while的作用，去除掉一个不可能的情况。 啊，我真菜，为什么老是想不出来呢！","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Pow(x,n)","slug":"Pow(x,y)","date":"2017-09-26T12:17:00.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/09/26/Pow(x,y)/","link":"","permalink":"http://blog.codeand.fun/2017/09/26/Pow(x,y)/","excerpt":"","text":"打卡第三天！！！ 今天刷的题是Pow(x,n) implement pow(x,n) 题目相当简洁，看起来好像也不会很难的样子，不过他竟然是一道Medium的题目（万万没想到）.pow(x,n)大家应该都多少有接触过，就是求x的n次方嘛。我们可以把n分成三种情况去考虑： n &gt; 0 ： 可以转化成求myPow(1/x,-n) n == 0 ：直接return 1即可 n &lt; 0 ：这个是我们实现的关键，只要完成这个就可以AC这道题了。 首先，一个最简单的思路就是n个x相乘. 1234double ret = 1for(int i = 0;i &lt; n;i++) ret *= x;return ret 这样需要做n次乘法，时间复杂度是O(n),在LeetCode中，这样做是会超时的，我们需要找到一个 时间复杂度更小的算法。 可以考虑使用分治法去完成：也就是说，我们要求myPow(x,n)的值，那我们可以转化成求myPow(x,n/2)的值，然后将其返回值乘二即可（n为奇数，还需要 乘多一个x）。 12double ret = myPow(x,n/2);return (n%2)?(ret*ret*x):(ret*ret); 这是递归的做法，显然这已经能够完成了,这也是我的做法。这里面还有一个坑点没提到，就是在n &lt; 0的情况下，我们前面的做法是直接return myPow(1/x,-n)的，但是这样是会出错的：当n=-2147483648时，会出现RunTime Error，也就是那个-n是求不出来的，因为int类型的最大值为2147483647。这里用了一个小技巧：return myPow(1/x, -(n + 1) ) *1/x; 因为这里的n满足n &lt; 0，所以可以不用考虑正溢出的情况。 完整的代码为： 12345678910double myPow(double x, int n) &#123; if (n == 0) return 1; else if (n &gt; 0) &#123; double ret = myPow(x,n/2); return (n%2)?ret*ret*x:ret*ret; &#125; else &#123; //n &lt; 0 return myPow(1/x,-(n + 1 )) * 1/x; &#125;&#125; 恩，按照惯例，看看dicuss中别人的做法: 123456789101112131415161718double myPow(double x, int n) &#123; double ans; unsigned long long; if ( n &lt; 0 ) &#123; p = -n; x = 1/x; &#125; else &#123; p = n; &#125; while(p) &#123; if (p &amp; 1) ans *= x; x *= x; p &gt;&gt;= 1; &#125;&#125; 看到这个做法的第一眼就想起了某位老师说的： “有时候你需要从二进制的角度去看问题。” 我们来考虑myPow(a,7)的情况：7的二进制编码为：0000 0111,也就是7 = 4 + 2 + 1而 $ a^{7} = a^{4} * a^{2} * a^{1} $相信上面的代码应该能够很容易的看懂了。另外我们还可以看到，他用unsigned long long来避免溢出的情况，这也是一个小技巧。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"算法","slug":"算法","permalink":"http://blog.codeand.fun/tags/%E7%AE%97%E6%B3%95/"}],"author":"wuxiaobai24"},{"title":"Longest Common Prefix","slug":"LongestCommonPrefix","date":"2017-09-25T09:59:00.000Z","updated":"2020-04-02T14:43:48.835Z","comments":true,"path":"2017/09/25/LongestCommonPrefix/","link":"","permalink":"http://blog.codeand.fun/2017/09/25/LongestCommonPrefix/","excerpt":"","text":"恩，今天早上1,2节没课，闲来无事就先把今天的题刷了（你的算法分析实验呢？）今天的题目是Longest Common Prefix,恩，比那个什么最长公共子串简单多了，很容易就可以找到思路（虽然写出来的代码很难看） 大概的解题思路是： 先找出最短的字符串，假定他就是我们要的答案 遍历所有字符串，看他们是否有这个字符串 如果有就直接返回 如果没有就把子串长度减小，再进行重复操作 思路很简单，但我写的很渣（直接过，我也是很懵，我还想再敲多一下的） 先上我的代码吧： 12345678910111213141516171819202122232425262728293031323334353637string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if (strs.empty()) return \"\"; else if (strs.size() == 1) return strs[0]; string ret = strs[0]; for(auto &amp;s:strs) &#123; if (ret.size() &gt; s.size()) ret = s; &#125; while(ret.size() &gt; 0) &#123; bool is = true; for(auto &amp;s:strs)&#123; if (s.substr(0,ret.size()) != ret) &#123; is = false; break; &#125; &#125; if (!is) ret = ret.substr(0,ret.size() - 1); else return ret; &#125; return \"\"; &#125;``` 恩，我是没想到它会直接过的，思路相当简单，当然思路简单一般效率就不会很高。我的思路一开始是假定最短的串是我们要的结果，而在`dicuss`中别人的写法是另一种思路：```c++string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; string prefix = \"\"; for(int idx=0; strs.size()&gt;0; prefix+=strs[0][idx], idx++) for(int i=0; i&lt;strs.size(); i++) if(idx &gt;= strs[i].size() ||(i &gt; 0 &amp;&amp; strs[i][idx] != strs[i-1][idx])) return prefix; return prefix;&#125; 比我的代码简洁很多，他是先假定最长前缀是空，然后在用动态规划的思路去做的（恩，要好好研究一下动态规划），而且他这种写法就不需要判断传入的vector是不是空了。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"},{"name":"串","slug":"串","permalink":"http://blog.codeand.fun/tags/%E4%B8%B2/"}]},{"title":"Valid Parentheses","slug":"Valid-Parentheses","date":"2017-09-24T23:23:00.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2017/09/24/Valid-Parentheses/","link":"","permalink":"http://blog.codeand.fun/2017/09/24/Valid-Parentheses/","excerpt":"","text":"恩，照常打个卡（差点忘记）。。。。 由于比较晚才发现要刷个题（捂脸），所以找了个Easy的题目——Valid Parentheses Given a string containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid. The brackets must close in the correct order, &quot;()&quot; and &quot;()[]{}&quot; are all valid but &quot;(]&quot; and &quot;([)]&quot; are not. 很经典（很简单）的题目——括号匹配，显然用个栈来完成是最简单的了： 12345678910111213141516171819202122232425bool isValid(string str) &#123; stack&lt;char&gt; s; for(auto c:str)&#123; switch(c)&#123; case '(':case '&#123;': case '[': s.push(c); break; case ')': if (s.empty() || s.top() != '(') return false; s.pop(); break; case '&#125;': if (s.empty() || s.top() != '&#123;') return false; s.pop(); break; case ']': if (s.empty() || s.top() != '[') return false; s.pop(); break; default: return false; &#125; &#125; return s.empty()&#125; 恩，好像没什么难度，多注意点细节就好了。 做完之后顺手看了一下Discuss,看了一下别人的实现，同样是c++，同样的方法，为什么别人写的看起来就很舒服呢？ 一起来对比一下: 123456789101112131415bool isValid(string s) &#123; stack&lt;char&gt; paren; for (char&amp; c : s) &#123; switch (c) &#123; case '(': case '&#123;': case '[': paren.push(c); break; case ')': if (paren.empty() || paren.top()!='(') return false; else paren.pop(); break; case '&#125;': if (paren.empty() || paren.top()!='&#123;') return false; else paren.pop(); break; case ']': if (paren.empty() || paren.top()!='[') return false; else paren.pop(); break; default: ; // pass &#125; &#125; return paren.empty() ;&#125; 突然很嫌弃自己的代码风格！！！","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"Stack","slug":"Stack","permalink":"http://blog.codeand.fun/tags/Stack/"},{"name":"String","slug":"String","permalink":"http://blog.codeand.fun/tags/String/"}]},{"title":"3Sum","slug":"3Sum","date":"2017-09-20T12:00:00.000Z","updated":"2020-04-02T14:43:48.831Z","comments":true,"path":"2017/09/20/3Sum/","link":"","permalink":"http://blog.codeand.fun/2017/09/20/3Sum/","excerpt":"","text":"3Sum觉得立个flag：从今天开始每天在LeetCode刷一道题,今天的是3Sum 题目： Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. For example, given array S = [-1, 0, 1, 2, -1, -4], A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 这个题的坑点有几个： 它要求的是不同的，但是如果处理的不好的话，是很容易出现相同的。 第二个是他很容易写出一个O(n^3)的算法，但是好像是跑不过去的。 接近的大概思路是： 先对数组进行排序，这样比较好解决第一个坑点 把他转换成2Sum去做 12345678910111213141516171819202122232425262728293031vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt; &gt; ret; sort(nums.begin(),nums.end()); //先进行排序 for(int i = 0; i &lt; nums.size() - 2;i++) &#123; int target = -nums[i]; //转换成求2Sum if (target &lt; 0) break; int beg = i + 1; int end = nums.size() - 1; while(beg &lt; end) &#123; int sum = nums[beg] + nums[end]; if (sum &lt; target) beg++; else if (sum &gt; target) end--; else &#123; int n1 = nums[beg]; int n2 = nums[end]; ret.push_back( &#123;nums[i],nums[beg],nums[end]&#125; ); //处理重复 while(beg &lt; end &amp;&amp; nums[beg] == n1) beg++; while(beg &lt; end &amp;&amp; nums[end] == n2) end--; &#125; &#125; //处理重复 while(i + 1 &lt; nums.size()- 2 &amp;&amp; nums[i + 1] == nums[i]) i++; &#125; return ret; &#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"Different Ways to Add Parentheses","slug":"different-ways-to-add-parentheses","date":"2017-09-20T12:00:00.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2017/09/20/different-ways-to-add-parentheses/","link":"","permalink":"http://blog.codeand.fun/2017/09/20/different-ways-to-add-parentheses/","excerpt":"","text":"Different Ways to Add Parentheses 开始每天坚持刷OJ和Paper吧。 今天的题目是 Different Ways to Add Parentheses : Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *. Example 1: 12345Input: &quot;2-1-1&quot;Output: [0, 2]Explanation: ((2-1)-1) &#x3D; 0 (2-(1-1)) &#x3D; 2 Example 2: 12345678Input: &quot;2*3-4*5&quot;Output: [-34, -14, -10, -10, 10]Explanation: (2*(3-(4*5))) &#x3D; -34 ((2*3)-(4*5)) &#x3D; -14 ((2*(3-4))*5) &#x3D; -10 (2*((3-4)*5)) &#x3D; -10 (((2*3)-4)*5) &#x3D; 10 太久没刷过题的后果就是之前掌握的一些解题思路好像有点生疏了，但还是勉强完成了这道题，首先从两个Example开始分析，第一个太简单好像看不出什么，我们分析一下第二个，我们可以看到，(2*(3-(4*5))) = -34是先算第二个*，然后再算-，最后算第一个*。大概可以猜出来我们需要穷举所有运算顺序，但应该不是全排列，因为当运算符个数为3时，他的运算顺序只有5个，而不是6个。仔细分析一下可以发现，这是因为已下两种算法是一样的： 先算第一个，再算第三个，最后算第二个 先算第三个，再算第一个，最后算第二个 这就有点像一个二叉树了，层数相同的情况。我们尝试把上面五种运行顺序用二叉树表示出来，首先，分别用1,2,3代替*,-,*: 123451 \\ 2 \\ 3 123 2 &#x2F; \\1 3 123451 \\ 3 &#x2F;2 12345 1 &#x2F;3 \\ 2 12345 3 &#x2F; 2 &#x2F;1 画出来后，我们很容易的发现，这个问题变成了对平衡二叉树的穷举问题，因此代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354vector&lt;int&gt; nums;vector&lt;char&gt; ops;vector&lt;int&gt; diffWaysToCompute(string input) &#123; vector&lt;int&gt; res; int num; char op; stringstream ss(input); ss &gt;&gt; num; nums.push_back(num); while(ss &gt;&gt; op &gt;&gt; num) &#123; nums.push_back(num); ops.push_back(op); &#125; helper(0, ops.size(), res); return res;&#125;int calc(char op, int i1, int i2) &#123; int res = 0; switch(op) &#123; case '+': res = i1 + i2; break; case '-': res = i1 - i2; break; case '*': res = i1 * i2; break; &#125; return res;&#125;void helper(int first, int last, vector&lt;int&gt; &amp;outputs) &#123; if (first == last) &#123; outputs.push_back(nums[first]); return ; &#125; vector&lt;int&gt; lefts; vector&lt;int&gt; rights; for(int i = first; i &lt; last;i++) &#123; // select ops[i] in this layer lefts.clear(); rights.clear(); helper(first, i, lefts); helper(i+1, last, rights); for(auto l: lefts) &#123; for(auto r: rights) &#123; outputs.push_back(calc(ops[i], l, r)); &#125; &#125; &#125;&#125; 由于stringstream的效率的确不行，所以我们可以尝试将解析字符串的那段代码改成： 123456789int beg = 0, end = 0;for(;end &lt; input.size(); end++) &#123; if (input[end] == '+' || input[end] == '-' || input[end] == '*') &#123; nums.push_back(stoi(input.substr(beg, end - beg))); ops.push_back(input[end]); beg = end + 1; &#125;&#125;nums.push_back(stoi(input.substr(beg, end - beg)));","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.codeand.fun/tags/LeetCode/"}]},{"title":"链表排序","slug":"链表排序","date":"2017-09-19T13:45:00.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2017/09/19/链表排序/","link":"","permalink":"http://blog.codeand.fun/2017/09/19/%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F/","excerpt":"","text":"今天中午在Lintcode上刷了一道题——链表排序 题目很短： 在 O(n log n) 时间复杂度和常数级的空间复杂度下给链表排序。 最近几天也在做排序算法的实验，所以看到这道题想刷一下。 从题目的要求我们可以大概的想出几种能达到要求的排序： 快速排序 归并排序 这里是归并排序的实现： 归并排序的大概思路是： 在待排序列中找到中间元素，将待排序列分成两个待排序列，分别对这两个待排序列递归地调用归并排序，当待排序列中元素只剩一个时，序列显然有序。 现在只需要将两个有序序列合并成一个有序序列。 实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class ListNode &#123;public: int val; ListNode* next; ListNode(int v):val(v),next(nullptr)&#123;&#125;&#125;ListNode * sortList(ListNode * head) &#123; // write your code here if (!head || !head-&gt;next) return head; ListNode *fast,*slow; fast = slow = head; while(fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; fast = slow; slow = slow-&gt;next; fast-&gt;next = nullptr; fast = sortList(head); slow = sortList(slow); return mergeList(fast,slow);&#125;ListNode *mergeList(ListNode *l1,ListNode *l2)&#123; if (!l1) return l2; else if (!l2) return l1; ListNode* ret = new ListNode(0); ListNode*p = ret; while(l1 &amp;&amp; l2) &#123; if (l1-&gt;val &gt; l2-&gt;val) &#123; ret-&gt;next = l2; ret = ret-&gt;next; l2 = l2-&gt;next; &#125; else &#123; ret-&gt;next = l1; ret = ret-&gt;next; l1 = l1-&gt;next; &#125; &#125; ret-&gt;next = (l1)?l1:l2; ret = p-&gt;next; delete p; return ret;&#125; 这里的难点就是找出中间元素，将一个序列分成两个序列，这里的实现是快慢指针来实现的，即： 123456ListNode *fast,*slow;fast = slow = head;while(fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next;&#125;","categories":[{"name":"算法实现","slug":"算法实现","permalink":"http://blog.codeand.fun/categories/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"}],"tags":[]},{"title":"关于Blog","slug":"关于Blog","date":"2017-09-18T08:45:00.000Z","updated":"2020-04-02T14:43:48.839Z","comments":true,"path":"2017/09/18/关于Blog/","link":"","permalink":"http://blog.codeand.fun/2017/09/18/%E5%85%B3%E4%BA%8EBlog/","excerpt":"","text":"早在很久之前就想弄个Blog了，先后试过博客园，CSDN，简书这些现有的博客网站，恩，但是都没写几篇就把他忘记了。后来也想自己写一个，github中flask-study就是这样来的，然而死在了前端上。。。 昨天可能考完CCF CSP有点懵，就开始想搞个blog，一开始也想着继续学学前端，自己搭一个出来，后来想着这学期课有点多，不知道要多久才能搭完，就先用github pages＋hexo 搭一个用用先。 说到CCF CSP就有点心塞，连续两年都是没做完第三题（搞得我会第四题一样），最烦的是每年第三天都是写一个Parser。今年是json,去年是Markdown。每次都做得很蹦，希望能混到几十分吧。 说到底，还是自己太渣了，每次写一些复杂的逻辑的时候，感觉大脑就不够用了，一旦程序达到300行，就开始有点接受不了了。这次考试暴露自己挺多不足的地方： 数据结构的底子还不够扎实。 一遇到图就直接崩，遇到适合树结构的也不敢用。 不会写注释 从这次做题的时候就可以感觉出来，如果一开始敲的时候加一些注释，后面就不会看自己代码都需要想好久，而且最近在写的sort算法，也不会记一些注释，写的时候老是觉得很简单，自己可以很容易记住，然而每次都打自己的脸。 遇事没有韧性 总感觉自己老是会放弃，做题时也是这样，做第三题时老是想着“要不不写了，直接走吧”，好在忍了下来，不然估计连几十分都不敢奢望。 对STL根本不熟悉 即使翻着书也不写不好，总是会忘记一下东西，最后还是用c那一套写了一堆。 不会组织程序结构 总是会写出一个很长的函数，明明很多时候是可以把一些实现分成函数，然后分别测试的。在想要实现一个东西的时候，首先做得是打开编辑器开写，而不是思考怎么做。 总结的有点心塞。。。 一点一点的改变吧。 把树和图的一些基本算法实现出来（开一个repositories来放一些算法） 写好注释（起码能让自己几天后一看就知道自己当时想的是什么） 坚持写blog，起码每周更新一次 尝试着研究一下STL（如果有时间的话，捂脸） 路还远着呢！","categories":[{"name":"杂事一堆","slug":"杂事一堆","permalink":"http://blog.codeand.fun/categories/%E6%9D%82%E4%BA%8B%E4%B8%80%E5%A0%86/"}],"tags":[]}]}